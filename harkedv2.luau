local G2L = {};

-- StarterGui.main
G2L["1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"));
G2L["1"]["Name"] = [[main]];
G2L["1"]["ResetOnSpawn"] = false;


-- StarterGui.main.top
G2L["2"] = Instance.new("Frame", G2L["1"]);
G2L["2"]["Active"] = true;
G2L["2"]["BackgroundColor3"] = Color3.fromRGB(48, 48, 48);
G2L["2"]["Size"] = UDim2.new(0, 291, 0, 30);
G2L["2"]["Position"] = UDim2.new(0.61215, 13, 0.31197, -51);
G2L["2"]["BorderColor3"] = Color3.fromRGB(30, 30, 30);
G2L["2"]["Name"] = [[top]];
G2L["2"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.back
G2L["3"] = Instance.new("Frame", G2L["2"]);
G2L["3"]["BorderSizePixel"] = 0;
G2L["3"]["BackgroundColor3"] = Color3.fromRGB(48, 48, 48);
G2L["3"]["Size"] = UDim2.new(0, 293, 0, 293);
G2L["3"]["Position"] = UDim2.new(-0.00344, 0, 1, 0);
G2L["3"]["BorderColor3"] = Color3.fromRGB(30, 30, 30);
G2L["3"]["Name"] = [[back]];
G2L["3"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.kill
G2L["4"] = Instance.new("TextButton", G2L["2"]);
G2L["4"]["BorderSizePixel"] = 0;
G2L["4"]["TextSize"] = 23;
G2L["4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["4"]["BackgroundTransparency"] = 0.5;
G2L["4"]["Size"] = UDim2.new(0, 134, 0, 40);
G2L["4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4"]["Text"] = [[Kill]];
G2L["4"]["Name"] = [[kill]];
G2L["4"]["Position"] = UDim2.new(0.02062, 0, 1.76667, 0);


-- StarterGui.main.top.kill.LocalScript
G2L["5"] = Instance.new("LocalScript", G2L["4"]);



-- StarterGui.main.top.btools
G2L["6"] = Instance.new("TextButton", G2L["2"]);
G2L["6"]["BorderSizePixel"] = 0;
G2L["6"]["TextSize"] = 23;
G2L["6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["6"]["BackgroundTransparency"] = 0.5;
G2L["6"]["Size"] = UDim2.new(0, 131, 0, 40);
G2L["6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6"]["Text"] = [[Btools]];
G2L["6"]["Name"] = [[btools]];
G2L["6"]["Position"] = UDim2.new(0.52577, 0, 1.76667, 0);


-- StarterGui.main.top.btools.LocalScript
G2L["7"] = Instance.new("LocalScript", G2L["6"]);



-- StarterGui.main.top.top
G2L["8"] = Instance.new("TextLabel", G2L["2"]);
G2L["8"]["TextSize"] = 45;
G2L["8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8"]["BackgroundTransparency"] = 1;
G2L["8"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8"]["Text"] = [[Harked V2]];
G2L["8"]["Name"] = [[top]];
G2L["8"]["Position"] = UDim2.new(0.15464, 0, -0.33333, 0);


-- StarterGui.main.top.naked
G2L["9"] = Instance.new("TextButton", G2L["2"]);
G2L["9"]["BorderSizePixel"] = 0;
G2L["9"]["TextSize"] = 23;
G2L["9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["9"]["BackgroundTransparency"] = 0.5;
G2L["9"]["Size"] = UDim2.new(0, 134, 0, 40);
G2L["9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9"]["Text"] = [[Naked]];
G2L["9"]["Name"] = [[naked]];
G2L["9"]["Position"] = UDim2.new(0.02062, 0, 3.56217, 0);


-- StarterGui.main.top.naked.LocalScript
G2L["a"] = Instance.new("LocalScript", G2L["9"]);



-- StarterGui.main.top.credits
G2L["b"] = Instance.new("TextLabel", G2L["2"]);
G2L["b"]["TextWrapped"] = true;
G2L["b"]["TextSize"] = 17;
G2L["b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b"]["BackgroundTransparency"] = 1;
G2L["b"]["Size"] = UDim2.new(0, 291, 0, 23);
G2L["b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b"]["Text"] = [[Commands/Scripts by Dong , UI by Unverified]];
G2L["b"]["Name"] = [[credits]];
G2L["b"]["Position"] = UDim2.new(0, 0, 1, 0);


-- StarterGui.main.top.hatless
G2L["c"] = Instance.new("TextButton", G2L["2"]);
G2L["c"]["BorderSizePixel"] = 0;
G2L["c"]["TextSize"] = 23;
G2L["c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["c"]["BackgroundTransparency"] = 0.5;
G2L["c"]["Size"] = UDim2.new(0, 134, 0, 40);
G2L["c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c"]["Text"] = [[Hatless]];
G2L["c"]["Name"] = [[hatless]];
G2L["c"]["Position"] = UDim2.new(0.02062, 0, 5.39551, 0);


-- StarterGui.main.top.hatless.LocalScript
G2L["d"] = Instance.new("LocalScript", G2L["c"]);



-- StarterGui.main.top.sink
G2L["e"] = Instance.new("TextButton", G2L["2"]);
G2L["e"]["BorderSizePixel"] = 0;
G2L["e"]["TextSize"] = 23;
G2L["e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["e"]["BackgroundTransparency"] = 0.5;
G2L["e"]["Size"] = UDim2.new(0, 131, 0, 40);
G2L["e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e"]["Text"] = [[Freeze]];
G2L["e"]["Name"] = [[sink]];
G2L["e"]["Position"] = UDim2.new(0.52577, 0, 5.39551, 0);


-- StarterGui.main.top.sink.LocalScript
G2L["f"] = Instance.new("LocalScript", G2L["e"]);



-- StarterGui.main.top.nuke
G2L["10"] = Instance.new("TextButton", G2L["2"]);
G2L["10"]["BorderSizePixel"] = 0;
G2L["10"]["TextSize"] = 23;
G2L["10"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["10"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["10"]["BackgroundTransparency"] = 0.5;
G2L["10"]["Size"] = UDim2.new(0, 131, 0, 40);
G2L["10"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["10"]["Text"] = [[Nuke]];
G2L["10"]["Name"] = [[nuke]];
G2L["10"]["Position"] = UDim2.new(0.52577, 0, 7.19551, 0);


-- StarterGui.main.top.nuke.LocalScript
G2L["11"] = Instance.new("LocalScript", G2L["10"]);



-- StarterGui.main.top.kick
G2L["12"] = Instance.new("TextButton", G2L["2"]);
G2L["12"]["BorderSizePixel"] = 0;
G2L["12"]["TextSize"] = 23;
G2L["12"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["12"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["12"]["BackgroundTransparency"] = 0.5;
G2L["12"]["Size"] = UDim2.new(0, 134, 0, 40);
G2L["12"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12"]["Text"] = [[Kick]];
G2L["12"]["Name"] = [[kick]];
G2L["12"]["Position"] = UDim2.new(0.02062, 0, 7.19551, 0);


-- StarterGui.main.top.kick.LocalScript
G2L["13"] = Instance.new("LocalScript", G2L["12"]);



-- StarterGui.main.top.target
G2L["14"] = Instance.new("TextBox", G2L["2"]);
G2L["14"]["Name"] = [[target]];
G2L["14"]["BorderSizePixel"] = 0;
G2L["14"]["TextSize"] = 23;
G2L["14"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["14"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["14"]["ClearTextOnFocus"] = false;
G2L["14"]["Size"] = UDim2.new(0, 278, 0, 33);
G2L["14"]["Position"] = UDim2.new(0.02062, 0, 8.86667, 0);
G2L["14"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14"]["Text"] = [[]];
G2L["14"]["BackgroundTransparency"] = 0.4;


-- StarterGui.main.top.nolimbs
G2L["15"] = Instance.new("TextButton", G2L["2"]);
G2L["15"]["BorderSizePixel"] = 0;
G2L["15"]["TextSize"] = 23;
G2L["15"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15"]["BackgroundColor3"] = Color3.fromRGB(173, 173, 173);
G2L["15"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Light, Enum.FontStyle.Normal);
G2L["15"]["BackgroundTransparency"] = 0.5;
G2L["15"]["Size"] = UDim2.new(0, 131, 0, 40);
G2L["15"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15"]["Text"] = [[NoLimbs]];
G2L["15"]["Name"] = [[nolimbs]];
G2L["15"]["Position"] = UDim2.new(0.52577, 0, 3.56217, 0);


-- StarterGui.main.top.nolimbs.LocalScript
G2L["16"] = Instance.new("LocalScript", G2L["15"]);



-- StarterGui.main.top.RemoteEvent
G2L["17"] = Instance.new("RemoteEvent", G2L["2"]);



-- StarterGui.main.top.Script
G2L["18"] = Instance.new("Script", G2L["2"]);



-- StarterGui.main.top.Script.Building Tools
G2L["19"] = Instance.new("Tool", G2L["18"]);
G2L["19"]["Grip"] = CFrame.new(Vector3.new(0, 0, 0.4), Vector3.new(0, 0, -1));
G2L["19"]["WorldPivot"] = CFrame.new(Vector3.new(-6.13871, 0.40001, -11.43525), Vector3.new(0, 0, -1));
G2L["19"]["Enabled"] = false;
G2L["19"]["ToolTip"] = [[Building Tools by F3X]];
G2L["19"]["Name"] = [[Building Tools]];


-- StarterGui.main.top.Script.Building Tools.Handle
G2L["1a"] = Instance.new("Part", G2L["19"]);
G2L["1a"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["1a"]["TopSurface"] = Enum.SurfaceType.Smooth;
G2L["1a"]["CFrame"] = CFrame.new(Vector3.new(-6.13871, 0.40001, -11.43525), Vector3.new(0, 0, -1));
G2L["1a"]["Locked"] = true;
G2L["1a"]["Material"] = Enum.Material.SmoothPlastic;
G2L["1a"]["Size"] = Vector3.new(0.8, 0.8, 0.8);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1a"]["Color"] = Color3.fromRGB(18, 18, 18);
G2L["1a"]["Name"] = [[Handle]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["1b"] = Instance.new("Decal", G2L["1a"]);
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1b"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["1c"] = Instance.new("Decal", G2L["1a"]);
G2L["1c"]["Face"] = Enum.NormalId.Back;
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1c"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["1d"] = Instance.new("Decal", G2L["1a"]);
G2L["1d"]["Face"] = Enum.NormalId.Left;
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1d"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["1e"] = Instance.new("Decal", G2L["1a"]);
G2L["1e"]["Face"] = Enum.NormalId.Right;
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1e"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["1f"] = Instance.new("Decal", G2L["1a"]);
G2L["1f"]["Face"] = Enum.NormalId.Top;
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1f"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Handle.Decal
G2L["20"] = Instance.new("Decal", G2L["1a"]);
G2L["20"]["Face"] = Enum.NormalId.Bottom;
-- [ERROR] cannot convert TextureContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["20"]["Texture"] = [[http://www.roblox.com/asset/?id=129748355]];


-- StarterGui.main.top.Script.Building Tools.Version
G2L["21"] = Instance.new("StringValue", G2L["19"]);
G2L["21"]["Name"] = [[Version]];
G2L["21"]["Value"] = [[2.2.2]];


-- StarterGui.main.top.Script.Building Tools.SupportLibrary
G2L["22"] = Instance.new("ModuleScript", G2L["19"]);
G2L["22"]["Name"] = [[SupportLibrary]];


-- StarterGui.main.top.Script.Building Tools.SecurityModule
G2L["23"] = Instance.new("ModuleScript", G2L["19"]);
G2L["23"]["Name"] = [[SecurityModule]];


-- StarterGui.main.top.Script.Building Tools.Region by AxisAngle
G2L["24"] = Instance.new("ModuleScript", G2L["19"]);
G2L["24"]["Name"] = [[Region by AxisAngle]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager
G2L["25"] = Instance.new("LocalScript", G2L["19"]);
G2L["25"]["Name"] = [[LibraryManager]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/SupportLibrary@1.0.0
G2L["26"] = Instance.new("ModuleScript", G2L["25"]);
G2L["26"]["Name"] = [[F3X/SupportLibrary@1.0.0]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/SupportLibrary@1.0.0.Metadata
G2L["27"] = Instance.new("ModuleScript", G2L["26"]);
G2L["27"]["Name"] = [[Metadata]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Cheer@0.0.1
G2L["28"] = Instance.new("ModuleScript", G2L["25"]);
G2L["28"]["Name"] = [[F3X/Cheer@0.0.1]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Cheer@0.0.1.SupportLibrary
G2L["29"] = Instance.new("ModuleScript", G2L["28"]);
G2L["29"]["Name"] = [[SupportLibrary]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Cheer@0.0.1.Metadata
G2L["2a"] = Instance.new("ModuleScript", G2L["28"]);
G2L["2a"]["Name"] = [[Metadata]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Try@1.0.0
G2L["2b"] = Instance.new("ModuleScript", G2L["25"]);
G2L["2b"]["Name"] = [[F3X/Try@1.0.0]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Try@1.0.0.SupportLibrary
G2L["2c"] = Instance.new("ModuleScript", G2L["2b"]);
G2L["2c"]["Name"] = [[SupportLibrary]];


-- StarterGui.main.top.Script.Building Tools.LibraryManager.F3X/Try@1.0.0.Metadata
G2L["2d"] = Instance.new("ModuleScript", G2L["2b"]);
G2L["2d"]["Name"] = [[Metadata]];


-- StarterGui.main.top.Script.Building Tools.SerializationModule
G2L["2e"] = Instance.new("ModuleScript", G2L["19"]);
G2L["2e"]["Name"] = [[SerializationModule]];


-- StarterGui.main.top.Script.Building Tools.SyncAPI
G2L["2f"] = Instance.new("BindableFunction", G2L["19"]);
G2L["2f"]["Name"] = [[SyncAPI]];


-- StarterGui.main.top.Script.Building Tools.SyncAPI.SyncModule
G2L["30"] = Instance.new("ModuleScript", G2L["2f"]);
G2L["30"]["Name"] = [[SyncModule]];


-- StarterGui.main.top.Script.Building Tools.SyncAPI.LocalSyncEndpointScript
G2L["31"] = Instance.new("LocalScript", G2L["2f"]);
G2L["31"]["Name"] = [[LocalSyncEndpointScript]];


-- StarterGui.main.top.Script.Building Tools.SyncAPI.ServerEndpoint
G2L["32"] = Instance.new("RemoteFunction", G2L["2f"]);
G2L["32"]["Name"] = [[ServerEndpoint]];


-- StarterGui.main.top.Script.Building Tools.SyncAPI.ServerEndpoint.ServerEndpointScript
G2L["33"] = Instance.new("Script", G2L["32"]);
G2L["33"]["Name"] = [[ServerEndpointScript]];


-- StarterGui.main.top.Script.Building Tools.Loaded
G2L["34"] = Instance.new("BoolValue", G2L["19"]);
G2L["34"]["Name"] = [[Loaded]];


-- StarterGui.main.top.Script.Building Tools.Loaded.ComponentCount
G2L["35"] = Instance.new("IntValue", G2L["34"]);
G2L["35"]["Name"] = [[ComponentCount]];


-- StarterGui.main.top.Script.Building Tools.Loaded.ComponentCount.ComponentCounter
G2L["36"] = Instance.new("Script", G2L["35"]);
G2L["36"]["Name"] = [[ComponentCounter]];


-- StarterGui.main.top.Script.Building Tools.Loaded.LoadDetector
G2L["37"] = Instance.new("LocalScript", G2L["34"]);
G2L["37"]["Name"] = [[LoadDetector]];


-- StarterGui.main.top.Script.Building Tools.Assets
G2L["38"] = Instance.new("ModuleScript", G2L["19"]);
G2L["38"]["Name"] = [[Assets]];


-- StarterGui.main.top.Script.Building Tools.Core
G2L["39"] = Instance.new("ModuleScript", G2L["19"]);
G2L["39"]["Name"] = [[Core]];


-- StarterGui.main.top.Script.Building Tools.Building Tools by F3X
G2L["3a"] = Instance.new("LocalScript", G2L["19"]);
G2L["3a"]["Name"] = [[Building Tools by F3X]];


-- StarterGui.main.top.Script.Building Tools.Tools
G2L["3b"] = Instance.new("Folder", G2L["19"]);
G2L["3b"]["Name"] = [[Tools]];


-- StarterGui.main.top.Script.Building Tools.Tools.MoveTool
G2L["3c"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["3c"]["Name"] = [[MoveTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.ResizeTool
G2L["3d"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["3d"]["Name"] = [[ResizeTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.RotateTool
G2L["3e"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["3e"]["Name"] = [[RotateTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.PaintTool
G2L["3f"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["3f"]["Name"] = [[PaintTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.MaterialTool
G2L["40"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["40"]["Name"] = [[MaterialTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.SurfaceTool
G2L["41"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["41"]["Name"] = [[SurfaceTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.AnchorTool
G2L["42"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["42"]["Name"] = [[AnchorTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.WeldTool
G2L["43"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["43"]["Name"] = [[WeldTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.TextureTool
G2L["44"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["44"]["Name"] = [[TextureTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.MeshTool
G2L["45"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["45"]["Name"] = [[MeshTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.NewPartTool
G2L["46"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["46"]["Name"] = [[NewPartTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.CollisionTool
G2L["47"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["47"]["Name"] = [[CollisionTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.LightingTool
G2L["48"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["48"]["Name"] = [[LightingTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.DecorateTool
G2L["49"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["49"]["Name"] = [[DecorateTool]];


-- StarterGui.main.top.Script.Building Tools.Tools.CoreToolLoader
G2L["4a"] = Instance.new("ModuleScript", G2L["3b"]);
G2L["4a"]["Name"] = [[CoreToolLoader]];


-- StarterGui.main.top.Script.Building Tools.HistoryModule
G2L["4b"] = Instance.new("ModuleScript", G2L["19"]);
G2L["4b"]["Name"] = [[HistoryModule]];


-- StarterGui.main.top.Script.Building Tools.SelectionModule
G2L["4c"] = Instance.new("ModuleScript", G2L["19"]);
G2L["4c"]["Name"] = [[SelectionModule]];


-- StarterGui.main.top.Script.Building Tools.SnappingModule
G2L["4d"] = Instance.new("ModuleScript", G2L["19"]);
G2L["4d"]["Name"] = [[SnappingModule]];


-- StarterGui.main.top.Script.Building Tools.FilterMode
G2L["4e"] = Instance.new("BoolValue", G2L["19"]);
G2L["4e"]["Name"] = [[FilterMode]];


-- StarterGui.main.top.Script.Building Tools.FilterMode.FilterModeEnabler
G2L["4f"] = Instance.new("Script", G2L["4e"]);
G2L["4f"]["Name"] = [[FilterModeEnabler]];


-- StarterGui.main.top.Script.Building Tools.BoundingBoxModule
G2L["50"] = Instance.new("ModuleScript", G2L["19"]);
G2L["50"]["Name"] = [[BoundingBoxModule]];


-- StarterGui.main.top.Script.Building Tools.TargetingModule
G2L["51"] = Instance.new("ModuleScript", G2L["19"]);
G2L["51"]["Name"] = [[TargetingModule]];


-- StarterGui.main.top.Script.Building Tools.Interfaces
G2L["52"] = Instance.new("Folder", G2L["19"]);
G2L["52"]["Name"] = [[Interfaces]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog
G2L["53"] = Instance.new("Frame", G2L["52"]);
G2L["53"]["Active"] = true;
G2L["53"]["BorderSizePixel"] = 0;
G2L["53"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["53"]["Size"] = UDim2.new(0, 200, 0, 110);
G2L["53"]["Position"] = UDim2.new(0.5, -100, 0.5, -55);
G2L["53"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["53"]["Name"] = [[ExportDialog]];
G2L["53"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info
G2L["54"] = Instance.new("Frame", G2L["53"]);
G2L["54"]["Visible"] = false;
G2L["54"]["BorderSizePixel"] = 0;
G2L["54"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["54"]["ClipsDescendants"] = true;
G2L["54"]["Size"] = UDim2.new(1, 0, 0, 75);
G2L["54"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["54"]["Name"] = [[Info]];
G2L["54"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.CreationIDLabel
G2L["55"] = Instance.new("TextLabel", G2L["54"]);
G2L["55"]["TextStrokeTransparency"] = 0.75;
G2L["55"]["BorderSizePixel"] = 0;
G2L["55"]["TextSize"] = 18;
G2L["55"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["55"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["55"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["55"]["BackgroundTransparency"] = 1;
G2L["55"]["Size"] = UDim2.new(1, 0, 0, 40);
G2L["55"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["55"]["Text"] = [[Your creation's ID:]];
G2L["55"]["Name"] = [[CreationIDLabel]];
G2L["55"]["Position"] = UDim2.new(0, 0, 0, 5);


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.CreationID
G2L["56"] = Instance.new("TextLabel", G2L["54"]);
G2L["56"]["TextStrokeTransparency"] = 0;
G2L["56"]["BorderSizePixel"] = 0;
G2L["56"]["TextSize"] = 24;
G2L["56"]["TextStrokeColor3"] = Color3.fromRGB(255, 255, 255);
G2L["56"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["56"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["56"]["TextColor3"] = Color3.fromRGB(113, 113, 113);
G2L["56"]["BackgroundTransparency"] = 1;
G2L["56"]["Size"] = UDim2.new(1, 0, 0, 40);
G2L["56"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["56"]["Text"] = [[j5of0]];
G2L["56"]["Name"] = [[CreationID]];
G2L["56"]["Position"] = UDim2.new(0, 0, 0, 30);


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar
G2L["57"] = Instance.new("Frame", G2L["54"]);
G2L["57"]["BorderSizePixel"] = 0;
G2L["57"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["57"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["57"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["57"]["Name"] = [[ColorBar]];
G2L["57"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar.Yellow
G2L["58"] = Instance.new("Frame", G2L["57"]);
G2L["58"]["BorderSizePixel"] = 0;
G2L["58"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["58"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["58"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["58"]["Name"] = [[Yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar.Green
G2L["59"] = Instance.new("Frame", G2L["57"]);
G2L["59"]["BorderSizePixel"] = 0;
G2L["59"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["59"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["59"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["59"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["59"]["Name"] = [[Green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar.Blue
G2L["5a"] = Instance.new("Frame", G2L["57"]);
G2L["5a"]["BorderSizePixel"] = 0;
G2L["5a"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["5a"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["5a"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["5a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5a"]["Name"] = [[Blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar.Red
G2L["5b"] = Instance.new("Frame", G2L["57"]);
G2L["5b"]["BorderSizePixel"] = 0;
G2L["5b"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["5b"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["5b"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["5b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5b"]["Name"] = [[Red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Info.ColorBar.Purple
G2L["5c"] = Instance.new("Frame", G2L["57"]);
G2L["5c"]["BorderSizePixel"] = 0;
G2L["5c"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["5c"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["5c"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["5c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5c"]["Name"] = [[Purple]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip
G2L["5d"] = Instance.new("Frame", G2L["53"]);
G2L["5d"]["Visible"] = false;
G2L["5d"]["BorderSizePixel"] = 0;
G2L["5d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5d"]["Size"] = UDim2.new(1, 0, 0, 30);
G2L["5d"]["Position"] = UDim2.new(0, 0, 0, 75);
G2L["5d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5d"]["Name"] = [[Tip]];
G2L["5d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.Tip
G2L["5e"] = Instance.new("TextLabel", G2L["5d"]);
G2L["5e"]["TextWrapped"] = true;
G2L["5e"]["TextStrokeTransparency"] = 0.75;
G2L["5e"]["BorderSizePixel"] = 0;
G2L["5e"]["TextSize"] = 10;
G2L["5e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["5e"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["5e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["5e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5e"]["BackgroundTransparency"] = 1;
G2L["5e"]["Size"] = UDim2.new(1, 0, 0, 30);
G2L["5e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5e"]["Text"] = [[Use the ID above to import your creation using the plugin.]];
G2L["5e"]["Name"] = [[Tip]];
G2L["5e"]["Position"] = UDim2.new(0, 0, 0, 7);


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar
G2L["5f"] = Instance.new("Frame", G2L["5d"]);
G2L["5f"]["BorderSizePixel"] = 0;
G2L["5f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["5f"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["5f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["5f"]["Name"] = [[ColorBar]];
G2L["5f"]["Rotation"] = 180;
G2L["5f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar.Yellow
G2L["60"] = Instance.new("Frame", G2L["5f"]);
G2L["60"]["BorderSizePixel"] = 0;
G2L["60"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["60"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["60"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["60"]["Name"] = [[Yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar.Green
G2L["61"] = Instance.new("Frame", G2L["5f"]);
G2L["61"]["BorderSizePixel"] = 0;
G2L["61"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["61"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["61"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["61"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["61"]["Name"] = [[Green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar.Blue
G2L["62"] = Instance.new("Frame", G2L["5f"]);
G2L["62"]["BorderSizePixel"] = 0;
G2L["62"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["62"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["62"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["62"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["62"]["Name"] = [[Blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar.Red
G2L["63"] = Instance.new("Frame", G2L["5f"]);
G2L["63"]["BorderSizePixel"] = 0;
G2L["63"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["63"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["63"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["63"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["63"]["Name"] = [[Red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Tip.ColorBar.Purple
G2L["64"] = Instance.new("Frame", G2L["5f"]);
G2L["64"]["BorderSizePixel"] = 0;
G2L["64"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["64"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["64"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["64"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["64"]["Name"] = [[Purple]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Close
G2L["65"] = Instance.new("Frame", G2L["53"]);
G2L["65"]["Visible"] = false;
G2L["65"]["BorderSizePixel"] = 0;
G2L["65"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["65"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["65"]["Position"] = UDim2.new(0, 0, 1, 5);
G2L["65"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["65"]["Name"] = [[Close]];
G2L["65"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Close.Button
G2L["66"] = Instance.new("TextButton", G2L["65"]);
G2L["66"]["TextStrokeTransparency"] = 0.8;
G2L["66"]["BorderSizePixel"] = 0;
G2L["66"]["TextSize"] = 14;
G2L["66"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["66"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["66"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["66"]["BackgroundTransparency"] = 0.5;
G2L["66"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["66"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["66"]["Text"] = [[Got it]];
G2L["66"]["Name"] = [[Button]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Close.Shadow
G2L["67"] = Instance.new("Frame", G2L["65"]);
G2L["67"]["ZIndex"] = 2;
G2L["67"]["BorderSizePixel"] = 0;
G2L["67"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["67"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["67"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["67"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["67"]["Name"] = [[Shadow]];
G2L["67"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading
G2L["68"] = Instance.new("Frame", G2L["53"]);
G2L["68"]["BorderSizePixel"] = 0;
G2L["68"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["68"]["ClipsDescendants"] = true;
G2L["68"]["Size"] = UDim2.new(1, 0, 0, 80);
G2L["68"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["68"]["Name"] = [[Loading]];
G2L["68"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar
G2L["69"] = Instance.new("Frame", G2L["68"]);
G2L["69"]["BorderSizePixel"] = 0;
G2L["69"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["69"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["69"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["69"]["Name"] = [[ColorBar]];
G2L["69"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar.Yellow
G2L["6a"] = Instance.new("Frame", G2L["69"]);
G2L["6a"]["BorderSizePixel"] = 0;
G2L["6a"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["6a"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["6a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6a"]["Name"] = [[Yellow]];
G2L["6a"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar.Green
G2L["6b"] = Instance.new("Frame", G2L["69"]);
G2L["6b"]["BorderSizePixel"] = 0;
G2L["6b"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["6b"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["6b"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["6b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6b"]["Name"] = [[Green]];
G2L["6b"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar.Blue
G2L["6c"] = Instance.new("Frame", G2L["69"]);
G2L["6c"]["BorderSizePixel"] = 0;
G2L["6c"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["6c"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["6c"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["6c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6c"]["Name"] = [[Blue]];
G2L["6c"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar.Red
G2L["6d"] = Instance.new("Frame", G2L["69"]);
G2L["6d"]["BorderSizePixel"] = 0;
G2L["6d"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["6d"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["6d"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["6d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6d"]["Name"] = [[Red]];
G2L["6d"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.ColorBar.Purple
G2L["6e"] = Instance.new("Frame", G2L["69"]);
G2L["6e"]["BorderSizePixel"] = 0;
G2L["6e"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["6e"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["6e"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["6e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6e"]["Name"] = [[Purple]];
G2L["6e"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.TextLabel
G2L["6f"] = Instance.new("TextLabel", G2L["68"]);
G2L["6f"]["TextWrapped"] = true;
G2L["6f"]["TextStrokeTransparency"] = 0.8;
G2L["6f"]["BorderSizePixel"] = 0;
G2L["6f"]["TextSize"] = 18;
G2L["6f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["6f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6f"]["BackgroundTransparency"] = 1;
G2L["6f"]["Size"] = UDim2.new(1, 0, 0, 50);
G2L["6f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["6f"]["Text"] = [[Uploading your creation...]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar
G2L["70"] = Instance.new("Frame", G2L["68"]);
G2L["70"]["BorderSizePixel"] = 0;
G2L["70"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["70"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["70"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["70"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["70"]["Name"] = [[BottomColorBar]];
G2L["70"]["Rotation"] = 180;
G2L["70"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar.Yellow
G2L["71"] = Instance.new("Frame", G2L["70"]);
G2L["71"]["BorderSizePixel"] = 0;
G2L["71"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["71"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["71"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["71"]["Name"] = [[Yellow]];
G2L["71"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar.Green
G2L["72"] = Instance.new("Frame", G2L["70"]);
G2L["72"]["BorderSizePixel"] = 0;
G2L["72"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["72"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["72"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["72"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["72"]["Name"] = [[Green]];
G2L["72"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar.Blue
G2L["73"] = Instance.new("Frame", G2L["70"]);
G2L["73"]["BorderSizePixel"] = 0;
G2L["73"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["73"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["73"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["73"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["73"]["Name"] = [[Blue]];
G2L["73"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar.Red
G2L["74"] = Instance.new("Frame", G2L["70"]);
G2L["74"]["BorderSizePixel"] = 0;
G2L["74"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["74"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["74"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["74"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["74"]["Name"] = [[Red]];
G2L["74"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.BottomColorBar.Purple
G2L["75"] = Instance.new("Frame", G2L["70"]);
G2L["75"]["BorderSizePixel"] = 0;
G2L["75"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["75"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["75"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["75"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["75"]["Name"] = [[Purple]];
G2L["75"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.CloseButton
G2L["76"] = Instance.new("TextButton", G2L["68"]);
G2L["76"]["TextStrokeTransparency"] = 0.85;
G2L["76"]["BorderSizePixel"] = 0;
G2L["76"]["TextSize"] = 14;
G2L["76"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["76"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["76"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["76"]["BackgroundTransparency"] = 0.5;
G2L["76"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["76"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["76"]["Text"] = [[Close]];
G2L["76"]["Name"] = [[CloseButton]];
G2L["76"]["Position"] = UDim2.new(0, 0, 1, -30);


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.Loading.CloseButton.Shadow
G2L["77"] = Instance.new("Frame", G2L["76"]);
G2L["77"]["BorderSizePixel"] = 0;
G2L["77"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["77"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["77"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["77"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["77"]["Name"] = [[Shadow]];
G2L["77"]["BackgroundTransparency"] = 0.7;


-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.[Component]
G2L["78"] = Instance.new("LocalScript", G2L["53"]);
G2L["78"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI
G2L["79"] = Instance.new("Frame", G2L["52"]);
G2L["79"]["Active"] = true;
G2L["79"]["BorderSizePixel"] = 0;
G2L["79"]["Size"] = UDim2.new(0, 245, 0, 90);
G2L["79"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["79"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["79"]["Name"] = [[BTAnchorToolGUI]];
G2L["79"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Title
G2L["7a"] = Instance.new("Frame", G2L["79"]);
G2L["7a"]["BorderSizePixel"] = 0;
G2L["7a"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["7a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7a"]["Name"] = [[Title]];
G2L["7a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Title.ColorBar
G2L["7b"] = Instance.new("Frame", G2L["7a"]);
G2L["7b"]["BorderSizePixel"] = 0;
G2L["7b"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["7b"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["7b"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["7b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7b"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Title.Label
G2L["7c"] = Instance.new("TextLabel", G2L["7a"]);
G2L["7c"]["TextWrapped"] = true;
G2L["7c"]["TextStrokeTransparency"] = 0;
G2L["7c"]["BorderSizePixel"] = 0;
G2L["7c"]["TextSize"] = 10;
G2L["7c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["7c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["7c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7c"]["BackgroundTransparency"] = 1;
G2L["7c"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["7c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7c"]["Text"] = [[ANCHOR TOOL]];
G2L["7c"]["Name"] = [[Label]];
G2L["7c"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Title.F3XSignature
G2L["7d"] = Instance.new("TextLabel", G2L["7a"]);
G2L["7d"]["TextWrapped"] = true;
G2L["7d"]["TextStrokeTransparency"] = 0.9;
G2L["7d"]["BorderSizePixel"] = 0;
G2L["7d"]["TextSize"] = 14;
G2L["7d"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["7d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["7d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7d"]["BackgroundTransparency"] = 1;
G2L["7d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["7d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7d"]["Text"] = [[F3X]];
G2L["7d"]["Name"] = [[F3XSignature]];
G2L["7d"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status
G2L["7e"] = Instance.new("Frame", G2L["79"]);
G2L["7e"]["BorderSizePixel"] = 0;
G2L["7e"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["7e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7e"]["Name"] = [[Status]];
G2L["7e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Label
G2L["7f"] = Instance.new("TextLabel", G2L["7e"]);
G2L["7f"]["TextWrapped"] = true;
G2L["7f"]["TextStrokeTransparency"] = 0;
G2L["7f"]["BorderSizePixel"] = 0;
G2L["7f"]["TextSize"] = 10;
G2L["7f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["7f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["7f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7f"]["BackgroundTransparency"] = 1;
G2L["7f"]["Size"] = UDim2.new(0, 40, 0, 25);
G2L["7f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["7f"]["Text"] = [[Status]];
G2L["7f"]["Name"] = [[Label]];
G2L["7f"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Anchored
G2L["80"] = Instance.new("Frame", G2L["7e"]);
G2L["80"]["BorderSizePixel"] = 0;
G2L["80"]["Size"] = UDim2.new(0, 90, 0, 25);
G2L["80"]["Position"] = UDim2.new(0, 55, 0, 0);
G2L["80"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["80"]["Name"] = [[Anchored]];
G2L["80"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Anchored.SelectedIndicator
G2L["81"] = Instance.new("Frame", G2L["80"]);
G2L["81"]["BorderSizePixel"] = 0;
G2L["81"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["81"]["Size"] = UDim2.new(1, -9, 0, 2);
G2L["81"]["Position"] = UDim2.new(0, 9, 0, -2);
G2L["81"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["81"]["Name"] = [[SelectedIndicator]];
G2L["81"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Anchored.Button
G2L["82"] = Instance.new("TextButton", G2L["80"]);
G2L["82"]["BorderSizePixel"] = 0;
G2L["82"]["TextTransparency"] = 1;
G2L["82"]["ZIndex"] = 2;
G2L["82"]["BackgroundTransparency"] = 1;
G2L["82"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["82"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["82"]["Text"] = [[]];
G2L["82"]["Name"] = [[Button]];
G2L["82"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Anchored.Background
G2L["83"] = Instance.new("ImageLabel", G2L["80"]);
G2L["83"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["83"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["83"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["83"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["83"]["BackgroundTransparency"] = 1;
G2L["83"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Anchored.Label
G2L["84"] = Instance.new("TextLabel", G2L["80"]);
G2L["84"]["BorderSizePixel"] = 0;
G2L["84"]["TextSize"] = 10;
G2L["84"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["84"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["84"]["BackgroundTransparency"] = 1;
G2L["84"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["84"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["84"]["Text"] = [[ANCHORED]];
G2L["84"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Unanchored
G2L["85"] = Instance.new("Frame", G2L["7e"]);
G2L["85"]["BorderSizePixel"] = 0;
G2L["85"]["Size"] = UDim2.new(0, 90, 0, 25);
G2L["85"]["Position"] = UDim2.new(0, 140, 0, 0);
G2L["85"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["85"]["Name"] = [[Unanchored]];
G2L["85"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Unanchored.SelectedIndicator
G2L["86"] = Instance.new("Frame", G2L["85"]);
G2L["86"]["BorderSizePixel"] = 0;
G2L["86"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["86"]["Size"] = UDim2.new(1, -9, 0, 2);
G2L["86"]["Position"] = UDim2.new(0, 9, 0, -2);
G2L["86"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["86"]["Name"] = [[SelectedIndicator]];
G2L["86"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Unanchored.Button
G2L["87"] = Instance.new("TextButton", G2L["85"]);
G2L["87"]["BorderSizePixel"] = 0;
G2L["87"]["TextTransparency"] = 1;
G2L["87"]["ZIndex"] = 2;
G2L["87"]["BackgroundTransparency"] = 1;
G2L["87"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["87"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["87"]["Text"] = [[]];
G2L["87"]["Name"] = [[Button]];
G2L["87"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Unanchored.Background
G2L["88"] = Instance.new("ImageLabel", G2L["85"]);
G2L["88"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["88"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["88"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["88"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["88"]["BackgroundTransparency"] = 1;
G2L["88"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Status.Unanchored.Label
G2L["89"] = Instance.new("TextLabel", G2L["85"]);
G2L["89"]["BorderSizePixel"] = 0;
G2L["89"]["TextSize"] = 10;
G2L["89"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["89"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["89"]["BackgroundTransparency"] = 1;
G2L["89"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["89"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["89"]["Text"] = [[UNANCHORED]];
G2L["89"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Tip
G2L["8a"] = Instance.new("Frame", G2L["79"]);
G2L["8a"]["BorderSizePixel"] = 0;
G2L["8a"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["8a"]["Position"] = UDim2.new(0, 5, 0, 70);
G2L["8a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8a"]["Name"] = [[Tip]];
G2L["8a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Tip.ColorBar
G2L["8b"] = Instance.new("Frame", G2L["8a"]);
G2L["8b"]["BorderSizePixel"] = 0;
G2L["8b"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["8b"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["8b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8b"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTAnchorToolGUI.Tip.Text
G2L["8c"] = Instance.new("TextLabel", G2L["8a"]);
G2L["8c"]["TextWrapped"] = true;
G2L["8c"]["TextStrokeTransparency"] = 0.5;
G2L["8c"]["BorderSizePixel"] = 0;
G2L["8c"]["TextSize"] = 10;
G2L["8c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["8c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8c"]["BackgroundTransparency"] = 1;
G2L["8c"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["8c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8c"]["Text"] = [[TIP: Press Enter to quickly toggle the anchor.]];
G2L["8c"]["Name"] = [[Text]];
G2L["8c"]["Position"] = UDim2.new(0, 0, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI
G2L["8d"] = Instance.new("Frame", G2L["52"]);
G2L["8d"]["Active"] = true;
G2L["8d"]["BorderSizePixel"] = 0;
G2L["8d"]["Size"] = UDim2.new(0, 200, 0, 90);
G2L["8d"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["8d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8d"]["Name"] = [[BTCollisionToolGUI]];
G2L["8d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Title
G2L["8e"] = Instance.new("Frame", G2L["8d"]);
G2L["8e"]["BorderSizePixel"] = 0;
G2L["8e"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["8e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8e"]["Name"] = [[Title]];
G2L["8e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Title.ColorBar
G2L["8f"] = Instance.new("Frame", G2L["8e"]);
G2L["8f"]["BorderSizePixel"] = 0;
G2L["8f"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["8f"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["8f"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["8f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["8f"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Title.Label
G2L["90"] = Instance.new("TextLabel", G2L["8e"]);
G2L["90"]["TextWrapped"] = true;
G2L["90"]["TextStrokeTransparency"] = 0;
G2L["90"]["BorderSizePixel"] = 0;
G2L["90"]["TextSize"] = 10;
G2L["90"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["90"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["90"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["90"]["BackgroundTransparency"] = 1;
G2L["90"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["90"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["90"]["Text"] = [[COLLISION TOOL]];
G2L["90"]["Name"] = [[Label]];
G2L["90"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Title.F3XSignature
G2L["91"] = Instance.new("TextLabel", G2L["8e"]);
G2L["91"]["TextWrapped"] = true;
G2L["91"]["TextStrokeTransparency"] = 0.9;
G2L["91"]["BorderSizePixel"] = 0;
G2L["91"]["TextSize"] = 14;
G2L["91"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["91"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["91"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["91"]["BackgroundTransparency"] = 1;
G2L["91"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["91"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["91"]["Text"] = [[F3X]];
G2L["91"]["Name"] = [[F3XSignature]];
G2L["91"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status
G2L["92"] = Instance.new("Frame", G2L["8d"]);
G2L["92"]["BorderSizePixel"] = 0;
G2L["92"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["92"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["92"]["Name"] = [[Status]];
G2L["92"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Label
G2L["93"] = Instance.new("TextLabel", G2L["92"]);
G2L["93"]["TextWrapped"] = true;
G2L["93"]["TextStrokeTransparency"] = 0;
G2L["93"]["BorderSizePixel"] = 0;
G2L["93"]["TextSize"] = 10;
G2L["93"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["93"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["93"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["93"]["BackgroundTransparency"] = 1;
G2L["93"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["93"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["93"]["Text"] = [[Collision]];
G2L["93"]["Name"] = [[Label]];
G2L["93"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.On
G2L["94"] = Instance.new("Frame", G2L["92"]);
G2L["94"]["BorderSizePixel"] = 0;
G2L["94"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["94"]["Position"] = UDim2.new(0, 65, 0, 0);
G2L["94"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["94"]["Name"] = [[On]];
G2L["94"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.On.SelectedIndicator
G2L["95"] = Instance.new("Frame", G2L["94"]);
G2L["95"]["BorderSizePixel"] = 0;
G2L["95"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["95"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["95"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["95"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["95"]["Name"] = [[SelectedIndicator]];
G2L["95"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.On.Button
G2L["96"] = Instance.new("TextButton", G2L["94"]);
G2L["96"]["BorderSizePixel"] = 0;
G2L["96"]["TextTransparency"] = 1;
G2L["96"]["ZIndex"] = 2;
G2L["96"]["BackgroundTransparency"] = 1;
G2L["96"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["96"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["96"]["Text"] = [[]];
G2L["96"]["Name"] = [[Button]];
G2L["96"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.On.Background
G2L["97"] = Instance.new("ImageLabel", G2L["94"]);
G2L["97"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["97"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["97"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["97"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["97"]["BackgroundTransparency"] = 1;
G2L["97"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.On.Label
G2L["98"] = Instance.new("TextLabel", G2L["94"]);
G2L["98"]["BorderSizePixel"] = 0;
G2L["98"]["TextSize"] = 10;
G2L["98"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["98"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["98"]["BackgroundTransparency"] = 1;
G2L["98"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["98"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["98"]["Text"] = [[ON]];
G2L["98"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Off
G2L["99"] = Instance.new("Frame", G2L["92"]);
G2L["99"]["BorderSizePixel"] = 0;
G2L["99"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["99"]["Position"] = UDim2.new(0, 113, 0, 0);
G2L["99"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["99"]["Name"] = [[Off]];
G2L["99"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Off.SelectedIndicator
G2L["9a"] = Instance.new("Frame", G2L["99"]);
G2L["9a"]["BorderSizePixel"] = 0;
G2L["9a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9a"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["9a"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["9a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9a"]["Name"] = [[SelectedIndicator]];
G2L["9a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Off.Button
G2L["9b"] = Instance.new("TextButton", G2L["99"]);
G2L["9b"]["BorderSizePixel"] = 0;
G2L["9b"]["TextTransparency"] = 1;
G2L["9b"]["ZIndex"] = 2;
G2L["9b"]["BackgroundTransparency"] = 1;
G2L["9b"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["9b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9b"]["Text"] = [[]];
G2L["9b"]["Name"] = [[Button]];
G2L["9b"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Off.Background
G2L["9c"] = Instance.new("ImageLabel", G2L["99"]);
G2L["9c"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["9c"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["9c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["9c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9c"]["BackgroundTransparency"] = 1;
G2L["9c"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Status.Off.Label
G2L["9d"] = Instance.new("TextLabel", G2L["99"]);
G2L["9d"]["BorderSizePixel"] = 0;
G2L["9d"]["TextSize"] = 10;
G2L["9d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["9d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9d"]["BackgroundTransparency"] = 1;
G2L["9d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["9d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9d"]["Text"] = [[OFF]];
G2L["9d"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Tip
G2L["9e"] = Instance.new("Frame", G2L["8d"]);
G2L["9e"]["BorderSizePixel"] = 0;
G2L["9e"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["9e"]["Position"] = UDim2.new(0, 5, 0, 70);
G2L["9e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9e"]["Name"] = [[Tip]];
G2L["9e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Tip.ColorBar
G2L["9f"] = Instance.new("Frame", G2L["9e"]);
G2L["9f"]["BorderSizePixel"] = 0;
G2L["9f"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["9f"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["9f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["9f"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTCollisionToolGUI.Tip.Text
G2L["a0"] = Instance.new("TextLabel", G2L["9e"]);
G2L["a0"]["TextWrapped"] = true;
G2L["a0"]["TextStrokeTransparency"] = 0.5;
G2L["a0"]["BorderSizePixel"] = 0;
G2L["a0"]["TextSize"] = 10;
G2L["a0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["a0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a0"]["BackgroundTransparency"] = 1;
G2L["a0"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["a0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a0"]["Text"] = [[TIP: Press Enter to toggle collision.]];
G2L["a0"]["Name"] = [[Text]];
G2L["a0"]["Position"] = UDim2.new(0, 0, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI
G2L["a1"] = Instance.new("Frame", G2L["52"]);
G2L["a1"]["Active"] = true;
G2L["a1"]["BorderSizePixel"] = 0;
G2L["a1"]["Size"] = UDim2.new(0, 200, 0, 100);
G2L["a1"]["Position"] = UDim2.new(0, -210, 0, 0);
G2L["a1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a1"]["Name"] = [[BTGroupsGUI]];
G2L["a1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates
G2L["a2"] = Instance.new("Frame", G2L["a1"]);
G2L["a2"]["Visible"] = false;
G2L["a2"]["BorderSizePixel"] = 0;
G2L["a2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a2"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["a2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a2"]["Name"] = [[Templates]];
G2L["a2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton
G2L["a3"] = Instance.new("Frame", G2L["a2"]);
G2L["a3"]["BorderSizePixel"] = 0;
G2L["a3"]["BackgroundColor3"] = Color3.fromRGB(69, 69, 69);
G2L["a3"]["Size"] = UDim2.new(1, -5, 0, 25);
G2L["a3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a3"]["Name"] = [[GroupButton]];
G2L["a3"]["BackgroundTransparency"] = 0.65;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.EditButton
G2L["a4"] = Instance.new("ImageButton", G2L["a3"]);
G2L["a4"]["BorderSizePixel"] = 0;
G2L["a4"]["ImageTransparency"] = 0.25;
G2L["a4"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["a4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a4"]["Image"] = [[http://www.roblox.com/asset/?id=160400465]];
G2L["a4"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["a4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a4"]["Name"] = [[EditButton]];
G2L["a4"]["Position"] = UDim2.new(1, -50, 0, 5);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.EditButton.RightTooltip
G2L["a5"] = Instance.new("Frame", G2L["a4"]);
G2L["a5"]["Visible"] = false;
G2L["a5"]["ZIndex"] = 2;
G2L["a5"]["BorderSizePixel"] = 0;
G2L["a5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a5"]["Size"] = UDim2.new(0, 40, 0, 16);
G2L["a5"]["Position"] = UDim2.new(0, -50, 0, 0);
G2L["a5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a5"]["Name"] = [[RightTooltip]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.EditButton.RightTooltip.Tip
G2L["a6"] = Instance.new("Frame", G2L["a5"]);
G2L["a6"]["ZIndex"] = 2;
G2L["a6"]["BorderSizePixel"] = 0;
G2L["a6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a6"]["Size"] = UDim2.new(0, 12, 0, 12);
G2L["a6"]["Position"] = UDim2.new(1, -6, 0, 2);
G2L["a6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a6"]["Name"] = [[Tip]];
G2L["a6"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.EditButton.RightTooltip.Text
G2L["a7"] = Instance.new("TextLabel", G2L["a5"]);
G2L["a7"]["ZIndex"] = 3;
G2L["a7"]["BorderSizePixel"] = 0;
G2L["a7"]["TextSize"] = 10;
G2L["a7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["a7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a7"]["BackgroundTransparency"] = 1;
G2L["a7"]["Size"] = UDim2.new(1, 4, 1, 0);
G2L["a7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a7"]["Text"] = [[RENAME]];
G2L["a7"]["Name"] = [[Text]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.IgnoreButton
G2L["a8"] = Instance.new("ImageButton", G2L["a3"]);
G2L["a8"]["BorderSizePixel"] = 0;
G2L["a8"]["ImageTransparency"] = 0.25;
G2L["a8"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["a8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a8"]["Image"] = [[http://www.roblox.com/asset/?id=160408836]];
G2L["a8"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["a8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a8"]["Name"] = [[IgnoreButton]];
G2L["a8"]["Position"] = UDim2.new(1, -25, 0, 5);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.IgnoreButton.RightTooltip
G2L["a9"] = Instance.new("Frame", G2L["a8"]);
G2L["a9"]["Visible"] = false;
G2L["a9"]["ZIndex"] = 2;
G2L["a9"]["BorderSizePixel"] = 0;
G2L["a9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a9"]["Size"] = UDim2.new(0, 48, 0, 16);
G2L["a9"]["Position"] = UDim2.new(0, -58, 0, 0);
G2L["a9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["a9"]["Name"] = [[RightTooltip]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.IgnoreButton.RightTooltip.Tip
G2L["aa"] = Instance.new("Frame", G2L["a9"]);
G2L["aa"]["ZIndex"] = 2;
G2L["aa"]["BorderSizePixel"] = 0;
G2L["aa"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["aa"]["Size"] = UDim2.new(0, 12, 0, 12);
G2L["aa"]["Position"] = UDim2.new(1, -6, 0, 2);
G2L["aa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["aa"]["Name"] = [[Tip]];
G2L["aa"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.IgnoreButton.RightTooltip.Text
G2L["ab"] = Instance.new("TextLabel", G2L["a9"]);
G2L["ab"]["ZIndex"] = 3;
G2L["ab"]["BorderSizePixel"] = 0;
G2L["ab"]["TextSize"] = 10;
G2L["ab"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ab"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["ab"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ab"]["BackgroundTransparency"] = 1;
G2L["ab"]["Size"] = UDim2.new(1, 4, 1, 0);
G2L["ab"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ab"]["Text"] = [[UNIGNORE]];
G2L["ab"]["Name"] = [[Text]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.UpdateButton
G2L["ac"] = Instance.new("ImageButton", G2L["a3"]);
G2L["ac"]["BorderSizePixel"] = 0;
G2L["ac"]["ImageTransparency"] = 0.25;
G2L["ac"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["ac"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ac"]["Image"] = [[http://www.roblox.com/asset/?id=160402908]];
G2L["ac"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["ac"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ac"]["Name"] = [[UpdateButton]];
G2L["ac"]["Position"] = UDim2.new(0, 12, 0, 5);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.UpdateButton.LeftTooltip
G2L["ad"] = Instance.new("Frame", G2L["ac"]);
G2L["ad"]["Visible"] = false;
G2L["ad"]["ZIndex"] = 3;
G2L["ad"]["BorderSizePixel"] = 0;
G2L["ad"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ad"]["Size"] = UDim2.new(0, 38, 0, 16);
G2L["ad"]["Position"] = UDim2.new(1, 12, 0, 0);
G2L["ad"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ad"]["Name"] = [[LeftTooltip]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.UpdateButton.LeftTooltip.Tip
G2L["ae"] = Instance.new("Frame", G2L["ad"]);
G2L["ae"]["ZIndex"] = 3;
G2L["ae"]["BorderSizePixel"] = 0;
G2L["ae"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ae"]["Size"] = UDim2.new(0, 12, 0, 12);
G2L["ae"]["Position"] = UDim2.new(0, -6, 0, 2);
G2L["ae"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ae"]["Name"] = [[Tip]];
G2L["ae"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.UpdateButton.LeftTooltip.Text
G2L["af"] = Instance.new("TextLabel", G2L["ad"]);
G2L["af"]["ZIndex"] = 3;
G2L["af"]["BorderSizePixel"] = 0;
G2L["af"]["TextSize"] = 10;
G2L["af"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["af"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["af"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["af"]["BackgroundTransparency"] = 1;
G2L["af"]["Size"] = UDim2.new(1, 4, 1, 0);
G2L["af"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["af"]["Text"] = [[UPDATE]];
G2L["af"]["Name"] = [[Text]];
G2L["af"]["Position"] = UDim2.new(0, -4, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupNameArea
G2L["b0"] = Instance.new("Frame", G2L["a3"]);
G2L["b0"]["BorderSizePixel"] = 0;
G2L["b0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b0"]["Size"] = UDim2.new(0, 90, 0, 25);
G2L["b0"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["b0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b0"]["Name"] = [[GroupNameArea]];
G2L["b0"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupNameArea.LeftTooltip
G2L["b1"] = Instance.new("Frame", G2L["b0"]);
G2L["b1"]["Visible"] = false;
G2L["b1"]["ZIndex"] = 2;
G2L["b1"]["BorderSizePixel"] = 0;
G2L["b1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b1"]["Size"] = UDim2.new(0, 38, 0, 16);
G2L["b1"]["Position"] = UDim2.new(1, 12, 0, 5);
G2L["b1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b1"]["Name"] = [[LeftTooltip]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupNameArea.LeftTooltip.Tip
G2L["b2"] = Instance.new("Frame", G2L["b1"]);
G2L["b2"]["ZIndex"] = 2;
G2L["b2"]["BorderSizePixel"] = 0;
G2L["b2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b2"]["Size"] = UDim2.new(0, 12, 0, 12);
G2L["b2"]["Position"] = UDim2.new(0, -6, 0, 2);
G2L["b2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b2"]["Name"] = [[Tip]];
G2L["b2"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupNameArea.LeftTooltip.Text
G2L["b3"] = Instance.new("TextLabel", G2L["b1"]);
G2L["b3"]["ZIndex"] = 3;
G2L["b3"]["BorderSizePixel"] = 0;
G2L["b3"]["TextSize"] = 10;
G2L["b3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b3"]["BackgroundTransparency"] = 1;
G2L["b3"]["Size"] = UDim2.new(1, 4, 1, 0);
G2L["b3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b3"]["Text"] = [[SELECT]];
G2L["b3"]["Name"] = [[Text]];
G2L["b3"]["Position"] = UDim2.new(0, -4, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupName
G2L["b4"] = Instance.new("TextButton", G2L["a3"]);
G2L["b4"]["TextStrokeTransparency"] = 0.8;
G2L["b4"]["BorderSizePixel"] = 0;
G2L["b4"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["b4"]["TextSize"] = 10;
G2L["b4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b4"]["ZIndex"] = 2;
G2L["b4"]["BackgroundTransparency"] = 1;
G2L["b4"]["Size"] = UDim2.new(0, 90, 0, 25);
G2L["b4"]["ClipsDescendants"] = true;
G2L["b4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b4"]["Text"] = [[Group 1]];
G2L["b4"]["Name"] = [[GroupName]];
G2L["b4"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Templates.GroupButton.GroupNamer
G2L["b5"] = Instance.new("TextBox", G2L["a3"]);
G2L["b5"]["Visible"] = false;
G2L["b5"]["TextStrokeTransparency"] = 0.8;
G2L["b5"]["Name"] = [[GroupNamer]];
G2L["b5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["b5"]["ZIndex"] = 2;
G2L["b5"]["BorderSizePixel"] = 0;
G2L["b5"]["TextSize"] = 10;
G2L["b5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b5"]["ClipsDescendants"] = true;
G2L["b5"]["Size"] = UDim2.new(0, 90, 0, 25);
G2L["b5"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["b5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b5"]["Text"] = [[Group 1]];
G2L["b5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.GroupList
G2L["b6"] = Instance.new("ScrollingFrame", G2L["a1"]);
G2L["b6"]["BorderSizePixel"] = 0;
G2L["b6"]["CanvasSize"] = UDim2.new(1, -10, 0, 0);
G2L["b6"]["TopImage"] = [[rbxasset://textures/blackBkg_square.png]];
G2L["b6"]["MidImage"] = [[rbxasset://textures/blackBkg_square.png]];
G2L["b6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b6"]["Name"] = [[GroupList]];
G2L["b6"]["BottomImage"] = [[rbxasset://textures/blackBkg_square.png]];
G2L["b6"]["Size"] = UDim2.new(1, -10, 0, 70);
G2L["b6"]["Position"] = UDim2.new(0, 10, 0, 30);
G2L["b6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b6"]["ScrollBarThickness"] = 3;
G2L["b6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.SelectNote
G2L["b7"] = Instance.new("TextLabel", G2L["a1"]);
G2L["b7"]["TextWrapped"] = true;
G2L["b7"]["TextStrokeTransparency"] = 0.5;
G2L["b7"]["BorderSizePixel"] = 0;
G2L["b7"]["TextSize"] = 14;
G2L["b7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["b7"]["TextScaled"] = true;
G2L["b7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["b7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b7"]["BackgroundTransparency"] = 1;
G2L["b7"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["b7"]["Visible"] = false;
G2L["b7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b7"]["Text"] = [[Select something to use this tool.]];
G2L["b7"]["Name"] = [[SelectNote]];
G2L["b7"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Title
G2L["b8"] = Instance.new("Frame", G2L["a1"]);
G2L["b8"]["BorderSizePixel"] = 0;
G2L["b8"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["b8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b8"]["Name"] = [[Title]];
G2L["b8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Title.CreateButton
G2L["b9"] = Instance.new("TextButton", G2L["b8"]);
G2L["b9"]["BorderSizePixel"] = 0;
G2L["b9"]["TextSize"] = 10;
G2L["b9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b9"]["BackgroundColor3"] = Color3.fromRGB(58, 58, 58);
G2L["b9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b9"]["BackgroundTransparency"] = 0.5;
G2L["b9"]["Size"] = UDim2.new(0, 40, 0, 16);
G2L["b9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["b9"]["Text"] = [[NEW]];
G2L["b9"]["Name"] = [[CreateButton]];
G2L["b9"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Title.ColorBar
G2L["ba"] = Instance.new("Frame", G2L["b8"]);
G2L["ba"]["BorderSizePixel"] = 0;
G2L["ba"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ba"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["ba"]["Position"] = UDim2.new(0, 7, 0, -3);
G2L["ba"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ba"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTGroupsGUI.Title.Label
G2L["bb"] = Instance.new("TextLabel", G2L["b8"]);
G2L["bb"]["TextWrapped"] = true;
G2L["bb"]["TextStrokeTransparency"] = 0;
G2L["bb"]["BorderSizePixel"] = 0;
G2L["bb"]["TextSize"] = 10;
G2L["bb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["bb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["bb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["bb"]["BackgroundTransparency"] = 1;
G2L["bb"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["bb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["bb"]["Text"] = [[SELECTION GROUPS]];
G2L["bb"]["Name"] = [[Label]];
G2L["bb"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI
G2L["bc"] = Instance.new("Frame", G2L["52"]);
G2L["bc"]["Active"] = true;
G2L["bc"]["BorderSizePixel"] = 0;
G2L["bc"]["Size"] = UDim2.new(0, 200, 0, 125);
G2L["bc"]["Position"] = UDim2.new(0, 0, 0.4, 0);
G2L["bc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["bc"]["Name"] = [[BTDecorateToolGUI]];
G2L["bc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.BottomColorBar
G2L["bd"] = Instance.new("Frame", G2L["bc"]);
G2L["bd"]["BorderSizePixel"] = 0;
G2L["bd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["bd"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["bd"]["Position"] = UDim2.new(0, 5, 1, -2);
G2L["bd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["bd"]["Name"] = [[BottomColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Title
G2L["be"] = Instance.new("Frame", G2L["bc"]);
G2L["be"]["BorderSizePixel"] = 0;
G2L["be"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["be"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["be"]["Name"] = [[Title]];
G2L["be"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Title.ColorBar
G2L["bf"] = Instance.new("Frame", G2L["be"]);
G2L["bf"]["BorderSizePixel"] = 0;
G2L["bf"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["bf"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["bf"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["bf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["bf"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Title.Label
G2L["c0"] = Instance.new("TextLabel", G2L["be"]);
G2L["c0"]["TextWrapped"] = true;
G2L["c0"]["TextStrokeTransparency"] = 0;
G2L["c0"]["BorderSizePixel"] = 0;
G2L["c0"]["TextSize"] = 10;
G2L["c0"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["c0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c0"]["BackgroundTransparency"] = 1;
G2L["c0"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["c0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c0"]["Text"] = [[DECORATE TOOL]];
G2L["c0"]["Name"] = [[Label]];
G2L["c0"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Title.F3XSignature
G2L["c1"] = Instance.new("TextLabel", G2L["be"]);
G2L["c1"]["TextWrapped"] = true;
G2L["c1"]["TextStrokeTransparency"] = 0.9;
G2L["c1"]["BorderSizePixel"] = 0;
G2L["c1"]["TextSize"] = 14;
G2L["c1"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["c1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c1"]["BackgroundTransparency"] = 1;
G2L["c1"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["c1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c1"]["Text"] = [[F3X]];
G2L["c1"]["Name"] = [[F3XSignature]];
G2L["c1"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke
G2L["c2"] = Instance.new("Frame", G2L["bc"]);
G2L["c2"]["BorderSizePixel"] = 0;
G2L["c2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c2"]["ClipsDescendants"] = true;
G2L["c2"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["c2"]["Position"] = UDim2.new(0, 10, 0, 30);
G2L["c2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c2"]["Name"] = [[Smoke]];
G2L["c2"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Label
G2L["c3"] = Instance.new("TextLabel", G2L["c2"]);
G2L["c3"]["TextWrapped"] = true;
G2L["c3"]["TextStrokeTransparency"] = 0.5;
G2L["c3"]["BorderSizePixel"] = 0;
G2L["c3"]["TextSize"] = 10;
G2L["c3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["c3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c3"]["BackgroundTransparency"] = 1;
G2L["c3"]["Size"] = UDim2.new(0, 60, 0, 25);
G2L["c3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c3"]["Text"] = [[Smoke]];
G2L["c3"]["Name"] = [[Label]];
G2L["c3"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.ArrowButton
G2L["c4"] = Instance.new("ImageButton", G2L["c2"]);
G2L["c4"]["BorderSizePixel"] = 0;
G2L["c4"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["c4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c4"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["c4"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["c4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c4"]["Name"] = [[ArrowButton]];
G2L["c4"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.ColorBar
G2L["c5"] = Instance.new("Frame", G2L["c2"]);
G2L["c5"]["BorderSizePixel"] = 0;
G2L["c5"]["BackgroundColor3"] = Color3.fromRGB(255, 175, 61);
G2L["c5"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["c5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c5"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.AddButton
G2L["c6"] = Instance.new("TextButton", G2L["c2"]);
G2L["c6"]["BorderSizePixel"] = 0;
G2L["c6"]["TextSize"] = 10;
G2L["c6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c6"]["BackgroundTransparency"] = 0.75;
G2L["c6"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["c6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c6"]["Text"] = [[ADD]];
G2L["c6"]["Name"] = [[AddButton]];
G2L["c6"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.RemoveButton
G2L["c7"] = Instance.new("TextButton", G2L["c2"]);
G2L["c7"]["BorderSizePixel"] = 0;
G2L["c7"]["TextSize"] = 10;
G2L["c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["c7"]["BackgroundTransparency"] = 0.75;
G2L["c7"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["c7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c7"]["Text"] = [[REMOVE]];
G2L["c7"]["Name"] = [[RemoveButton]];
G2L["c7"]["Visible"] = false;
G2L["c7"]["Position"] = UDim2.new(0, 127, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Shadow
G2L["c8"] = Instance.new("Frame", G2L["c2"]);
G2L["c8"]["BorderSizePixel"] = 0;
G2L["c8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c8"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["c8"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["c8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c8"]["Name"] = [[Shadow]];
G2L["c8"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options
G2L["c9"] = Instance.new("Frame", G2L["c2"]);
G2L["c9"]["BorderSizePixel"] = 0;
G2L["c9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c9"]["ClipsDescendants"] = true;
G2L["c9"]["Size"] = UDim2.new(1, -3, 0, 72);
G2L["c9"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["c9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["c9"]["Name"] = [[Options]];
G2L["c9"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption
G2L["ca"] = Instance.new("Frame", G2L["c9"]);
G2L["ca"]["BorderSizePixel"] = 0;
G2L["ca"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["ca"]["Position"] = UDim2.new(0, 100, 0, 10);
G2L["ca"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ca"]["Name"] = [[OpacityOption]];
G2L["ca"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption.Label
G2L["cb"] = Instance.new("TextLabel", G2L["ca"]);
G2L["cb"]["TextWrapped"] = true;
G2L["cb"]["TextStrokeTransparency"] = 0;
G2L["cb"]["BorderSizePixel"] = 0;
G2L["cb"]["TextSize"] = 10;
G2L["cb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["cb"]["BackgroundTransparency"] = 1;
G2L["cb"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["cb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["cb"]["Text"] = [[Opacity]];
G2L["cb"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption.Input
G2L["cc"] = Instance.new("Frame", G2L["ca"]);
G2L["cc"]["BorderSizePixel"] = 0;
G2L["cc"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["cc"]["Position"] = UDim2.new(0, 45, 0, 0);
G2L["cc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["cc"]["Name"] = [[Input]];
G2L["cc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption.Input.Background
G2L["cd"] = Instance.new("ImageLabel", G2L["cc"]);
G2L["cd"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["cd"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["cd"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["cd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["cd"]["BackgroundTransparency"] = 1;
G2L["cd"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption.Input.SelectedIndicator
G2L["ce"] = Instance.new("Frame", G2L["cc"]);
G2L["ce"]["BorderSizePixel"] = 0;
G2L["ce"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ce"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["ce"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["ce"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ce"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.OpacityOption.Input.TextBox
G2L["cf"] = Instance.new("TextBox", G2L["cc"]);
G2L["cf"]["ZIndex"] = 2;
G2L["cf"]["BorderSizePixel"] = 0;
G2L["cf"]["TextSize"] = 10;
G2L["cf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["cf"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["cf"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["cf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["cf"]["Text"] = [[1]];
G2L["cf"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption
G2L["d0"] = Instance.new("Frame", G2L["c9"]);
G2L["d0"]["BorderSizePixel"] = 0;
G2L["d0"]["Size"] = UDim2.new(1, -115, 0, 25);
G2L["d0"]["Position"] = UDim2.new(0, 100, 0, 45);
G2L["d0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d0"]["Name"] = [[VelocityOption]];
G2L["d0"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption.Label
G2L["d1"] = Instance.new("TextLabel", G2L["d0"]);
G2L["d1"]["TextWrapped"] = true;
G2L["d1"]["TextStrokeTransparency"] = 0;
G2L["d1"]["BorderSizePixel"] = 0;
G2L["d1"]["TextSize"] = 10;
G2L["d1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d1"]["BackgroundTransparency"] = 1;
G2L["d1"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["d1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d1"]["Text"] = [[Velocity]];
G2L["d1"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption.Input
G2L["d2"] = Instance.new("Frame", G2L["d0"]);
G2L["d2"]["BorderSizePixel"] = 0;
G2L["d2"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["d2"]["Position"] = UDim2.new(0, 45, 0, 0);
G2L["d2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d2"]["Name"] = [[Input]];
G2L["d2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption.Input.Background
G2L["d3"] = Instance.new("ImageLabel", G2L["d2"]);
G2L["d3"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["d3"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["d3"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["d3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d3"]["BackgroundTransparency"] = 1;
G2L["d3"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption.Input.SelectedIndicator
G2L["d4"] = Instance.new("Frame", G2L["d2"]);
G2L["d4"]["BorderSizePixel"] = 0;
G2L["d4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d4"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["d4"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["d4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d4"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.VelocityOption.Input.TextBox
G2L["d5"] = Instance.new("TextBox", G2L["d2"]);
G2L["d5"]["ZIndex"] = 2;
G2L["d5"]["BorderSizePixel"] = 0;
G2L["d5"]["TextSize"] = 10;
G2L["d5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["d5"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["d5"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["d5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d5"]["Text"] = [[90]];
G2L["d5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption
G2L["d6"] = Instance.new("Frame", G2L["c9"]);
G2L["d6"]["BorderSizePixel"] = 0;
G2L["d6"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["d6"]["Position"] = UDim2.new(0, 0, 0, 45);
G2L["d6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d6"]["Name"] = [[SizeOption]];
G2L["d6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption.Label
G2L["d7"] = Instance.new("TextLabel", G2L["d6"]);
G2L["d7"]["TextWrapped"] = true;
G2L["d7"]["TextStrokeTransparency"] = 0;
G2L["d7"]["BorderSizePixel"] = 0;
G2L["d7"]["TextSize"] = 10;
G2L["d7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["d7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["d7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d7"]["BackgroundTransparency"] = 1;
G2L["d7"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["d7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d7"]["Text"] = [[Size]];
G2L["d7"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption.Input
G2L["d8"] = Instance.new("Frame", G2L["d6"]);
G2L["d8"]["BorderSizePixel"] = 0;
G2L["d8"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["d8"]["Position"] = UDim2.new(0, 30, 0, 0);
G2L["d8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d8"]["Name"] = [[Input]];
G2L["d8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption.Input.Background
G2L["d9"] = Instance.new("ImageLabel", G2L["d8"]);
G2L["d9"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["d9"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["d9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["d9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["d9"]["BackgroundTransparency"] = 1;
G2L["d9"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption.Input.SelectedIndicator
G2L["da"] = Instance.new("Frame", G2L["d8"]);
G2L["da"]["BorderSizePixel"] = 0;
G2L["da"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["da"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["da"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["da"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["da"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.SizeOption.Input.TextBox
G2L["db"] = Instance.new("TextBox", G2L["d8"]);
G2L["db"]["ZIndex"] = 2;
G2L["db"]["BorderSizePixel"] = 0;
G2L["db"]["TextSize"] = 10;
G2L["db"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["db"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["db"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["db"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["db"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["db"]["Text"] = [[16]];
G2L["db"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption
G2L["dc"] = Instance.new("Frame", G2L["c9"]);
G2L["dc"]["BorderSizePixel"] = 0;
G2L["dc"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["dc"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["dc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["dc"]["Name"] = [[ColorOption]];
G2L["dc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.HSVPicker
G2L["dd"] = Instance.new("ImageButton", G2L["dc"]);
G2L["dd"]["BorderSizePixel"] = 0;
G2L["dd"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["dd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["dd"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["dd"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["dd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["dd"]["Name"] = [[HSVPicker]];
G2L["dd"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.HSVPicker.Shadow
G2L["de"] = Instance.new("Frame", G2L["dd"]);
G2L["de"]["BorderSizePixel"] = 0;
G2L["de"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["de"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["de"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["de"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["de"]["Name"] = [[Shadow]];
G2L["de"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.Label
G2L["df"] = Instance.new("TextLabel", G2L["dc"]);
G2L["df"]["TextWrapped"] = true;
G2L["df"]["TextStrokeTransparency"] = 0;
G2L["df"]["BorderSizePixel"] = 0;
G2L["df"]["TextSize"] = 10;
G2L["df"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["df"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["df"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["df"]["BackgroundTransparency"] = 1;
G2L["df"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["df"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["df"]["Text"] = [[Color]];
G2L["df"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.Indicator
G2L["e0"] = Instance.new("Frame", G2L["dc"]);
G2L["e0"]["BorderSizePixel"] = 0;
G2L["e0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e0"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["e0"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["e0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e0"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.Indicator.Shadow
G2L["e1"] = Instance.new("Frame", G2L["e0"]);
G2L["e1"]["BorderSizePixel"] = 0;
G2L["e1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e1"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["e1"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["e1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e1"]["Name"] = [[Shadow]];
G2L["e1"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Smoke.Options.ColorOption.Indicator.Varies
G2L["e2"] = Instance.new("TextLabel", G2L["e0"]);
G2L["e2"]["TextWrapped"] = true;
G2L["e2"]["TextStrokeTransparency"] = 0.75;
G2L["e2"]["BorderSizePixel"] = 0;
G2L["e2"]["TextSize"] = 14;
G2L["e2"]["TextScaled"] = true;
G2L["e2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["e2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e2"]["BackgroundTransparency"] = 1;
G2L["e2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["e2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e2"]["Text"] = [[]];
G2L["e2"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.SelectNote
G2L["e3"] = Instance.new("TextLabel", G2L["bc"]);
G2L["e3"]["TextWrapped"] = true;
G2L["e3"]["TextStrokeTransparency"] = 0.5;
G2L["e3"]["BorderSizePixel"] = 0;
G2L["e3"]["TextSize"] = 14;
G2L["e3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["e3"]["TextScaled"] = true;
G2L["e3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e3"]["BackgroundTransparency"] = 1;
G2L["e3"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["e3"]["Visible"] = false;
G2L["e3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e3"]["Text"] = [[Select something to use this tool.]];
G2L["e3"]["Name"] = [[SelectNote]];
G2L["e3"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire
G2L["e4"] = Instance.new("Frame", G2L["bc"]);
G2L["e4"]["BorderSizePixel"] = 0;
G2L["e4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e4"]["ClipsDescendants"] = true;
G2L["e4"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["e4"]["Position"] = UDim2.new(0, 10, 0, 60);
G2L["e4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e4"]["Name"] = [[Fire]];
G2L["e4"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Label
G2L["e5"] = Instance.new("TextLabel", G2L["e4"]);
G2L["e5"]["TextWrapped"] = true;
G2L["e5"]["TextStrokeTransparency"] = 0.5;
G2L["e5"]["BorderSizePixel"] = 0;
G2L["e5"]["TextSize"] = 10;
G2L["e5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["e5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["e5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e5"]["BackgroundTransparency"] = 1;
G2L["e5"]["Size"] = UDim2.new(0, 60, 0, 25);
G2L["e5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e5"]["Text"] = [[Fire]];
G2L["e5"]["Name"] = [[Label]];
G2L["e5"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.ArrowButton
G2L["e6"] = Instance.new("ImageButton", G2L["e4"]);
G2L["e6"]["BorderSizePixel"] = 0;
G2L["e6"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["e6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e6"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["e6"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["e6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e6"]["Name"] = [[ArrowButton]];
G2L["e6"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.ColorBar
G2L["e7"] = Instance.new("Frame", G2L["e4"]);
G2L["e7"]["BorderSizePixel"] = 0;
G2L["e7"]["BackgroundColor3"] = Color3.fromRGB(218, 0, 255);
G2L["e7"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["e7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["e7"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.AddButton
G2L["e8"] = Instance.new("TextButton", G2L["e4"]);
G2L["e8"]["BorderSizePixel"] = 0;
G2L["e8"]["TextSize"] = 10;
G2L["e8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["e8"]["BackgroundTransparency"] = 0.75;
G2L["e8"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["e8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e8"]["Text"] = [[ADD]];
G2L["e8"]["Name"] = [[AddButton]];
G2L["e8"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.RemoveButton
G2L["e9"] = Instance.new("TextButton", G2L["e4"]);
G2L["e9"]["BorderSizePixel"] = 0;
G2L["e9"]["TextSize"] = 10;
G2L["e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["e9"]["BackgroundTransparency"] = 0.75;
G2L["e9"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["e9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e9"]["Text"] = [[REMOVE]];
G2L["e9"]["Name"] = [[RemoveButton]];
G2L["e9"]["Visible"] = false;
G2L["e9"]["Position"] = UDim2.new(0, 90, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Shadow
G2L["ea"] = Instance.new("Frame", G2L["e4"]);
G2L["ea"]["BorderSizePixel"] = 0;
G2L["ea"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ea"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["ea"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["ea"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ea"]["Name"] = [[Shadow]];
G2L["ea"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options
G2L["eb"] = Instance.new("Frame", G2L["e4"]);
G2L["eb"]["BorderSizePixel"] = 0;
G2L["eb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["eb"]["Size"] = UDim2.new(1, -3, 0, 72);
G2L["eb"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["eb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["eb"]["Name"] = [[Options]];
G2L["eb"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption
G2L["ec"] = Instance.new("Frame", G2L["eb"]);
G2L["ec"]["BorderSizePixel"] = 0;
G2L["ec"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["ec"]["Position"] = UDim2.new(0, 0, 0, 45);
G2L["ec"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ec"]["Name"] = [[HeatOption]];
G2L["ec"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption.Label
G2L["ed"] = Instance.new("TextLabel", G2L["ec"]);
G2L["ed"]["TextWrapped"] = true;
G2L["ed"]["TextStrokeTransparency"] = 0;
G2L["ed"]["BorderSizePixel"] = 0;
G2L["ed"]["TextSize"] = 10;
G2L["ed"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["ed"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["ed"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ed"]["BackgroundTransparency"] = 1;
G2L["ed"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["ed"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ed"]["Text"] = [[Heat]];
G2L["ed"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption.Input
G2L["ee"] = Instance.new("Frame", G2L["ec"]);
G2L["ee"]["BorderSizePixel"] = 0;
G2L["ee"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["ee"]["Position"] = UDim2.new(0, 34, 0, 0);
G2L["ee"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ee"]["Name"] = [[Input]];
G2L["ee"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption.Input.Background
G2L["ef"] = Instance.new("ImageLabel", G2L["ee"]);
G2L["ef"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["ef"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["ef"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["ef"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ef"]["BackgroundTransparency"] = 1;
G2L["ef"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption.Input.SelectedIndicator
G2L["f0"] = Instance.new("Frame", G2L["ee"]);
G2L["f0"]["BorderSizePixel"] = 0;
G2L["f0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f0"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["f0"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["f0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f0"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.HeatOption.Input.TextBox
G2L["f1"] = Instance.new("TextBox", G2L["ee"]);
G2L["f1"]["ZIndex"] = 2;
G2L["f1"]["BorderSizePixel"] = 0;
G2L["f1"]["TextSize"] = 10;
G2L["f1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["f1"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["f1"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["f1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f1"]["Text"] = [[1]];
G2L["f1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption
G2L["f2"] = Instance.new("Frame", G2L["eb"]);
G2L["f2"]["BorderSizePixel"] = 0;
G2L["f2"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["f2"]["Position"] = UDim2.new(0, 90, 0, 45);
G2L["f2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f2"]["Name"] = [[SizeOption]];
G2L["f2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption.Label
G2L["f3"] = Instance.new("TextLabel", G2L["f2"]);
G2L["f3"]["TextWrapped"] = true;
G2L["f3"]["TextStrokeTransparency"] = 0;
G2L["f3"]["BorderSizePixel"] = 0;
G2L["f3"]["TextSize"] = 10;
G2L["f3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["f3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["f3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f3"]["BackgroundTransparency"] = 1;
G2L["f3"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["f3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f3"]["Text"] = [[Size]];
G2L["f3"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption.Input
G2L["f4"] = Instance.new("Frame", G2L["f2"]);
G2L["f4"]["BorderSizePixel"] = 0;
G2L["f4"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["f4"]["Position"] = UDim2.new(0, 30, 0, 0);
G2L["f4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f4"]["Name"] = [[Input]];
G2L["f4"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption.Input.Background
G2L["f5"] = Instance.new("ImageLabel", G2L["f4"]);
G2L["f5"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["f5"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["f5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["f5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f5"]["BackgroundTransparency"] = 1;
G2L["f5"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption.Input.SelectedIndicator
G2L["f6"] = Instance.new("Frame", G2L["f4"]);
G2L["f6"]["BorderSizePixel"] = 0;
G2L["f6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f6"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["f6"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["f6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f6"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SizeOption.Input.TextBox
G2L["f7"] = Instance.new("TextBox", G2L["f4"]);
G2L["f7"]["ZIndex"] = 2;
G2L["f7"]["BorderSizePixel"] = 0;
G2L["f7"]["TextSize"] = 10;
G2L["f7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["f7"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["f7"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["f7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f7"]["Text"] = [[16]];
G2L["f7"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption
G2L["f8"] = Instance.new("Frame", G2L["eb"]);
G2L["f8"]["BorderSizePixel"] = 0;
G2L["f8"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["f8"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["f8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f8"]["Name"] = [[ColorOption]];
G2L["f8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.HSVPicker
G2L["f9"] = Instance.new("ImageButton", G2L["f8"]);
G2L["f9"]["BorderSizePixel"] = 0;
G2L["f9"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["f9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f9"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["f9"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["f9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["f9"]["Name"] = [[HSVPicker]];
G2L["f9"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.HSVPicker.Shadow
G2L["fa"] = Instance.new("Frame", G2L["f9"]);
G2L["fa"]["BorderSizePixel"] = 0;
G2L["fa"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["fa"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["fa"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["fa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["fa"]["Name"] = [[Shadow]];
G2L["fa"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.Label
G2L["fb"] = Instance.new("TextLabel", G2L["f8"]);
G2L["fb"]["TextWrapped"] = true;
G2L["fb"]["TextStrokeTransparency"] = 0;
G2L["fb"]["BorderSizePixel"] = 0;
G2L["fb"]["TextSize"] = 10;
G2L["fb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["fb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["fb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["fb"]["BackgroundTransparency"] = 1;
G2L["fb"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["fb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["fb"]["Text"] = [[Color]];
G2L["fb"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.Indicator
G2L["fc"] = Instance.new("Frame", G2L["f8"]);
G2L["fc"]["BorderSizePixel"] = 0;
G2L["fc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["fc"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["fc"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["fc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["fc"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.Indicator.Shadow
G2L["fd"] = Instance.new("Frame", G2L["fc"]);
G2L["fd"]["BorderSizePixel"] = 0;
G2L["fd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["fd"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["fd"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["fd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["fd"]["Name"] = [[Shadow]];
G2L["fd"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.ColorOption.Indicator.Varies
G2L["fe"] = Instance.new("TextLabel", G2L["fc"]);
G2L["fe"]["TextWrapped"] = true;
G2L["fe"]["TextStrokeTransparency"] = 0.75;
G2L["fe"]["BorderSizePixel"] = 0;
G2L["fe"]["TextSize"] = 14;
G2L["fe"]["TextScaled"] = true;
G2L["fe"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["fe"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["fe"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["fe"]["BackgroundTransparency"] = 1;
G2L["fe"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["fe"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["fe"]["Text"] = [[]];
G2L["fe"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption
G2L["ff"] = Instance.new("Frame", G2L["eb"]);
G2L["ff"]["BorderSizePixel"] = 0;
G2L["ff"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["ff"]["Position"] = UDim2.new(0, 100, 0, 10);
G2L["ff"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["ff"]["Name"] = [[SecondaryColorOption]];
G2L["ff"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.HSVPicker
G2L["100"] = Instance.new("ImageButton", G2L["ff"]);
G2L["100"]["BorderSizePixel"] = 0;
G2L["100"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["100"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["100"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["100"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["100"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["100"]["Name"] = [[HSVPicker]];
G2L["100"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.HSVPicker.Shadow
G2L["101"] = Instance.new("Frame", G2L["100"]);
G2L["101"]["BorderSizePixel"] = 0;
G2L["101"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["101"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["101"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["101"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["101"]["Name"] = [[Shadow]];
G2L["101"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.Label
G2L["102"] = Instance.new("TextLabel", G2L["ff"]);
G2L["102"]["TextWrapped"] = true;
G2L["102"]["TextStrokeTransparency"] = 0;
G2L["102"]["BorderSizePixel"] = 0;
G2L["102"]["TextSize"] = 10;
G2L["102"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["102"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["102"]["BackgroundTransparency"] = 1;
G2L["102"]["Size"] = UDim2.new(0, 30, 0, 25);
G2L["102"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["102"]["Text"] = [[2nd Color]];
G2L["102"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.Indicator
G2L["103"] = Instance.new("Frame", G2L["ff"]);
G2L["103"]["BorderSizePixel"] = 0;
G2L["103"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["103"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["103"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["103"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["103"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.Indicator.Shadow
G2L["104"] = Instance.new("Frame", G2L["103"]);
G2L["104"]["BorderSizePixel"] = 0;
G2L["104"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["104"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["104"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["104"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["104"]["Name"] = [[Shadow]];
G2L["104"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Fire.Options.SecondaryColorOption.Indicator.Varies
G2L["105"] = Instance.new("TextLabel", G2L["103"]);
G2L["105"]["TextWrapped"] = true;
G2L["105"]["TextStrokeTransparency"] = 0.75;
G2L["105"]["BorderSizePixel"] = 0;
G2L["105"]["TextSize"] = 14;
G2L["105"]["TextScaled"] = true;
G2L["105"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["105"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["105"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["105"]["BackgroundTransparency"] = 1;
G2L["105"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["105"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["105"]["Text"] = [[]];
G2L["105"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles
G2L["106"] = Instance.new("Frame", G2L["bc"]);
G2L["106"]["BorderSizePixel"] = 0;
G2L["106"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["106"]["ClipsDescendants"] = true;
G2L["106"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["106"]["Position"] = UDim2.new(0, 10, 0, 90);
G2L["106"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["106"]["Name"] = [[Sparkles]];
G2L["106"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Label
G2L["107"] = Instance.new("TextLabel", G2L["106"]);
G2L["107"]["TextWrapped"] = true;
G2L["107"]["TextStrokeTransparency"] = 0.5;
G2L["107"]["BorderSizePixel"] = 0;
G2L["107"]["TextSize"] = 10;
G2L["107"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["107"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["107"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["107"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["107"]["BackgroundTransparency"] = 1;
G2L["107"]["Size"] = UDim2.new(0, 60, 0, 25);
G2L["107"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["107"]["Text"] = [[Sparkles]];
G2L["107"]["Name"] = [[Label]];
G2L["107"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.ArrowButton
G2L["108"] = Instance.new("ImageButton", G2L["106"]);
G2L["108"]["BorderSizePixel"] = 0;
G2L["108"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["108"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["108"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["108"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["108"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["108"]["Name"] = [[ArrowButton]];
G2L["108"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.ColorBar
G2L["109"] = Instance.new("Frame", G2L["106"]);
G2L["109"]["BorderSizePixel"] = 0;
G2L["109"]["BackgroundColor3"] = Color3.fromRGB(6, 102, 255);
G2L["109"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["109"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["109"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.AddButton
G2L["10a"] = Instance.new("TextButton", G2L["106"]);
G2L["10a"]["BorderSizePixel"] = 0;
G2L["10a"]["TextSize"] = 10;
G2L["10a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["10a"]["ZIndex"] = 2;
G2L["10a"]["BackgroundTransparency"] = 0.75;
G2L["10a"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["10a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10a"]["Text"] = [[ADD]];
G2L["10a"]["Name"] = [[AddButton]];
G2L["10a"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.RemoveButton
G2L["10b"] = Instance.new("TextButton", G2L["106"]);
G2L["10b"]["BorderSizePixel"] = 0;
G2L["10b"]["TextSize"] = 10;
G2L["10b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["10b"]["ZIndex"] = 2;
G2L["10b"]["BackgroundTransparency"] = 0.75;
G2L["10b"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["10b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10b"]["Text"] = [[REMOVE]];
G2L["10b"]["Name"] = [[RemoveButton]];
G2L["10b"]["Visible"] = false;
G2L["10b"]["Position"] = UDim2.new(0, 90, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Shadow
G2L["10c"] = Instance.new("Frame", G2L["106"]);
G2L["10c"]["BorderSizePixel"] = 0;
G2L["10c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10c"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["10c"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["10c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["10c"]["Name"] = [[Shadow]];
G2L["10c"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options
G2L["10d"] = Instance.new("Frame", G2L["106"]);
G2L["10d"]["BorderSizePixel"] = 0;
G2L["10d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["10d"]["Size"] = UDim2.new(1, -3, 0, 36);
G2L["10d"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["10d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["10d"]["Name"] = [[Options]];
G2L["10d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption
G2L["10e"] = Instance.new("Frame", G2L["10d"]);
G2L["10e"]["BorderSizePixel"] = 0;
G2L["10e"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["10e"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["10e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["10e"]["Name"] = [[ColorOption]];
G2L["10e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.HSVPicker
G2L["10f"] = Instance.new("ImageButton", G2L["10e"]);
G2L["10f"]["BorderSizePixel"] = 0;
G2L["10f"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["10f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["10f"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["10f"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["10f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["10f"]["Name"] = [[HSVPicker]];
G2L["10f"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.HSVPicker.Shadow
G2L["110"] = Instance.new("Frame", G2L["10f"]);
G2L["110"]["BorderSizePixel"] = 0;
G2L["110"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["110"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["110"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["110"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["110"]["Name"] = [[Shadow]];
G2L["110"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.Label
G2L["111"] = Instance.new("TextLabel", G2L["10e"]);
G2L["111"]["TextWrapped"] = true;
G2L["111"]["TextStrokeTransparency"] = 0;
G2L["111"]["BorderSizePixel"] = 0;
G2L["111"]["TextSize"] = 10;
G2L["111"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["111"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["111"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["111"]["BackgroundTransparency"] = 1;
G2L["111"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["111"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["111"]["Text"] = [[Color]];
G2L["111"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.Indicator
G2L["112"] = Instance.new("Frame", G2L["10e"]);
G2L["112"]["BorderSizePixel"] = 0;
G2L["112"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["112"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["112"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["112"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["112"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.Indicator.Shadow
G2L["113"] = Instance.new("Frame", G2L["112"]);
G2L["113"]["BorderSizePixel"] = 0;
G2L["113"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["113"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["113"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["113"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["113"]["Name"] = [[Shadow]];
G2L["113"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTDecorateToolGUI.Sparkles.Options.ColorOption.Indicator.Varies
G2L["114"] = Instance.new("TextLabel", G2L["112"]);
G2L["114"]["TextWrapped"] = true;
G2L["114"]["TextStrokeTransparency"] = 0.75;
G2L["114"]["BorderSizePixel"] = 0;
G2L["114"]["TextSize"] = 14;
G2L["114"]["TextScaled"] = true;
G2L["114"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["114"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["114"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["114"]["BackgroundTransparency"] = 1;
G2L["114"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["114"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["114"]["Text"] = [[]];
G2L["114"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock
G2L["115"] = Instance.new("Frame", G2L["52"]);
G2L["115"]["Active"] = true;
G2L["115"]["BorderSizePixel"] = 0;
G2L["115"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["115"]["AnchorPoint"] = Vector2.new(0, 0.5);
G2L["115"]["Size"] = UDim2.new(0, 70, 0, 380);
G2L["115"]["Position"] = UDim2.new(1, -80, 0.6, 0);
G2L["115"]["BorderColor3"] = Color3.fromRGB(36, 36, 36);
G2L["115"]["Name"] = [[Dock]];
G2L["115"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons
G2L["116"] = Instance.new("Frame", G2L["115"]);
G2L["116"]["BorderSizePixel"] = 0;
G2L["116"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["116"]["Size"] = UDim2.new(1, 0, 0, 32);
G2L["116"]["Position"] = UDim2.new(0, 0, 0, 350);
G2L["116"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["116"]["Name"] = [[InfoButtons]];
G2L["116"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.F3XSignature
G2L["117"] = Instance.new("TextLabel", G2L["116"]);
G2L["117"]["TextWrapped"] = true;
G2L["117"]["TextStrokeTransparency"] = 0.9;
G2L["117"]["BorderSizePixel"] = 0;
G2L["117"]["TextSize"] = 14;
G2L["117"]["TextScaled"] = true;
G2L["117"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["117"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["117"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["117"]["BackgroundTransparency"] = 1;
G2L["117"]["Size"] = UDim2.new(1, -28, 0, 17);
G2L["117"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["117"]["Text"] = [[F3X]];
G2L["117"]["Name"] = [[F3XSignature]];
G2L["117"]["Position"] = UDim2.new(0, 0, 0, 7);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.HelpButton
G2L["118"] = Instance.new("ImageButton", G2L["116"]);
G2L["118"]["BorderSizePixel"] = 0;
G2L["118"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["118"]["BackgroundColor3"] = Color3.fromRGB(86, 171, 255);
G2L["118"]["Image"] = [[http://www.roblox.com/asset/?id=141911973]];
G2L["118"]["Size"] = UDim2.new(0, 32, 0, 32);
G2L["118"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["118"]["Name"] = [[HelpButton]];
G2L["118"]["Position"] = UDim2.new(1, -32, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.HelpButton.Tooltip
G2L["119"] = Instance.new("TextLabel", G2L["118"]);
G2L["119"]["ZIndex"] = 10;
G2L["119"]["BorderSizePixel"] = 0;
G2L["119"]["TextSize"] = 10;
G2L["119"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["119"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["119"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["119"]["BackgroundTransparency"] = 0.4;
G2L["119"]["AnchorPoint"] = Vector2.new(1, 0);
G2L["119"]["Size"] = UDim2.new(0, 45, 0, 22);
G2L["119"]["Visible"] = false;
G2L["119"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["119"]["Text"] = [[HELP]];
G2L["119"]["Name"] = [[Tooltip]];
G2L["119"]["Position"] = UDim2.new(1, 0, 1, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.HelpButton.Tooltip.[Component]
G2L["11a"] = Instance.new("LocalScript", G2L["119"]);
G2L["11a"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.Shadow
G2L["11b"] = Instance.new("Frame", G2L["116"]);
G2L["11b"]["BorderSizePixel"] = 0;
G2L["11b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11b"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["11b"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["11b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["11b"]["Name"] = [[Shadow]];
G2L["11b"]["BackgroundTransparency"] = 0.7;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.SelectionButtons
G2L["11c"] = Instance.new("Frame", G2L["115"]);
G2L["11c"]["BorderSizePixel"] = 0;
G2L["11c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11c"]["Size"] = UDim2.new(1, 0, 0, 105);
G2L["11c"]["Position"] = UDim2.new(0, 0, 0, 245);
G2L["11c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["11c"]["Name"] = [[SelectionButtons]];
G2L["11c"]["BackgroundTransparency"] = 0.5;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolButtons
G2L["11d"] = Instance.new("Frame", G2L["115"]);
G2L["11d"]["BorderSizePixel"] = 0;
G2L["11d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11d"]["Size"] = UDim2.new(0, 70, 0, 245);
G2L["11d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["11d"]["Name"] = [[ToolButtons]];
G2L["11d"]["BackgroundTransparency"] = 0.6;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo
G2L["11e"] = Instance.new("Frame", G2L["115"]);
G2L["11e"]["Visible"] = false;
G2L["11e"]["BorderSizePixel"] = 0;
G2L["11e"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["11e"]["ClipsDescendants"] = true;
G2L["11e"]["Size"] = UDim2.new(0, 120, 0, 315);
G2L["11e"]["Position"] = UDim2.new(0, -120, 0, 0);
G2L["11e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["11e"]["Name"] = [[HelpInfo]];
G2L["11e"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar
G2L["11f"] = Instance.new("Frame", G2L["11e"]);
G2L["11f"]["BorderSizePixel"] = 0;
G2L["11f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["11f"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["11f"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["11f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["11f"]["Name"] = [[BottomColorBar]];
G2L["11f"]["Rotation"] = 180;
G2L["11f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar.Yellow
G2L["120"] = Instance.new("Frame", G2L["11f"]);
G2L["120"]["BorderSizePixel"] = 0;
G2L["120"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["120"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["120"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["120"]["Name"] = [[Yellow]];
G2L["120"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar.Green
G2L["121"] = Instance.new("Frame", G2L["11f"]);
G2L["121"]["BorderSizePixel"] = 0;
G2L["121"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["121"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["121"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["121"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["121"]["Name"] = [[Green]];
G2L["121"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar.Blue
G2L["122"] = Instance.new("Frame", G2L["11f"]);
G2L["122"]["BorderSizePixel"] = 0;
G2L["122"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["122"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["122"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["122"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["122"]["Name"] = [[Blue]];
G2L["122"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar.Red
G2L["123"] = Instance.new("Frame", G2L["11f"]);
G2L["123"]["BorderSizePixel"] = 0;
G2L["123"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["123"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["123"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["123"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["123"]["Name"] = [[Red]];
G2L["123"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.BottomColorBar.Purple
G2L["124"] = Instance.new("Frame", G2L["11f"]);
G2L["124"]["BorderSizePixel"] = 0;
G2L["124"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["124"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["124"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["124"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["124"]["Name"] = [[Purple]];
G2L["124"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content
G2L["125"] = Instance.new("ScrollingFrame", G2L["11e"]);
G2L["125"]["BorderSizePixel"] = 0;
G2L["125"]["CanvasSize"] = UDim2.new(0, 0, 0, 480);
G2L["125"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["125"]["Name"] = [[Content]];
G2L["125"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["125"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["125"]["ScrollBarThickness"] = 6;
G2L["125"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar
G2L["126"] = Instance.new("Frame", G2L["125"]);
G2L["126"]["BorderSizePixel"] = 0;
G2L["126"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["126"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["126"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["126"]["Name"] = [[ColorBar]];
G2L["126"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar.Yellow
G2L["127"] = Instance.new("Frame", G2L["126"]);
G2L["127"]["BorderSizePixel"] = 0;
G2L["127"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["127"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["127"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["127"]["Name"] = [[Yellow]];
G2L["127"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar.Green
G2L["128"] = Instance.new("Frame", G2L["126"]);
G2L["128"]["BorderSizePixel"] = 0;
G2L["128"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["128"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["128"]["Position"] = UDim2.new(0.2, 0, 0, 0);
G2L["128"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["128"]["Name"] = [[Green]];
G2L["128"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar.Blue
G2L["129"] = Instance.new("Frame", G2L["126"]);
G2L["129"]["BorderSizePixel"] = 0;
G2L["129"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["129"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["129"]["Position"] = UDim2.new(0.4, 0, 0, 0);
G2L["129"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["129"]["Name"] = [[Blue]];
G2L["129"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar.Red
G2L["12a"] = Instance.new("Frame", G2L["126"]);
G2L["12a"]["BorderSizePixel"] = 0;
G2L["12a"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["12a"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["12a"]["Position"] = UDim2.new(0.6, 0, 0, 0);
G2L["12a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12a"]["Name"] = [[Red]];
G2L["12a"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ColorBar.Purple
G2L["12b"] = Instance.new("Frame", G2L["126"]);
G2L["12b"]["BorderSizePixel"] = 0;
G2L["12b"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["12b"]["Size"] = UDim2.new(0.2, 0, 1, 0);
G2L["12b"]["Position"] = UDim2.new(0.8, 0, 0, 0);
G2L["12b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12b"]["Name"] = [[Purple]];
G2L["12b"]["BackgroundTransparency"] = 0.25;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ExportingInfo
G2L["12c"] = Instance.new("Frame", G2L["125"]);
G2L["12c"]["BorderSizePixel"] = 0;
G2L["12c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12c"]["Size"] = UDim2.new(1, 0, 0, 220);
G2L["12c"]["Position"] = UDim2.new(0, 0, 0, 290);
G2L["12c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12c"]["Name"] = [[ExportingInfo]];
G2L["12c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ExportingInfo.TextLabel
G2L["12d"] = Instance.new("TextLabel", G2L["12c"]);
G2L["12d"]["TextWrapped"] = true;
G2L["12d"]["BorderSizePixel"] = 0;
G2L["12d"]["TextSize"] = 10;
G2L["12d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["12d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["12d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["12d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12d"]["BackgroundTransparency"] = 1;
G2L["12d"]["Size"] = UDim2.new(0, 90, 0, 200);
G2L["12d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12d"]["Text"] = [[You can export your builds into a short code by clicking the export button, or pressing [Shift P].

Install the import plugin in ROBLOX Studio to import your creation:

roblox.com/library/142485815/import]];
G2L["12d"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ExportingInfo.TextLabel
G2L["12e"] = Instance.new("TextLabel", G2L["12c"]);
G2L["12e"]["TextWrapped"] = true;
G2L["12e"]["BorderSizePixel"] = 0;
G2L["12e"]["TextSize"] = 10;
G2L["12e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["12e"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["12e"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["12e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["12e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12e"]["BackgroundTransparency"] = 1;
G2L["12e"]["Size"] = UDim2.new(0, 90, 0, 24);
G2L["12e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12e"]["Text"] = [[Exporting your creations]];
G2L["12e"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.SelectionInfo
G2L["12f"] = Instance.new("Frame", G2L["125"]);
G2L["12f"]["BorderSizePixel"] = 0;
G2L["12f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["12f"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["12f"]["Position"] = UDim2.new(0, 0, 0, 90);
G2L["12f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["12f"]["Name"] = [[SelectionInfo]];
G2L["12f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.SelectionInfo.TextLabel
G2L["130"] = Instance.new("TextLabel", G2L["12f"]);
G2L["130"]["TextWrapped"] = true;
G2L["130"]["BorderSizePixel"] = 0;
G2L["130"]["TextSize"] = 10;
G2L["130"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["130"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["130"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["130"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["130"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["130"]["BackgroundTransparency"] = 1;
G2L["130"]["Size"] = UDim2.new(0, 95, 0, 240);
G2L["130"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["130"]["Text"] = [[Select individual multiple parts by holding [Shift] and clicking each one.

 Rectangle select multiple parts by holding [Shift], clicking, and dragging.

 Press [Shift K] to select parts inside of the selected parts.

 Press [Shift R] to clear your selection.]];
G2L["130"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.SelectionInfo.TextLabel
G2L["131"] = Instance.new("TextLabel", G2L["12f"]);
G2L["131"]["TextWrapped"] = true;
G2L["131"]["BorderSizePixel"] = 0;
G2L["131"]["TextSize"] = 10;
G2L["131"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["131"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["131"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["131"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["131"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["131"]["BackgroundTransparency"] = 1;
G2L["131"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["131"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["131"]["Text"] = [[Selecting]];
G2L["131"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ToolDescription
G2L["132"] = Instance.new("TextLabel", G2L["125"]);
G2L["132"]["TextWrapped"] = true;
G2L["132"]["BorderSizePixel"] = 0;
G2L["132"]["TextSize"] = 10;
G2L["132"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["132"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["132"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["132"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["132"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["132"]["BackgroundTransparency"] = 1;
G2L["132"]["Size"] = UDim2.new(0, 93, 0, 250);
G2L["132"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["132"]["Text"] = [[To learn more about each tool, click on it and read its help section.]];
G2L["132"]["Name"] = [[ToolDescription]];
G2L["132"]["Position"] = UDim2.new(0, 10, 0, 35);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.HelpInfo.Content.ToolName
G2L["133"] = Instance.new("TextLabel", G2L["125"]);
G2L["133"]["TextWrapped"] = true;
G2L["133"]["BorderSizePixel"] = 0;
G2L["133"]["TextSize"] = 10;
G2L["133"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["133"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["133"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["133"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["133"]["BackgroundTransparency"] = 1;
G2L["133"]["Size"] = UDim2.new(0, 80, 0, 30);
G2L["133"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["133"]["Text"] = [[BUILDING TOOLS BY F3X]];
G2L["133"]["Name"] = [[ToolName]];
G2L["133"]["Position"] = UDim2.new(0, 10, 0, 4);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.Tooltip
G2L["134"] = Instance.new("TextLabel", G2L["115"]);
G2L["134"]["ZIndex"] = 10;
G2L["134"]["BorderSizePixel"] = 0;
G2L["134"]["TextSize"] = 10;
G2L["134"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["134"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["134"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["134"]["BackgroundTransparency"] = 0.4;
G2L["134"]["Size"] = UDim2.new(0, 50, 0, 22);
G2L["134"]["Visible"] = false;
G2L["134"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["134"]["Text"] = [[TEST]];
G2L["134"]["Name"] = [[Tooltip]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.Tooltip.[Component]
G2L["135"] = Instance.new("LocalScript", G2L["134"]);
G2L["135"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.SelectionButton
G2L["136"] = Instance.new("ImageButton", G2L["115"]);
G2L["136"]["BorderSizePixel"] = 0;
G2L["136"]["Visible"] = false;
G2L["136"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["136"]["BackgroundColor3"] = Color3.fromRGB(86, 171, 255);
G2L["136"]["Image"] = [[rbxassetid://142074563]];
G2L["136"]["Size"] = UDim2.new(0, 35, 0, 35);
G2L["136"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["136"]["Name"] = [[SelectionButton]];
G2L["136"]["Position"] = UDim2.new(0, 0, 0, 70);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolButton
G2L["137"] = Instance.new("ImageButton", G2L["115"]);
G2L["137"]["BorderSizePixel"] = 0;
G2L["137"]["AutoButtonColor"] = false;
G2L["137"]["Visible"] = false;
G2L["137"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["137"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["137"]["Image"] = [[http://www.roblox.com/asset/?id=141741323]];
G2L["137"]["Size"] = UDim2.new(0, 35, 0, 35);
G2L["137"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["137"]["Name"] = [[ToolButton]];
G2L["137"]["Position"] = UDim2.new(0, 0, 0, 105);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolButton.Hotkey
G2L["138"] = Instance.new("TextLabel", G2L["137"]);
G2L["138"]["BorderSizePixel"] = 0;
G2L["138"]["TextSize"] = 10;
G2L["138"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["138"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["138"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["138"]["BackgroundTransparency"] = 1;
G2L["138"]["Size"] = UDim2.new(0, 13, 0, 13);
G2L["138"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["138"]["Text"] = [[M]];
G2L["138"]["Name"] = [[Hotkey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.[Component]
G2L["139"] = Instance.new("LocalScript", G2L["115"]);
G2L["139"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation
G2L["13a"] = Instance.new("Frame", G2L["115"]);
G2L["13a"]["BorderSizePixel"] = 0;
G2L["13a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13a"]["ClipsDescendants"] = true;
G2L["13a"]["Size"] = UDim2.new(0, 120, 0, 315);
G2L["13a"]["Position"] = UDim2.new(0, -120, 0, 0);
G2L["13a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13a"]["Name"] = [[ToolInformation]];
G2L["13a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.PaintInfo
G2L["13b"] = Instance.new("Frame", G2L["13a"]);
G2L["13b"]["Visible"] = false;
G2L["13b"]["BorderSizePixel"] = 0;
G2L["13b"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["13b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["13b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13b"]["Name"] = [[PaintInfo]];
G2L["13b"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.PaintInfo.Content
G2L["13c"] = Instance.new("Frame", G2L["13b"]);
G2L["13c"]["BorderSizePixel"] = 0;
G2L["13c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13c"]["Size"] = UDim2.new(1, 0, 0, 70);
G2L["13c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13c"]["Name"] = [[Content]];
G2L["13c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.PaintInfo.Content.ColorBar
G2L["13d"] = Instance.new("Frame", G2L["13c"]);
G2L["13d"]["BorderSizePixel"] = 0;
G2L["13d"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["13d"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["13d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13d"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.PaintInfo.Content.ToolDescription
G2L["13e"] = Instance.new("TextLabel", G2L["13c"]);
G2L["13e"]["TextWrapped"] = true;
G2L["13e"]["BorderSizePixel"] = 0;
G2L["13e"]["TextSize"] = 10;
G2L["13e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["13e"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["13e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["13e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13e"]["BackgroundTransparency"] = 1;
G2L["13e"]["Size"] = UDim2.new(0, 95, 0, 200);
G2L["13e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13e"]["Text"] = [[Lets you paint parts in different colors.

TIP: Press R while hovering over a part to copy its color.]];
G2L["13e"]["Name"] = [[ToolDescription]];
G2L["13e"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.PaintInfo.Content.ToolName
G2L["13f"] = Instance.new("TextLabel", G2L["13c"]);
G2L["13f"]["BorderSizePixel"] = 0;
G2L["13f"]["TextSize"] = 10;
G2L["13f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["13f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["13f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13f"]["BackgroundTransparency"] = 1;
G2L["13f"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["13f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["13f"]["Text"] = [[PAINT TOOL]];
G2L["13f"]["Name"] = [[ToolName]];
G2L["13f"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.SurfaceInfo
G2L["140"] = Instance.new("Frame", G2L["13a"]);
G2L["140"]["Visible"] = false;
G2L["140"]["BorderSizePixel"] = 0;
G2L["140"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["140"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["140"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["140"]["Name"] = [[SurfaceInfo]];
G2L["140"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.SurfaceInfo.Content
G2L["141"] = Instance.new("Frame", G2L["140"]);
G2L["141"]["BorderSizePixel"] = 0;
G2L["141"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["141"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["141"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["141"]["Name"] = [[Content]];
G2L["141"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.SurfaceInfo.Content.ColorBar
G2L["142"] = Instance.new("Frame", G2L["141"]);
G2L["142"]["BorderSizePixel"] = 0;
G2L["142"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["142"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["142"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["142"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.SurfaceInfo.Content.ToolDescription
G2L["143"] = Instance.new("TextLabel", G2L["141"]);
G2L["143"]["TextWrapped"] = true;
G2L["143"]["BorderSizePixel"] = 0;
G2L["143"]["TextSize"] = 10;
G2L["143"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["143"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["143"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["143"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["143"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["143"]["BackgroundTransparency"] = 1;
G2L["143"]["Size"] = UDim2.new(0, 82, 0, 120);
G2L["143"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["143"]["Text"] = [[Lets you change the surfaces of parts.

TIP: Click a part's surface to select it quickly.]];
G2L["143"]["Name"] = [[ToolDescription]];
G2L["143"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.SurfaceInfo.Content.ToolName
G2L["144"] = Instance.new("TextLabel", G2L["141"]);
G2L["144"]["BorderSizePixel"] = 0;
G2L["144"]["TextSize"] = 10;
G2L["144"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["144"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["144"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["144"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["144"]["BackgroundTransparency"] = 1;
G2L["144"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["144"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["144"]["Text"] = [[SURFACE TOOL]];
G2L["144"]["Name"] = [[ToolName]];
G2L["144"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MaterialInfo
G2L["145"] = Instance.new("Frame", G2L["13a"]);
G2L["145"]["Visible"] = false;
G2L["145"]["BorderSizePixel"] = 0;
G2L["145"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["145"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["145"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["145"]["Name"] = [[MaterialInfo]];
G2L["145"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MaterialInfo.Content
G2L["146"] = Instance.new("Frame", G2L["145"]);
G2L["146"]["BorderSizePixel"] = 0;
G2L["146"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["146"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["146"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["146"]["Name"] = [[Content]];
G2L["146"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MaterialInfo.Content.ColorBar
G2L["147"] = Instance.new("Frame", G2L["146"]);
G2L["147"]["BorderSizePixel"] = 0;
G2L["147"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["147"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["147"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["147"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MaterialInfo.Content.ToolDescription
G2L["148"] = Instance.new("TextLabel", G2L["146"]);
G2L["148"]["TextWrapped"] = true;
G2L["148"]["BorderSizePixel"] = 0;
G2L["148"]["TextSize"] = 10;
G2L["148"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["148"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["148"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["148"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["148"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["148"]["BackgroundTransparency"] = 1;
G2L["148"]["Size"] = UDim2.new(0, 80, 0, 120);
G2L["148"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["148"]["Text"] = [[Lets you change the material, transparency, and reflectance of parts.]];
G2L["148"]["Name"] = [[ToolDescription]];
G2L["148"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MaterialInfo.Content.ToolName
G2L["149"] = Instance.new("TextLabel", G2L["146"]);
G2L["149"]["BorderSizePixel"] = 0;
G2L["149"]["TextSize"] = 10;
G2L["149"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["149"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["149"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["149"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["149"]["BackgroundTransparency"] = 1;
G2L["149"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["149"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["149"]["Text"] = [[MATERIAL TOOL]];
G2L["149"]["Name"] = [[ToolName]];
G2L["149"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.AnchorInfo
G2L["14a"] = Instance.new("Frame", G2L["13a"]);
G2L["14a"]["Visible"] = false;
G2L["14a"]["BorderSizePixel"] = 0;
G2L["14a"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["14a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["14a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14a"]["Name"] = [[AnchorInfo]];
G2L["14a"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.AnchorInfo.Content
G2L["14b"] = Instance.new("Frame", G2L["14a"]);
G2L["14b"]["BorderSizePixel"] = 0;
G2L["14b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["14b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14b"]["Name"] = [[Content]];
G2L["14b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.AnchorInfo.Content.ColorBar
G2L["14c"] = Instance.new("Frame", G2L["14b"]);
G2L["14c"]["BorderSizePixel"] = 0;
G2L["14c"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["14c"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["14c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14c"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.AnchorInfo.Content.ToolDescription
G2L["14d"] = Instance.new("TextLabel", G2L["14b"]);
G2L["14d"]["TextWrapped"] = true;
G2L["14d"]["BorderSizePixel"] = 0;
G2L["14d"]["TextSize"] = 10;
G2L["14d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["14d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["14d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["14d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14d"]["BackgroundTransparency"] = 1;
G2L["14d"]["Size"] = UDim2.new(0, 80, 0, 120);
G2L["14d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14d"]["Text"] = [[Lets you anchor and unanchor parts.

TIP: Press Enter to toggle anchor quickly.]];
G2L["14d"]["Name"] = [[ToolDescription]];
G2L["14d"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.AnchorInfo.Content.ToolName
G2L["14e"] = Instance.new("TextLabel", G2L["14b"]);
G2L["14e"]["BorderSizePixel"] = 0;
G2L["14e"]["TextSize"] = 10;
G2L["14e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["14e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["14e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14e"]["BackgroundTransparency"] = 1;
G2L["14e"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["14e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14e"]["Text"] = [[ANCHOR TOOL]];
G2L["14e"]["Name"] = [[ToolName]];
G2L["14e"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.NewPartInfo
G2L["14f"] = Instance.new("Frame", G2L["13a"]);
G2L["14f"]["Visible"] = false;
G2L["14f"]["BorderSizePixel"] = 0;
G2L["14f"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["14f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["14f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["14f"]["Name"] = [[NewPartInfo]];
G2L["14f"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.NewPartInfo.Content
G2L["150"] = Instance.new("Frame", G2L["14f"]);
G2L["150"]["BorderSizePixel"] = 0;
G2L["150"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["150"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["150"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["150"]["Name"] = [[Content]];
G2L["150"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.NewPartInfo.Content.ColorBar
G2L["151"] = Instance.new("Frame", G2L["150"]);
G2L["151"]["BorderSizePixel"] = 0;
G2L["151"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["151"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["151"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["151"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.NewPartInfo.Content.ToolDescription
G2L["152"] = Instance.new("TextLabel", G2L["150"]);
G2L["152"]["TextWrapped"] = true;
G2L["152"]["BorderSizePixel"] = 0;
G2L["152"]["TextSize"] = 10;
G2L["152"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["152"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["152"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["152"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["152"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["152"]["BackgroundTransparency"] = 1;
G2L["152"]["Size"] = UDim2.new(0, 80, 0, 120);
G2L["152"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["152"]["Text"] = [[Lets you create new parts.

TIP: Click and drag where you want your part to be.]];
G2L["152"]["Name"] = [[ToolDescription]];
G2L["152"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.NewPartInfo.Content.ToolName
G2L["153"] = Instance.new("TextLabel", G2L["150"]);
G2L["153"]["BorderSizePixel"] = 0;
G2L["153"]["TextSize"] = 10;
G2L["153"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["153"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["153"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["153"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["153"]["BackgroundTransparency"] = 1;
G2L["153"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["153"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["153"]["Text"] = [[NEW PART TOOL]];
G2L["153"]["Name"] = [[ToolName]];
G2L["153"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MeshInfo
G2L["154"] = Instance.new("Frame", G2L["13a"]);
G2L["154"]["Visible"] = false;
G2L["154"]["BorderSizePixel"] = 0;
G2L["154"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["154"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["154"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["154"]["Name"] = [[MeshInfo]];
G2L["154"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MeshInfo.Content
G2L["155"] = Instance.new("Frame", G2L["154"]);
G2L["155"]["BorderSizePixel"] = 0;
G2L["155"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["155"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["155"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["155"]["Name"] = [[Content]];
G2L["155"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MeshInfo.Content.ColorBar
G2L["156"] = Instance.new("Frame", G2L["155"]);
G2L["156"]["BorderSizePixel"] = 0;
G2L["156"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["156"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["156"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["156"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MeshInfo.Content.ToolDescription
G2L["157"] = Instance.new("TextLabel", G2L["155"]);
G2L["157"]["TextWrapped"] = true;
G2L["157"]["BorderSizePixel"] = 0;
G2L["157"]["TextSize"] = 10;
G2L["157"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["157"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["157"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["157"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["157"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["157"]["BackgroundTransparency"] = 1;
G2L["157"]["Size"] = UDim2.new(0, 84, 0, 260);
G2L["157"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["157"]["Text"] = [[Lets you add meshes to parts.

TIP: You can paste the link to anything with a mesh (e.g. a hat, gear, etc.) and it will automatically find the right mesh and texture IDs.

NOTE: If HttpService is not enabled, you must type the mesh or image asset ID directly.]];
G2L["157"]["Name"] = [[ToolDescription]];
G2L["157"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MeshInfo.Content.ToolName
G2L["158"] = Instance.new("TextLabel", G2L["155"]);
G2L["158"]["BorderSizePixel"] = 0;
G2L["158"]["TextSize"] = 10;
G2L["158"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["158"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["158"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["158"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["158"]["BackgroundTransparency"] = 1;
G2L["158"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["158"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["158"]["Text"] = [[MESH TOOL]];
G2L["158"]["Name"] = [[ToolName]];
G2L["158"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.TextureInfo
G2L["159"] = Instance.new("Frame", G2L["13a"]);
G2L["159"]["Visible"] = false;
G2L["159"]["BorderSizePixel"] = 0;
G2L["159"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["159"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["159"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["159"]["Name"] = [[TextureInfo]];
G2L["159"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.TextureInfo.Content
G2L["15a"] = Instance.new("Frame", G2L["159"]);
G2L["15a"]["BorderSizePixel"] = 0;
G2L["15a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15a"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["15a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15a"]["Name"] = [[Content]];
G2L["15a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.TextureInfo.Content.ColorBar
G2L["15b"] = Instance.new("Frame", G2L["15a"]);
G2L["15b"]["BorderSizePixel"] = 0;
G2L["15b"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["15b"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["15b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15b"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.TextureInfo.Content.ToolDescription
G2L["15c"] = Instance.new("TextLabel", G2L["15a"]);
G2L["15c"]["TextWrapped"] = true;
G2L["15c"]["BorderSizePixel"] = 0;
G2L["15c"]["TextSize"] = 10;
G2L["15c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["15c"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["15c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["15c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15c"]["BackgroundTransparency"] = 1;
G2L["15c"]["Size"] = UDim2.new(0, 95, 0, 250);
G2L["15c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15c"]["Text"] = [[Lets you add decals and textures to parts.

TIP: Click on any part's surface to quickly change a decal/texture's side.

TIP: You can paste the link to any decal and it'll automatically get the right image ID.

NOTE: If HttpService isn't enabled, you must manually type an image's ID.]];
G2L["15c"]["Name"] = [[ToolDescription]];
G2L["15c"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.TextureInfo.Content.ToolName
G2L["15d"] = Instance.new("TextLabel", G2L["15a"]);
G2L["15d"]["BorderSizePixel"] = 0;
G2L["15d"]["TextSize"] = 10;
G2L["15d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["15d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["15d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15d"]["BackgroundTransparency"] = 1;
G2L["15d"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["15d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15d"]["Text"] = [[TEXTURE TOOL]];
G2L["15d"]["Name"] = [[ToolName]];
G2L["15d"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.LightingInfo
G2L["15e"] = Instance.new("Frame", G2L["13a"]);
G2L["15e"]["Visible"] = false;
G2L["15e"]["BorderSizePixel"] = 0;
G2L["15e"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["15e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["15e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15e"]["Name"] = [[LightingInfo]];
G2L["15e"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.LightingInfo.Content
G2L["15f"] = Instance.new("Frame", G2L["15e"]);
G2L["15f"]["BorderSizePixel"] = 0;
G2L["15f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15f"]["Size"] = UDim2.new(1, 0, 0, 100);
G2L["15f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["15f"]["Name"] = [[Content]];
G2L["15f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.LightingInfo.Content.ColorBar
G2L["160"] = Instance.new("Frame", G2L["15f"]);
G2L["160"]["BorderSizePixel"] = 0;
G2L["160"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["160"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["160"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["160"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.LightingInfo.Content.ToolDescription
G2L["161"] = Instance.new("TextLabel", G2L["15f"]);
G2L["161"]["TextWrapped"] = true;
G2L["161"]["BorderSizePixel"] = 0;
G2L["161"]["TextSize"] = 10;
G2L["161"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["161"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["161"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["161"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["161"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["161"]["BackgroundTransparency"] = 1;
G2L["161"]["Size"] = UDim2.new(0, 80, 0, 200);
G2L["161"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["161"]["Text"] = [[Lets you add point lights, surface lights, and spotlights to parts.

TIP: Click on the surface of any part to change a light's side quickly.]];
G2L["161"]["Name"] = [[ToolDescription]];
G2L["161"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.LightingInfo.Content.ToolName
G2L["162"] = Instance.new("TextLabel", G2L["15f"]);
G2L["162"]["BorderSizePixel"] = 0;
G2L["162"]["TextSize"] = 10;
G2L["162"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["162"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["162"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["162"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["162"]["BackgroundTransparency"] = 1;
G2L["162"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["162"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["162"]["Text"] = [[LIGHTING TOOL]];
G2L["162"]["Name"] = [[ToolName]];
G2L["162"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.DecorateInfo
G2L["163"] = Instance.new("Frame", G2L["13a"]);
G2L["163"]["Visible"] = false;
G2L["163"]["BorderSizePixel"] = 0;
G2L["163"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["163"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["163"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["163"]["Name"] = [[DecorateInfo]];
G2L["163"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.DecorateInfo.Content
G2L["164"] = Instance.new("Frame", G2L["163"]);
G2L["164"]["BorderSizePixel"] = 0;
G2L["164"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["164"]["Size"] = UDim2.new(1, 0, 0, 100);
G2L["164"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["164"]["Name"] = [[Content]];
G2L["164"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.DecorateInfo.Content.ColorBar
G2L["165"] = Instance.new("Frame", G2L["164"]);
G2L["165"]["BorderSizePixel"] = 0;
G2L["165"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["165"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["165"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["165"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.DecorateInfo.Content.ToolDescription
G2L["166"] = Instance.new("TextLabel", G2L["164"]);
G2L["166"]["TextWrapped"] = true;
G2L["166"]["BorderSizePixel"] = 0;
G2L["166"]["TextSize"] = 10;
G2L["166"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["166"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["166"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["166"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["166"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["166"]["BackgroundTransparency"] = 1;
G2L["166"]["Size"] = UDim2.new(0, 80, 0, 200);
G2L["166"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["166"]["Text"] = [[Allows you to add smoke, fire, and sparkles to parts.]];
G2L["166"]["Name"] = [[ToolDescription]];
G2L["166"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.DecorateInfo.Content.ToolName
G2L["167"] = Instance.new("TextLabel", G2L["164"]);
G2L["167"]["BorderSizePixel"] = 0;
G2L["167"]["TextSize"] = 10;
G2L["167"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["167"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["167"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["167"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["167"]["BackgroundTransparency"] = 1;
G2L["167"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["167"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["167"]["Text"] = [[DECORATE TOOL]];
G2L["167"]["Name"] = [[ToolName]];
G2L["167"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.WeldInfo
G2L["168"] = Instance.new("Frame", G2L["13a"]);
G2L["168"]["Visible"] = false;
G2L["168"]["BorderSizePixel"] = 0;
G2L["168"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["168"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["168"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["168"]["Name"] = [[WeldInfo]];
G2L["168"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.WeldInfo.Content
G2L["169"] = Instance.new("Frame", G2L["168"]);
G2L["169"]["BorderSizePixel"] = 0;
G2L["169"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["169"]["Size"] = UDim2.new(1, 0, 0, 310);
G2L["169"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["169"]["Name"] = [[Content]];
G2L["169"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.WeldInfo.Content.ColorBar
G2L["16a"] = Instance.new("Frame", G2L["169"]);
G2L["16a"]["BorderSizePixel"] = 0;
G2L["16a"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["16a"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["16a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16a"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.WeldInfo.Content.ToolDescription
G2L["16b"] = Instance.new("TextLabel", G2L["169"]);
G2L["16b"]["TextWrapped"] = true;
G2L["16b"]["BorderSizePixel"] = 0;
G2L["16b"]["TextSize"] = 10;
G2L["16b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["16b"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["16b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16b"]["BackgroundTransparency"] = 1;
G2L["16b"]["Size"] = UDim2.new(0, 90, 0, 300);
G2L["16b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16b"]["Text"] = [[Allows you to weld parts to hold them together.

NOTE: Welds may break if parts are individually moved.

NOTE: This tool does not work in Roblox Studio.]];
G2L["16b"]["Name"] = [[ToolDescription]];
G2L["16b"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.WeldInfo.Content.ToolName
G2L["16c"] = Instance.new("TextLabel", G2L["169"]);
G2L["16c"]["BorderSizePixel"] = 0;
G2L["16c"]["TextSize"] = 10;
G2L["16c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["16c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["16c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16c"]["BackgroundTransparency"] = 1;
G2L["16c"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["16c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16c"]["Text"] = [[WELD TOOL]];
G2L["16c"]["Name"] = [[ToolName]];
G2L["16c"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.CollisionInfo
G2L["16d"] = Instance.new("Frame", G2L["13a"]);
G2L["16d"]["Visible"] = false;
G2L["16d"]["BorderSizePixel"] = 0;
G2L["16d"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["16d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["16d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16d"]["Name"] = [[CollisionInfo]];
G2L["16d"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.CollisionInfo.Content
G2L["16e"] = Instance.new("Frame", G2L["16d"]);
G2L["16e"]["BorderSizePixel"] = 0;
G2L["16e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16e"]["Size"] = UDim2.new(1, 0, 0, 150);
G2L["16e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16e"]["Name"] = [[Content]];
G2L["16e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.CollisionInfo.Content.ColorBar
G2L["16f"] = Instance.new("Frame", G2L["16e"]);
G2L["16f"]["BorderSizePixel"] = 0;
G2L["16f"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["16f"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["16f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["16f"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.CollisionInfo.Content.ToolDescription
G2L["170"] = Instance.new("TextLabel", G2L["16e"]);
G2L["170"]["TextWrapped"] = true;
G2L["170"]["BorderSizePixel"] = 0;
G2L["170"]["TextSize"] = 10;
G2L["170"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["170"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["170"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["170"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["170"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["170"]["BackgroundTransparency"] = 1;
G2L["170"]["Size"] = UDim2.new(0, 80, 0, 120);
G2L["170"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["170"]["Text"] = [[Lets you change whether parts collide with one another.

TIP: Press Enter to toggle collision quickly.]];
G2L["170"]["Name"] = [[ToolDescription]];
G2L["170"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.CollisionInfo.Content.ToolName
G2L["171"] = Instance.new("TextLabel", G2L["16e"]);
G2L["171"]["BorderSizePixel"] = 0;
G2L["171"]["TextSize"] = 10;
G2L["171"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["171"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["171"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["171"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["171"]["BackgroundTransparency"] = 1;
G2L["171"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["171"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["171"]["Text"] = [[COLLISION TOOL]];
G2L["171"]["Name"] = [[ToolName]];
G2L["171"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.[Component]
G2L["172"] = Instance.new("LocalScript", G2L["13a"]);
G2L["172"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo
G2L["173"] = Instance.new("Frame", G2L["13a"]);
G2L["173"]["Visible"] = false;
G2L["173"]["BorderSizePixel"] = 0;
G2L["173"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["173"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["173"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["173"]["Name"] = [[MoveInfo]];
G2L["173"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content
G2L["174"] = Instance.new("ScrollingFrame", G2L["173"]);
G2L["174"]["BorderSizePixel"] = 0;
G2L["174"]["CanvasSize"] = UDim2.new(0, 0, 0, 700);
G2L["174"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["174"]["Name"] = [[Content]];
G2L["174"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["174"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["174"]["ScrollBarThickness"] = 6;
G2L["174"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo
G2L["175"] = Instance.new("Frame", G2L["174"]);
G2L["175"]["BorderSizePixel"] = 0;
G2L["175"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["175"]["Size"] = UDim2.new(1, 0, 0, 300);
G2L["175"]["Position"] = UDim2.new(0, 0, 0, 60);
G2L["175"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["175"]["Name"] = [[AxesInfo]];
G2L["175"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo.Frame
G2L["176"] = Instance.new("Frame", G2L["175"]);
G2L["176"]["BorderSizePixel"] = 0;
G2L["176"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["176"]["Size"] = UDim2.new(0, 2, 0, 103);
G2L["176"]["Position"] = UDim2.new(0, 10, 0, 68);
G2L["176"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo.TextLabel
G2L["177"] = Instance.new("TextLabel", G2L["175"]);
G2L["177"]["TextWrapped"] = true;
G2L["177"]["BorderSizePixel"] = 0;
G2L["177"]["TextSize"] = 10;
G2L["177"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["177"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["177"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["177"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["177"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["177"]["BackgroundTransparency"] = 1;
G2L["177"]["Size"] = UDim2.new(0, 80, 0, 180);
G2L["177"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["177"]["Text"] = [[GLOBAL - Normal

LOCAL - Relative to each individual part

LAST - Relative to the last part selected]];
G2L["177"]["Position"] = UDim2.new(0, 17, 0, 68);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo.TextLabel
G2L["178"] = Instance.new("TextLabel", G2L["175"]);
G2L["178"]["TextWrapped"] = true;
G2L["178"]["BorderSizePixel"] = 0;
G2L["178"]["TextSize"] = 10;
G2L["178"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["178"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["178"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["178"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["178"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["178"]["BackgroundTransparency"] = 1;
G2L["178"]["Size"] = UDim2.new(0, 80, 0, 60);
G2L["178"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["178"]["Text"] = [[This option lets you choose in which direction to move each part.]];
G2L["178"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo.TextLabel
G2L["179"] = Instance.new("TextLabel", G2L["175"]);
G2L["179"]["TextWrapped"] = true;
G2L["179"]["BorderSizePixel"] = 0;
G2L["179"]["TextSize"] = 10;
G2L["179"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["179"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["179"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["179"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["179"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["179"]["BackgroundTransparency"] = 1;
G2L["179"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["179"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["179"]["Text"] = [[Axes]];
G2L["179"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.AxesInfo.TextLabel
G2L["17a"] = Instance.new("TextLabel", G2L["175"]);
G2L["17a"]["TextWrapped"] = true;
G2L["17a"]["BorderSizePixel"] = 0;
G2L["17a"]["TextSize"] = 10;
G2L["17a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17a"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["17a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17a"]["BackgroundTransparency"] = 1;
G2L["17a"]["Size"] = UDim2.new(0, 80, 0, 90);
G2L["17a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17a"]["Text"] = [[TIP: Click on any part to focus the handles on it.]];
G2L["17a"]["Position"] = UDim2.new(0, 10, 0, 180);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.ColorBar
G2L["17b"] = Instance.new("Frame", G2L["174"]);
G2L["17b"]["BorderSizePixel"] = 0;
G2L["17b"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["17b"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["17b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17b"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.IncrementInfo
G2L["17c"] = Instance.new("Frame", G2L["174"]);
G2L["17c"]["BorderSizePixel"] = 0;
G2L["17c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17c"]["Size"] = UDim2.new(1, 0, 0, 300);
G2L["17c"]["Position"] = UDim2.new(0, 0, 0, 285);
G2L["17c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17c"]["Name"] = [[IncrementInfo]];
G2L["17c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.IncrementInfo.TextLabel
G2L["17d"] = Instance.new("TextLabel", G2L["17c"]);
G2L["17d"]["TextWrapped"] = true;
G2L["17d"]["BorderSizePixel"] = 0;
G2L["17d"]["TextSize"] = 10;
G2L["17d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["17d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17d"]["BackgroundTransparency"] = 1;
G2L["17d"]["Size"] = UDim2.new(0, 90, 0, 400);
G2L["17d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17d"]["Text"] = [[Lets you choose how many studs to move parts by.

TIP: Press T while dragging to align the bottom surface of your base part to the current target surface.

TIP: You can place parts perfectly together by holding the R key, and dragging parts by their snap points.

TIP: Use your right-side number keypad to move exactly by the current increment
  8/2 = up/down
  1/9 = back/forth
  4/6 = left/right
(Shift = reverses increment)

TIP: Hit the Enter key to switch between Axes modes quickly.

TIP: Hit the - key to quickly type increments.]];
G2L["17d"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.IncrementInfo.TextLabel
G2L["17e"] = Instance.new("TextLabel", G2L["17c"]);
G2L["17e"]["TextWrapped"] = true;
G2L["17e"]["BorderSizePixel"] = 0;
G2L["17e"]["TextSize"] = 10;
G2L["17e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17e"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["17e"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["17e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["17e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17e"]["BackgroundTransparency"] = 1;
G2L["17e"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["17e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17e"]["Text"] = [[Increment]];
G2L["17e"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.ToolDescription
G2L["17f"] = Instance.new("TextLabel", G2L["174"]);
G2L["17f"]["TextWrapped"] = true;
G2L["17f"]["BorderSizePixel"] = 0;
G2L["17f"]["TextSize"] = 10;
G2L["17f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["17f"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["17f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17f"]["BackgroundTransparency"] = 1;
G2L["17f"]["Size"] = UDim2.new(0, 80, 0, 50);
G2L["17f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["17f"]["Text"] = [[Allows you to move parts.]];
G2L["17f"]["Name"] = [[ToolDescription]];
G2L["17f"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.MoveInfo.Content.ToolName
G2L["180"] = Instance.new("TextLabel", G2L["174"]);
G2L["180"]["BorderSizePixel"] = 0;
G2L["180"]["TextSize"] = 10;
G2L["180"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["180"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["180"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["180"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["180"]["BackgroundTransparency"] = 1;
G2L["180"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["180"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["180"]["Text"] = [[MOVE TOOL]];
G2L["180"]["Name"] = [[ToolName]];
G2L["180"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo
G2L["181"] = Instance.new("Frame", G2L["13a"]);
G2L["181"]["Visible"] = false;
G2L["181"]["BorderSizePixel"] = 0;
G2L["181"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["181"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["181"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["181"]["Name"] = [[RotateInfo]];
G2L["181"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content
G2L["182"] = Instance.new("ScrollingFrame", G2L["181"]);
G2L["182"]["BorderSizePixel"] = 0;
G2L["182"]["CanvasSize"] = UDim2.new(0, 0, 0, 630);
G2L["182"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["182"]["Name"] = [[Content]];
G2L["182"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["182"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["182"]["ScrollBarThickness"] = 6;
G2L["182"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.ColorBar
G2L["183"] = Instance.new("Frame", G2L["182"]);
G2L["183"]["BorderSizePixel"] = 0;
G2L["183"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["183"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["183"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["183"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.IncrementInfo
G2L["184"] = Instance.new("Frame", G2L["182"]);
G2L["184"]["BorderSizePixel"] = 0;
G2L["184"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["184"]["Size"] = UDim2.new(1, 0, 0, 130);
G2L["184"]["Position"] = UDim2.new(0, 0, 0, 310);
G2L["184"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["184"]["Name"] = [[IncrementInfo]];
G2L["184"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.IncrementInfo.TextLabel
G2L["185"] = Instance.new("TextLabel", G2L["184"]);
G2L["185"]["TextWrapped"] = true;
G2L["185"]["BorderSizePixel"] = 0;
G2L["185"]["TextSize"] = 10;
G2L["185"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["185"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["185"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["185"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["185"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["185"]["BackgroundTransparency"] = 1;
G2L["185"]["Size"] = UDim2.new(0, 94, 0, 400);
G2L["185"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["185"]["Text"] = [[Lets you choose how many degrees to rotate by.

TIP: Press R and click on a snap point to rotate around it.

TIP: Hit the Enter key to switch between Pivot modes quickly.

TIP: Hit the - key to quickly type increments.

TIP: Use your right-side number keypad to rotate exactly by the current increment:
 4/6 = Y axis (green)
 1/9 = Z axis (blue)
 2/8 = X axis (red)
(Shift = reverses increment)]];
G2L["185"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.IncrementInfo.TextLabel
G2L["186"] = Instance.new("TextLabel", G2L["184"]);
G2L["186"]["TextWrapped"] = true;
G2L["186"]["BorderSizePixel"] = 0;
G2L["186"]["TextSize"] = 10;
G2L["186"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["186"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["186"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["186"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["186"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["186"]["BackgroundTransparency"] = 1;
G2L["186"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["186"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["186"]["Text"] = [[Increment]];
G2L["186"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo
G2L["187"] = Instance.new("Frame", G2L["182"]);
G2L["187"]["BorderSizePixel"] = 0;
G2L["187"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["187"]["Size"] = UDim2.new(1, 0, 0, 300);
G2L["187"]["Position"] = UDim2.new(0, 0, 0, 60);
G2L["187"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["187"]["Name"] = [[PivotInfo]];
G2L["187"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo.Frame
G2L["188"] = Instance.new("Frame", G2L["187"]);
G2L["188"]["BorderSizePixel"] = 0;
G2L["188"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["188"]["Size"] = UDim2.new(0, 2, 0, 132);
G2L["188"]["Position"] = UDim2.new(0, 10, 0, 67);
G2L["188"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo.TextLabel
G2L["189"] = Instance.new("TextLabel", G2L["187"]);
G2L["189"]["TextWrapped"] = true;
G2L["189"]["BorderSizePixel"] = 0;
G2L["189"]["TextSize"] = 10;
G2L["189"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["189"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["189"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["189"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["189"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["189"]["BackgroundTransparency"] = 1;
G2L["189"]["Size"] = UDim2.new(0, 80, 0, 180);
G2L["189"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["189"]["Text"] = [[CENTER - Around the center of the selection

LOCAL - Each part around its own center

LAST - Each part around the center of the last part selected]];
G2L["189"]["Position"] = UDim2.new(0, 17, 0, 67);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo.TextLabel
G2L["18a"] = Instance.new("TextLabel", G2L["187"]);
G2L["18a"]["TextWrapped"] = true;
G2L["18a"]["BorderSizePixel"] = 0;
G2L["18a"]["TextSize"] = 10;
G2L["18a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["18a"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["18a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18a"]["BackgroundTransparency"] = 1;
G2L["18a"]["Size"] = UDim2.new(0, 80, 0, 60);
G2L["18a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18a"]["Text"] = [[This option lets you choose what to rotate the parts around.]];
G2L["18a"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo.TextLabel
G2L["18b"] = Instance.new("TextLabel", G2L["187"]);
G2L["18b"]["TextWrapped"] = true;
G2L["18b"]["BorderSizePixel"] = 0;
G2L["18b"]["TextSize"] = 10;
G2L["18b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["18b"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["18b"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["18b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["18b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18b"]["BackgroundTransparency"] = 1;
G2L["18b"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["18b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18b"]["Text"] = [[Pivot]];
G2L["18b"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.PivotInfo.TextLabel
G2L["18c"] = Instance.new("TextLabel", G2L["187"]);
G2L["18c"]["TextWrapped"] = true;
G2L["18c"]["BorderSizePixel"] = 0;
G2L["18c"]["TextSize"] = 10;
G2L["18c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["18c"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["18c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18c"]["BackgroundTransparency"] = 1;
G2L["18c"]["Size"] = UDim2.new(0, 80, 0, 90);
G2L["18c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18c"]["Text"] = [[TIP: Click on any part to focus the handles on it.]];
G2L["18c"]["Position"] = UDim2.new(0, 10, 0, 208);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.ToolDescription
G2L["18d"] = Instance.new("TextLabel", G2L["182"]);
G2L["18d"]["TextWrapped"] = true;
G2L["18d"]["BorderSizePixel"] = 0;
G2L["18d"]["TextSize"] = 10;
G2L["18d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["18d"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["18d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18d"]["BackgroundTransparency"] = 1;
G2L["18d"]["Size"] = UDim2.new(0, 80, 0, 50);
G2L["18d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18d"]["Text"] = [[Allows you to rotate parts.]];
G2L["18d"]["Name"] = [[ToolDescription]];
G2L["18d"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.RotateInfo.Content.ToolName
G2L["18e"] = Instance.new("TextLabel", G2L["182"]);
G2L["18e"]["BorderSizePixel"] = 0;
G2L["18e"]["TextSize"] = 10;
G2L["18e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["18e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["18e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18e"]["BackgroundTransparency"] = 1;
G2L["18e"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["18e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18e"]["Text"] = [[ROTATE TOOL]];
G2L["18e"]["Name"] = [[ToolName]];
G2L["18e"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo
G2L["18f"] = Instance.new("Frame", G2L["13a"]);
G2L["18f"]["Visible"] = false;
G2L["18f"]["BorderSizePixel"] = 0;
G2L["18f"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["18f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["18f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["18f"]["Name"] = [[ResizeInfo]];
G2L["18f"]["BackgroundTransparency"] = 0.2;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content
G2L["190"] = Instance.new("ScrollingFrame", G2L["18f"]);
G2L["190"]["BorderSizePixel"] = 0;
G2L["190"]["CanvasSize"] = UDim2.new(0, 0, 0, 540);
G2L["190"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["190"]["Name"] = [[Content]];
G2L["190"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["190"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["190"]["ScrollBarThickness"] = 6;
G2L["190"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.ColorBar
G2L["191"] = Instance.new("Frame", G2L["190"]);
G2L["191"]["BorderSizePixel"] = 0;
G2L["191"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["191"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["191"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["191"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.DirectionsInfo
G2L["192"] = Instance.new("Frame", G2L["190"]);
G2L["192"]["BorderSizePixel"] = 0;
G2L["192"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["192"]["Size"] = UDim2.new(1, 0, 0, 300);
G2L["192"]["Position"] = UDim2.new(0, 0, 0, 60);
G2L["192"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["192"]["Name"] = [[DirectionsInfo]];
G2L["192"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.DirectionsInfo.TextLabel
G2L["193"] = Instance.new("TextLabel", G2L["192"]);
G2L["193"]["TextWrapped"] = true;
G2L["193"]["BorderSizePixel"] = 0;
G2L["193"]["TextSize"] = 10;
G2L["193"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["193"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["193"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["193"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["193"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["193"]["BackgroundTransparency"] = 1;
G2L["193"]["Size"] = UDim2.new(0, 80, 0, 120);
G2L["193"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["193"]["Text"] = [[Lets you choose in which directions to resize the part.

TIP: Click on a part to focus the handles on it.]];
G2L["193"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.DirectionsInfo.TextLabel
G2L["194"] = Instance.new("TextLabel", G2L["192"]);
G2L["194"]["TextWrapped"] = true;
G2L["194"]["BorderSizePixel"] = 0;
G2L["194"]["TextSize"] = 10;
G2L["194"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["194"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["194"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["194"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["194"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["194"]["BackgroundTransparency"] = 1;
G2L["194"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["194"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["194"]["Text"] = [[Directions]];
G2L["194"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.IncrementInfo
G2L["195"] = Instance.new("Frame", G2L["190"]);
G2L["195"]["BorderSizePixel"] = 0;
G2L["195"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["195"]["Size"] = UDim2.new(1, 0, 0, 135);
G2L["195"]["Position"] = UDim2.new(0, 0, 0, 165);
G2L["195"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["195"]["Name"] = [[IncrementInfo]];
G2L["195"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.IncrementInfo.TextLabel
G2L["196"] = Instance.new("TextLabel", G2L["195"]);
G2L["196"]["TextWrapped"] = true;
G2L["196"]["BorderSizePixel"] = 0;
G2L["196"]["TextSize"] = 10;
G2L["196"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["196"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["196"]["BackgroundColor3"] = Color3.fromRGB(62, 62, 62);
G2L["196"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["196"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["196"]["BackgroundTransparency"] = 1;
G2L["196"]["Size"] = UDim2.new(0, 80, 0, 12);
G2L["196"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["196"]["Text"] = [[Increment]];
G2L["196"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.IncrementInfo.TextLabel
G2L["197"] = Instance.new("TextLabel", G2L["195"]);
G2L["197"]["TextWrapped"] = true;
G2L["197"]["BorderSizePixel"] = 0;
G2L["197"]["TextSize"] = 10;
G2L["197"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["197"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["197"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["197"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["197"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["197"]["BackgroundTransparency"] = 1;
G2L["197"]["Size"] = UDim2.new(0, 82, 0, 400);
G2L["197"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["197"]["Text"] = [[Lets you choose how many studs to resize by.

TIP: Hit the - key to quickly type increments.

TIP: Hit Enter to switch between directions quickly.

TIP: Use your right-side number keypad to resize exactly by the current increment
  8/2 = up/down
  1/9 = back/forth
  4/6 = left/right
(Shift = reverses increment)

TIP: Hold the R key, and click and drag the snap point of a part (in the direction that you want to resize) towards the snap point of another part, to resize up to that point.]];
G2L["197"]["Position"] = UDim2.new(0, 10, 0, 15);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.ToolDescription
G2L["198"] = Instance.new("TextLabel", G2L["190"]);
G2L["198"]["TextWrapped"] = true;
G2L["198"]["BorderSizePixel"] = 0;
G2L["198"]["TextSize"] = 10;
G2L["198"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["198"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["198"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["198"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["198"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["198"]["BackgroundTransparency"] = 1;
G2L["198"]["Size"] = UDim2.new(0, 80, 0, 50);
G2L["198"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["198"]["Text"] = [[Allows you to resize parts.]];
G2L["198"]["Name"] = [[ToolDescription]];
G2L["198"]["Position"] = UDim2.new(0, 10, 0, 25);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.ResizeInfo.Content.ToolName
G2L["199"] = Instance.new("TextLabel", G2L["190"]);
G2L["199"]["BorderSizePixel"] = 0;
G2L["199"]["TextSize"] = 10;
G2L["199"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["199"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["199"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["199"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["199"]["BackgroundTransparency"] = 1;
G2L["199"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["199"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["199"]["Text"] = [[RESIZE TOOL]];
G2L["199"]["Name"] = [[ToolName]];
G2L["199"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI
G2L["19a"] = Instance.new("Frame", G2L["52"]);
G2L["19a"]["Active"] = true;
G2L["19a"]["BorderSizePixel"] = 0;
G2L["19a"]["Size"] = UDim2.new(0, 220, 0, 125);
G2L["19a"]["Position"] = UDim2.new(0, 0, 0.4, 0);
G2L["19a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["19a"]["Name"] = [[BTLightingToolGUI]];
G2L["19a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight
G2L["19b"] = Instance.new("Frame", G2L["19a"]);
G2L["19b"]["BorderSizePixel"] = 0;
G2L["19b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19b"]["ClipsDescendants"] = true;
G2L["19b"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["19b"]["Position"] = UDim2.new(0, 10, 0, 60);
G2L["19b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["19b"]["Name"] = [[PointLight]];
G2L["19b"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Shadow
G2L["19c"] = Instance.new("Frame", G2L["19b"]);
G2L["19c"]["BorderSizePixel"] = 0;
G2L["19c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19c"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["19c"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["19c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["19c"]["Name"] = [[Shadow]];
G2L["19c"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.RemoveButton
G2L["19d"] = Instance.new("TextButton", G2L["19b"]);
G2L["19d"]["BorderSizePixel"] = 0;
G2L["19d"]["TextSize"] = 10;
G2L["19d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["19d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["19d"]["BackgroundTransparency"] = 0.75;
G2L["19d"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["19d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19d"]["Text"] = [[REMOVE]];
G2L["19d"]["Name"] = [[RemoveButton]];
G2L["19d"]["Visible"] = false;
G2L["19d"]["Position"] = UDim2.new(0, 90, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.AddButton
G2L["19e"] = Instance.new("TextButton", G2L["19b"]);
G2L["19e"]["BorderSizePixel"] = 0;
G2L["19e"]["TextSize"] = 10;
G2L["19e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["19e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["19e"]["BackgroundTransparency"] = 0.75;
G2L["19e"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["19e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19e"]["Text"] = [[ADD]];
G2L["19e"]["Name"] = [[AddButton]];
G2L["19e"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.ColorBar
G2L["19f"] = Instance.new("Frame", G2L["19b"]);
G2L["19f"]["BorderSizePixel"] = 0;
G2L["19f"]["BackgroundColor3"] = Color3.fromRGB(218, 0, 255);
G2L["19f"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["19f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["19f"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.ArrowButton
G2L["1a0"] = Instance.new("ImageButton", G2L["19b"]);
G2L["1a0"]["BorderSizePixel"] = 0;
G2L["1a0"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1a0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a0"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["1a0"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["1a0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a0"]["Name"] = [[ArrowButton]];
G2L["1a0"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Label
G2L["1a1"] = Instance.new("TextLabel", G2L["19b"]);
G2L["1a1"]["TextWrapped"] = true;
G2L["1a1"]["TextStrokeTransparency"] = 0.5;
G2L["1a1"]["BorderSizePixel"] = 0;
G2L["1a1"]["TextSize"] = 10;
G2L["1a1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1a1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1a1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a1"]["BackgroundTransparency"] = 1;
G2L["1a1"]["Size"] = UDim2.new(0, 60, 0, 25);
G2L["1a1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a1"]["Text"] = [[Point light]];
G2L["1a1"]["Name"] = [[Label]];
G2L["1a1"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options
G2L["1a2"] = Instance.new("Frame", G2L["19b"]);
G2L["1a2"]["BorderSizePixel"] = 0;
G2L["1a2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a2"]["ClipsDescendants"] = true;
G2L["1a2"]["Size"] = UDim2.new(1, -3, 0, 71);
G2L["1a2"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["1a2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a2"]["Name"] = [[Options]];
G2L["1a2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ShadowsOption
G2L["1a3"] = Instance.new("Frame", G2L["1a2"]);
G2L["1a3"]["BorderSizePixel"] = 0;
G2L["1a3"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1a3"]["Position"] = UDim2.new(0, 120, 0, 45);
G2L["1a3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a3"]["Name"] = [[ShadowsOption]];
G2L["1a3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ShadowsOption.Label
G2L["1a4"] = Instance.new("TextLabel", G2L["1a3"]);
G2L["1a4"]["TextWrapped"] = true;
G2L["1a4"]["TextStrokeTransparency"] = 0;
G2L["1a4"]["BorderSizePixel"] = 0;
G2L["1a4"]["TextSize"] = 10;
G2L["1a4"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1a4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1a4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a4"]["BackgroundTransparency"] = 1;
G2L["1a4"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["1a4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a4"]["Text"] = [[Shadows]];
G2L["1a4"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ShadowsOption.Checkbox
G2L["1a5"] = Instance.new("ImageButton", G2L["1a3"]);
G2L["1a5"]["BorderSizePixel"] = 0;
G2L["1a5"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1a5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a5"]["ImageColor3"] = Color3.fromRGB(242, 242, 242);
G2L["1a5"]["Image"] = [[rbxassetid://401518903]];
G2L["1a5"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["1a5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a5"]["Name"] = [[Checkbox]];
G2L["1a5"]["Position"] = UDim2.new(0, 55, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption
G2L["1a6"] = Instance.new("Frame", G2L["1a2"]);
G2L["1a6"]["BorderSizePixel"] = 0;
G2L["1a6"]["Size"] = UDim2.new(0, 80, 0, 25);
G2L["1a6"]["Position"] = UDim2.new(0, 105, 0, 10);
G2L["1a6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a6"]["Name"] = [[RangeOption]];
G2L["1a6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption.Input
G2L["1a7"] = Instance.new("Frame", G2L["1a6"]);
G2L["1a7"]["BorderSizePixel"] = 0;
G2L["1a7"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["1a7"]["Position"] = UDim2.new(0, 40, 0, 0);
G2L["1a7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a7"]["Name"] = [[Input]];
G2L["1a7"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption.Input.TextBox
G2L["1a8"] = Instance.new("TextBox", G2L["1a7"]);
G2L["1a8"]["ZIndex"] = 2;
G2L["1a8"]["BorderSizePixel"] = 0;
G2L["1a8"]["TextSize"] = 10;
G2L["1a8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1a8"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1a8"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["1a8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a8"]["Text"] = [[16]];
G2L["1a8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption.Input.Background
G2L["1a9"] = Instance.new("ImageLabel", G2L["1a7"]);
G2L["1a9"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1a9"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["1a9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1a9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1a9"]["BackgroundTransparency"] = 1;
G2L["1a9"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption.Input.SelectedIndicator
G2L["1aa"] = Instance.new("Frame", G2L["1a7"]);
G2L["1aa"]["BorderSizePixel"] = 0;
G2L["1aa"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1aa"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["1aa"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["1aa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1aa"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.RangeOption.Label
G2L["1ab"] = Instance.new("TextLabel", G2L["1a6"]);
G2L["1ab"]["TextWrapped"] = true;
G2L["1ab"]["TextStrokeTransparency"] = 0;
G2L["1ab"]["BorderSizePixel"] = 0;
G2L["1ab"]["TextSize"] = 10;
G2L["1ab"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1ab"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1ab"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ab"]["BackgroundTransparency"] = 1;
G2L["1ab"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1ab"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ab"]["Text"] = [[Range]];
G2L["1ab"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption
G2L["1ac"] = Instance.new("Frame", G2L["1a2"]);
G2L["1ac"]["BorderSizePixel"] = 0;
G2L["1ac"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1ac"]["Position"] = UDim2.new(0, 0, 0, 45);
G2L["1ac"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ac"]["Name"] = [[BrightnessOption]];
G2L["1ac"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption.Input
G2L["1ad"] = Instance.new("Frame", G2L["1ac"]);
G2L["1ad"]["BorderSizePixel"] = 0;
G2L["1ad"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["1ad"]["Position"] = UDim2.new(0, 60, 0, 0);
G2L["1ad"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ad"]["Name"] = [[Input]];
G2L["1ad"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption.Input.TextBox
G2L["1ae"] = Instance.new("TextBox", G2L["1ad"]);
G2L["1ae"]["ZIndex"] = 2;
G2L["1ae"]["BorderSizePixel"] = 0;
G2L["1ae"]["TextSize"] = 10;
G2L["1ae"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ae"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1ae"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1ae"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["1ae"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ae"]["Text"] = [[1]];
G2L["1ae"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption.Input.Background
G2L["1af"] = Instance.new("ImageLabel", G2L["1ad"]);
G2L["1af"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1af"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["1af"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1af"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1af"]["BackgroundTransparency"] = 1;
G2L["1af"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption.Input.SelectedIndicator
G2L["1b0"] = Instance.new("Frame", G2L["1ad"]);
G2L["1b0"]["BorderSizePixel"] = 0;
G2L["1b0"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b0"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["1b0"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["1b0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b0"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.BrightnessOption.Label
G2L["1b1"] = Instance.new("TextLabel", G2L["1ac"]);
G2L["1b1"]["TextWrapped"] = true;
G2L["1b1"]["TextStrokeTransparency"] = 0;
G2L["1b1"]["BorderSizePixel"] = 0;
G2L["1b1"]["TextSize"] = 10;
G2L["1b1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1b1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1b1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b1"]["BackgroundTransparency"] = 1;
G2L["1b1"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1b1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b1"]["Text"] = [[Brightness]];
G2L["1b1"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption
G2L["1b2"] = Instance.new("Frame", G2L["1a2"]);
G2L["1b2"]["BorderSizePixel"] = 0;
G2L["1b2"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1b2"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["1b2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b2"]["Name"] = [[ColorOption]];
G2L["1b2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.HSVPicker
G2L["1b3"] = Instance.new("ImageButton", G2L["1b2"]);
G2L["1b3"]["BorderSizePixel"] = 0;
G2L["1b3"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1b3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b3"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["1b3"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["1b3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b3"]["Name"] = [[HSVPicker]];
G2L["1b3"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.HSVPicker.Shadow
G2L["1b4"] = Instance.new("Frame", G2L["1b3"]);
G2L["1b4"]["BorderSizePixel"] = 0;
G2L["1b4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b4"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["1b4"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["1b4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b4"]["Name"] = [[Shadow]];
G2L["1b4"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.Label
G2L["1b5"] = Instance.new("TextLabel", G2L["1b2"]);
G2L["1b5"]["TextWrapped"] = true;
G2L["1b5"]["TextStrokeTransparency"] = 0;
G2L["1b5"]["BorderSizePixel"] = 0;
G2L["1b5"]["TextSize"] = 10;
G2L["1b5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1b5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b5"]["BackgroundTransparency"] = 1;
G2L["1b5"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1b5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b5"]["Text"] = [[Color]];
G2L["1b5"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.Indicator
G2L["1b6"] = Instance.new("Frame", G2L["1b2"]);
G2L["1b6"]["BorderSizePixel"] = 0;
G2L["1b6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b6"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["1b6"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["1b6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b6"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.Indicator.Shadow
G2L["1b7"] = Instance.new("Frame", G2L["1b6"]);
G2L["1b7"]["BorderSizePixel"] = 0;
G2L["1b7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b7"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["1b7"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["1b7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b7"]["Name"] = [[Shadow]];
G2L["1b7"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.PointLight.Options.ColorOption.Indicator.Varies
G2L["1b8"] = Instance.new("TextLabel", G2L["1b6"]);
G2L["1b8"]["TextWrapped"] = true;
G2L["1b8"]["TextStrokeTransparency"] = 0.75;
G2L["1b8"]["BorderSizePixel"] = 0;
G2L["1b8"]["TextSize"] = 14;
G2L["1b8"]["TextScaled"] = true;
G2L["1b8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1b8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b8"]["BackgroundTransparency"] = 1;
G2L["1b8"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1b8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b8"]["Text"] = [[]];
G2L["1b8"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SelectNote
G2L["1b9"] = Instance.new("TextLabel", G2L["19a"]);
G2L["1b9"]["TextWrapped"] = true;
G2L["1b9"]["TextStrokeTransparency"] = 0.5;
G2L["1b9"]["BorderSizePixel"] = 0;
G2L["1b9"]["TextSize"] = 14;
G2L["1b9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1b9"]["TextScaled"] = true;
G2L["1b9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1b9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b9"]["BackgroundTransparency"] = 1;
G2L["1b9"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["1b9"]["Visible"] = false;
G2L["1b9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1b9"]["Text"] = [[Select something to use this tool.]];
G2L["1b9"]["Name"] = [[SelectNote]];
G2L["1b9"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight
G2L["1ba"] = Instance.new("Frame", G2L["19a"]);
G2L["1ba"]["BorderSizePixel"] = 0;
G2L["1ba"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ba"]["ClipsDescendants"] = true;
G2L["1ba"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["1ba"]["Position"] = UDim2.new(0, 10, 0, 30);
G2L["1ba"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ba"]["Name"] = [[SpotLight]];
G2L["1ba"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options
G2L["1bb"] = Instance.new("Frame", G2L["1ba"]);
G2L["1bb"]["BorderSizePixel"] = 0;
G2L["1bb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1bb"]["ClipsDescendants"] = true;
G2L["1bb"]["Size"] = UDim2.new(1, -3, 0, 105);
G2L["1bb"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["1bb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1bb"]["Name"] = [[Options]];
G2L["1bb"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ShadowsOption
G2L["1bc"] = Instance.new("Frame", G2L["1bb"]);
G2L["1bc"]["BorderSizePixel"] = 0;
G2L["1bc"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1bc"]["Position"] = UDim2.new(0, 120, 0, 80);
G2L["1bc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1bc"]["Name"] = [[ShadowsOption]];
G2L["1bc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ShadowsOption.Label
G2L["1bd"] = Instance.new("TextLabel", G2L["1bc"]);
G2L["1bd"]["TextWrapped"] = true;
G2L["1bd"]["TextStrokeTransparency"] = 0;
G2L["1bd"]["BorderSizePixel"] = 0;
G2L["1bd"]["TextSize"] = 10;
G2L["1bd"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1bd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1bd"]["BackgroundTransparency"] = 1;
G2L["1bd"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["1bd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1bd"]["Text"] = [[Shadows]];
G2L["1bd"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ShadowsOption.Checkbox
G2L["1be"] = Instance.new("ImageButton", G2L["1bc"]);
G2L["1be"]["BorderSizePixel"] = 0;
G2L["1be"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1be"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1be"]["ImageColor3"] = Color3.fromRGB(242, 242, 242);
G2L["1be"]["Image"] = [[rbxassetid://401518903]];
G2L["1be"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["1be"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1be"]["Name"] = [[Checkbox]];
G2L["1be"]["Position"] = UDim2.new(0, 55, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption
G2L["1bf"] = Instance.new("Frame", G2L["1bb"]);
G2L["1bf"]["BorderSizePixel"] = 0;
G2L["1bf"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1bf"]["Position"] = UDim2.new(0, 0, 0, 80);
G2L["1bf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1bf"]["Name"] = [[SideOption]];
G2L["1bf"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Label
G2L["1c0"] = Instance.new("TextLabel", G2L["1bf"]);
G2L["1c0"]["TextWrapped"] = true;
G2L["1c0"]["TextStrokeTransparency"] = 0;
G2L["1c0"]["BorderSizePixel"] = 0;
G2L["1c0"]["TextSize"] = 10;
G2L["1c0"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1c0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1c0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c0"]["BackgroundTransparency"] = 1;
G2L["1c0"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1c0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c0"]["Text"] = [[Side]];
G2L["1c0"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown
G2L["1c1"] = Instance.new("TextButton", G2L["1bf"]);
G2L["1c1"]["TextStrokeTransparency"] = 0.8;
G2L["1c1"]["BorderSizePixel"] = 0;
G2L["1c1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1c1"]["TextSize"] = 10;
G2L["1c1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1c1"]["BackgroundTransparency"] = 0.3;
G2L["1c1"]["Size"] = UDim2.new(0, 72, 0, 25);
G2L["1c1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c1"]["Text"] = [[]];
G2L["1c1"]["Name"] = [[Dropdown]];
G2L["1c1"]["Position"] = UDim2.new(0, 30, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.Icon
G2L["1c2"] = Instance.new("ImageLabel", G2L["1c1"]);
G2L["1c2"]["ZIndex"] = 3;
G2L["1c2"]["BorderSizePixel"] = 0;
G2L["1c2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1c2"]["Image"] = [[rbxassetid://134367382]];
G2L["1c2"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["1c2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c2"]["BackgroundTransparency"] = 1;
G2L["1c2"]["Name"] = [[Icon]];
G2L["1c2"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.OptionButton
G2L["1c3"] = Instance.new("TextButton", G2L["1c1"]);
G2L["1c3"]["TextStrokeTransparency"] = 0.8;
G2L["1c3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1c3"]["TextSize"] = 10;
G2L["1c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1c3"]["ZIndex"] = 4;
G2L["1c3"]["BackgroundTransparency"] = 0.3;
G2L["1c3"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["1c3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c3"]["Text"] = [[]];
G2L["1c3"]["Name"] = [[OptionButton]];
G2L["1c3"]["Visible"] = false;
G2L["1c3"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.OptionButton.OptionLabel
G2L["1c4"] = Instance.new("TextLabel", G2L["1c3"]);
G2L["1c4"]["ZIndex"] = 4;
G2L["1c4"]["BorderSizePixel"] = 0;
G2L["1c4"]["TextSize"] = 10;
G2L["1c4"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1c4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1c4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c4"]["BackgroundTransparency"] = 1;
G2L["1c4"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["1c4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c4"]["Text"] = [[ALL]];
G2L["1c4"]["Name"] = [[OptionLabel]];
G2L["1c4"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.Options
G2L["1c5"] = Instance.new("Folder", G2L["1c1"]);
G2L["1c5"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.Border
G2L["1c6"] = Instance.new("Frame", G2L["1c1"]);
G2L["1c6"]["BorderSizePixel"] = 0;
G2L["1c6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c6"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["1c6"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["1c6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c6"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.CurrentOption
G2L["1c7"] = Instance.new("TextLabel", G2L["1c1"]);
G2L["1c7"]["ZIndex"] = 3;
G2L["1c7"]["BorderSizePixel"] = 0;
G2L["1c7"]["TextSize"] = 10;
G2L["1c7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1c7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c7"]["BackgroundTransparency"] = 1;
G2L["1c7"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["1c7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c7"]["Text"] = [[]];
G2L["1c7"]["Name"] = [[CurrentOption]];
G2L["1c7"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.[Component]
G2L["1c8"] = Instance.new("LocalScript", G2L["1c1"]);
G2L["1c8"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption
G2L["1c9"] = Instance.new("Frame", G2L["1bb"]);
G2L["1c9"]["BorderSizePixel"] = 0;
G2L["1c9"]["Size"] = UDim2.new(0, 80, 0, 25);
G2L["1c9"]["Position"] = UDim2.new(0, 110, 0, 10);
G2L["1c9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1c9"]["Name"] = [[RangeOption]];
G2L["1c9"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption.Input
G2L["1ca"] = Instance.new("Frame", G2L["1c9"]);
G2L["1ca"]["BorderSizePixel"] = 0;
G2L["1ca"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["1ca"]["Position"] = UDim2.new(0, 40, 0, 0);
G2L["1ca"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ca"]["Name"] = [[Input]];
G2L["1ca"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption.Input.TextBox
G2L["1cb"] = Instance.new("TextBox", G2L["1ca"]);
G2L["1cb"]["ZIndex"] = 2;
G2L["1cb"]["BorderSizePixel"] = 0;
G2L["1cb"]["TextSize"] = 10;
G2L["1cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1cb"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1cb"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["1cb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1cb"]["Text"] = [[16]];
G2L["1cb"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption.Input.Background
G2L["1cc"] = Instance.new("ImageLabel", G2L["1ca"]);
G2L["1cc"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1cc"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["1cc"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1cc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1cc"]["BackgroundTransparency"] = 1;
G2L["1cc"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption.Input.SelectedIndicator
G2L["1cd"] = Instance.new("Frame", G2L["1ca"]);
G2L["1cd"]["BorderSizePixel"] = 0;
G2L["1cd"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1cd"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["1cd"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["1cd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1cd"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.RangeOption.Label
G2L["1ce"] = Instance.new("TextLabel", G2L["1c9"]);
G2L["1ce"]["TextWrapped"] = true;
G2L["1ce"]["TextStrokeTransparency"] = 0;
G2L["1ce"]["BorderSizePixel"] = 0;
G2L["1ce"]["TextSize"] = 10;
G2L["1ce"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1ce"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1ce"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ce"]["BackgroundTransparency"] = 1;
G2L["1ce"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1ce"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ce"]["Text"] = [[Range]];
G2L["1ce"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption
G2L["1cf"] = Instance.new("Frame", G2L["1bb"]);
G2L["1cf"]["BorderSizePixel"] = 0;
G2L["1cf"]["Size"] = UDim2.new(1, -115, 0, 25);
G2L["1cf"]["Position"] = UDim2.new(0, 120, 0, 46);
G2L["1cf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1cf"]["Name"] = [[AngleOption]];
G2L["1cf"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption.Input
G2L["1d0"] = Instance.new("Frame", G2L["1cf"]);
G2L["1d0"]["BorderSizePixel"] = 0;
G2L["1d0"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["1d0"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["1d0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d0"]["Name"] = [[Input]];
G2L["1d0"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption.Input.TextBox
G2L["1d1"] = Instance.new("TextBox", G2L["1d0"]);
G2L["1d1"]["ZIndex"] = 2;
G2L["1d1"]["BorderSizePixel"] = 0;
G2L["1d1"]["TextSize"] = 10;
G2L["1d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1d1"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1d1"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["1d1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d1"]["Text"] = [[90]];
G2L["1d1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption.Input.SelectedIndicator
G2L["1d2"] = Instance.new("Frame", G2L["1d0"]);
G2L["1d2"]["BorderSizePixel"] = 0;
G2L["1d2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d2"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["1d2"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["1d2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d2"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption.Input.Background
G2L["1d3"] = Instance.new("ImageLabel", G2L["1d0"]);
G2L["1d3"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1d3"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["1d3"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1d3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d3"]["BackgroundTransparency"] = 1;
G2L["1d3"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.AngleOption.Label
G2L["1d4"] = Instance.new("TextLabel", G2L["1cf"]);
G2L["1d4"]["TextWrapped"] = true;
G2L["1d4"]["TextStrokeTransparency"] = 0;
G2L["1d4"]["BorderSizePixel"] = 0;
G2L["1d4"]["TextSize"] = 10;
G2L["1d4"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d4"]["BackgroundTransparency"] = 1;
G2L["1d4"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1d4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d4"]["Text"] = [[Angle]];
G2L["1d4"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption
G2L["1d5"] = Instance.new("Frame", G2L["1bb"]);
G2L["1d5"]["BorderSizePixel"] = 0;
G2L["1d5"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1d5"]["Position"] = UDim2.new(0, 0, 0, 45);
G2L["1d5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d5"]["Name"] = [[BrightnessOption]];
G2L["1d5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption.Input
G2L["1d6"] = Instance.new("Frame", G2L["1d5"]);
G2L["1d6"]["BorderSizePixel"] = 0;
G2L["1d6"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["1d6"]["Position"] = UDim2.new(0, 60, 0, 0);
G2L["1d6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d6"]["Name"] = [[Input]];
G2L["1d6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption.Input.TextBox
G2L["1d7"] = Instance.new("TextBox", G2L["1d6"]);
G2L["1d7"]["ZIndex"] = 2;
G2L["1d7"]["BorderSizePixel"] = 0;
G2L["1d7"]["TextSize"] = 10;
G2L["1d7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1d7"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1d7"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["1d7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d7"]["Text"] = [[1]];
G2L["1d7"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption.Input.Background
G2L["1d8"] = Instance.new("ImageLabel", G2L["1d6"]);
G2L["1d8"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1d8"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["1d8"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1d8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d8"]["BackgroundTransparency"] = 1;
G2L["1d8"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption.Input.SelectedIndicator
G2L["1d9"] = Instance.new("Frame", G2L["1d6"]);
G2L["1d9"]["BorderSizePixel"] = 0;
G2L["1d9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d9"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["1d9"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["1d9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1d9"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.BrightnessOption.Label
G2L["1da"] = Instance.new("TextLabel", G2L["1d5"]);
G2L["1da"]["TextWrapped"] = true;
G2L["1da"]["TextStrokeTransparency"] = 0;
G2L["1da"]["BorderSizePixel"] = 0;
G2L["1da"]["TextSize"] = 10;
G2L["1da"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1da"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1da"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1da"]["BackgroundTransparency"] = 1;
G2L["1da"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1da"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1da"]["Text"] = [[Brightness]];
G2L["1da"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption
G2L["1db"] = Instance.new("Frame", G2L["1bb"]);
G2L["1db"]["BorderSizePixel"] = 0;
G2L["1db"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1db"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["1db"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1db"]["Name"] = [[ColorOption]];
G2L["1db"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.HSVPicker
G2L["1dc"] = Instance.new("ImageButton", G2L["1db"]);
G2L["1dc"]["BorderSizePixel"] = 0;
G2L["1dc"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1dc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1dc"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["1dc"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["1dc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1dc"]["Name"] = [[HSVPicker]];
G2L["1dc"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.HSVPicker.Shadow
G2L["1dd"] = Instance.new("Frame", G2L["1dc"]);
G2L["1dd"]["BorderSizePixel"] = 0;
G2L["1dd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1dd"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["1dd"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["1dd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1dd"]["Name"] = [[Shadow]];
G2L["1dd"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.Label
G2L["1de"] = Instance.new("TextLabel", G2L["1db"]);
G2L["1de"]["TextWrapped"] = true;
G2L["1de"]["TextStrokeTransparency"] = 0;
G2L["1de"]["BorderSizePixel"] = 0;
G2L["1de"]["TextSize"] = 10;
G2L["1de"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1de"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1de"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1de"]["BackgroundTransparency"] = 1;
G2L["1de"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1de"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1de"]["Text"] = [[Color]];
G2L["1de"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.Indicator
G2L["1df"] = Instance.new("Frame", G2L["1db"]);
G2L["1df"]["BorderSizePixel"] = 0;
G2L["1df"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1df"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["1df"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["1df"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1df"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.Indicator.Shadow
G2L["1e0"] = Instance.new("Frame", G2L["1df"]);
G2L["1e0"]["BorderSizePixel"] = 0;
G2L["1e0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e0"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["1e0"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["1e0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e0"]["Name"] = [[Shadow]];
G2L["1e0"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.ColorOption.Indicator.Varies
G2L["1e1"] = Instance.new("TextLabel", G2L["1df"]);
G2L["1e1"]["TextWrapped"] = true;
G2L["1e1"]["TextStrokeTransparency"] = 0.75;
G2L["1e1"]["BorderSizePixel"] = 0;
G2L["1e1"]["TextSize"] = 14;
G2L["1e1"]["TextScaled"] = true;
G2L["1e1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1e1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e1"]["BackgroundTransparency"] = 1;
G2L["1e1"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["1e1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e1"]["Text"] = [[]];
G2L["1e1"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Shadow
G2L["1e2"] = Instance.new("Frame", G2L["1ba"]);
G2L["1e2"]["BorderSizePixel"] = 0;
G2L["1e2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e2"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["1e2"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["1e2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e2"]["Name"] = [[Shadow]];
G2L["1e2"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.RemoveButton
G2L["1e3"] = Instance.new("TextButton", G2L["1ba"]);
G2L["1e3"]["BorderSizePixel"] = 0;
G2L["1e3"]["TextSize"] = 10;
G2L["1e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1e3"]["BackgroundTransparency"] = 0.75;
G2L["1e3"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["1e3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e3"]["Text"] = [[REMOVE]];
G2L["1e3"]["Name"] = [[RemoveButton]];
G2L["1e3"]["Visible"] = false;
G2L["1e3"]["Position"] = UDim2.new(0, 127, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.AddButton
G2L["1e4"] = Instance.new("TextButton", G2L["1ba"]);
G2L["1e4"]["BorderSizePixel"] = 0;
G2L["1e4"]["TextSize"] = 10;
G2L["1e4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1e4"]["BackgroundTransparency"] = 0.75;
G2L["1e4"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["1e4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e4"]["Text"] = [[ADD]];
G2L["1e4"]["Name"] = [[AddButton]];
G2L["1e4"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.ColorBar
G2L["1e5"] = Instance.new("Frame", G2L["1ba"]);
G2L["1e5"]["BorderSizePixel"] = 0;
G2L["1e5"]["BackgroundColor3"] = Color3.fromRGB(255, 175, 61);
G2L["1e5"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["1e5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e5"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.ArrowButton
G2L["1e6"] = Instance.new("ImageButton", G2L["1ba"]);
G2L["1e6"]["BorderSizePixel"] = 0;
G2L["1e6"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1e6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e6"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["1e6"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["1e6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e6"]["Name"] = [[ArrowButton]];
G2L["1e6"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Label
G2L["1e7"] = Instance.new("TextLabel", G2L["1ba"]);
G2L["1e7"]["TextWrapped"] = true;
G2L["1e7"]["TextStrokeTransparency"] = 0.5;
G2L["1e7"]["BorderSizePixel"] = 0;
G2L["1e7"]["TextSize"] = 10;
G2L["1e7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1e7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1e7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e7"]["BackgroundTransparency"] = 1;
G2L["1e7"]["Size"] = UDim2.new(0, 60, 0, 25);
G2L["1e7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e7"]["Text"] = [[Spot light]];
G2L["1e7"]["Name"] = [[Label]];
G2L["1e7"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.Title
G2L["1e8"] = Instance.new("Frame", G2L["19a"]);
G2L["1e8"]["BorderSizePixel"] = 0;
G2L["1e8"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["1e8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e8"]["Name"] = [[Title]];
G2L["1e8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.Title.F3XSignature
G2L["1e9"] = Instance.new("TextLabel", G2L["1e8"]);
G2L["1e9"]["TextWrapped"] = true;
G2L["1e9"]["TextStrokeTransparency"] = 0.9;
G2L["1e9"]["BorderSizePixel"] = 0;
G2L["1e9"]["TextSize"] = 14;
G2L["1e9"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["1e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e9"]["BackgroundTransparency"] = 1;
G2L["1e9"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1e9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1e9"]["Text"] = [[F3X]];
G2L["1e9"]["Name"] = [[F3XSignature]];
G2L["1e9"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.Title.Label
G2L["1ea"] = Instance.new("TextLabel", G2L["1e8"]);
G2L["1ea"]["TextWrapped"] = true;
G2L["1ea"]["TextStrokeTransparency"] = 0;
G2L["1ea"]["BorderSizePixel"] = 0;
G2L["1ea"]["TextSize"] = 10;
G2L["1ea"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1ea"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1ea"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ea"]["BackgroundTransparency"] = 1;
G2L["1ea"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["1ea"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ea"]["Text"] = [[LIGHTING TOOL]];
G2L["1ea"]["Name"] = [[Label]];
G2L["1ea"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.Title.ColorBar
G2L["1eb"] = Instance.new("Frame", G2L["1e8"]);
G2L["1eb"]["BorderSizePixel"] = 0;
G2L["1eb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1eb"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["1eb"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["1eb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1eb"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.BottomColorBar
G2L["1ec"] = Instance.new("Frame", G2L["19a"]);
G2L["1ec"]["BorderSizePixel"] = 0;
G2L["1ec"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ec"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["1ec"]["Position"] = UDim2.new(0, 5, 1, -2);
G2L["1ec"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ec"]["Name"] = [[BottomColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight
G2L["1ed"] = Instance.new("Frame", G2L["19a"]);
G2L["1ed"]["BorderSizePixel"] = 0;
G2L["1ed"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ed"]["ClipsDescendants"] = true;
G2L["1ed"]["Size"] = UDim2.new(1, -10, 0, 25);
G2L["1ed"]["Position"] = UDim2.new(0, 10, 0, 90);
G2L["1ed"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ed"]["Name"] = [[SurfaceLight]];
G2L["1ed"]["BackgroundTransparency"] = 0.675;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Shadow
G2L["1ee"] = Instance.new("Frame", G2L["1ed"]);
G2L["1ee"]["BorderSizePixel"] = 0;
G2L["1ee"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ee"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["1ee"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["1ee"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ee"]["Name"] = [[Shadow]];
G2L["1ee"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.RemoveButton
G2L["1ef"] = Instance.new("TextButton", G2L["1ed"]);
G2L["1ef"]["BorderSizePixel"] = 0;
G2L["1ef"]["TextSize"] = 10;
G2L["1ef"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ef"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ef"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1ef"]["BackgroundTransparency"] = 0.75;
G2L["1ef"]["Size"] = UDim2.new(0, 58, 0, 19);
G2L["1ef"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ef"]["Text"] = [[REMOVE]];
G2L["1ef"]["Name"] = [[RemoveButton]];
G2L["1ef"]["Visible"] = false;
G2L["1ef"]["Position"] = UDim2.new(0, 90, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.AddButton
G2L["1f0"] = Instance.new("TextButton", G2L["1ed"]);
G2L["1f0"]["BorderSizePixel"] = 0;
G2L["1f0"]["TextSize"] = 10;
G2L["1f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1f0"]["BackgroundTransparency"] = 0.75;
G2L["1f0"]["Size"] = UDim2.new(0, 35, 0, 19);
G2L["1f0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f0"]["Text"] = [[ADD]];
G2L["1f0"]["Name"] = [[AddButton]];
G2L["1f0"]["Position"] = UDim2.new(1, -40, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.ColorBar
G2L["1f1"] = Instance.new("Frame", G2L["1ed"]);
G2L["1f1"]["BorderSizePixel"] = 0;
G2L["1f1"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 5);
G2L["1f1"]["Size"] = UDim2.new(0, 3, 1, 0);
G2L["1f1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f1"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.ArrowButton
G2L["1f2"] = Instance.new("ImageButton", G2L["1ed"]);
G2L["1f2"]["BorderSizePixel"] = 0;
G2L["1f2"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1f2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f2"]["Image"] = [[http://www.roblox.com/asset/?id=134367382]];
G2L["1f2"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["1f2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f2"]["Name"] = [[ArrowButton]];
G2L["1f2"]["Position"] = UDim2.new(0, 10, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Label
G2L["1f3"] = Instance.new("TextLabel", G2L["1ed"]);
G2L["1f3"]["TextWrapped"] = true;
G2L["1f3"]["TextStrokeTransparency"] = 0.5;
G2L["1f3"]["BorderSizePixel"] = 0;
G2L["1f3"]["TextSize"] = 10;
G2L["1f3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1f3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1f3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f3"]["BackgroundTransparency"] = 1;
G2L["1f3"]["Size"] = UDim2.new(0, 80, 0, 25);
G2L["1f3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f3"]["Text"] = [[Surface light]];
G2L["1f3"]["Name"] = [[Label]];
G2L["1f3"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options
G2L["1f4"] = Instance.new("Frame", G2L["1ed"]);
G2L["1f4"]["BorderSizePixel"] = 0;
G2L["1f4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f4"]["ClipsDescendants"] = true;
G2L["1f4"]["Size"] = UDim2.new(1, -3, 0, 105);
G2L["1f4"]["Position"] = UDim2.new(0, 3, 1, 0);
G2L["1f4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f4"]["Name"] = [[Options]];
G2L["1f4"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ShadowsOption
G2L["1f5"] = Instance.new("Frame", G2L["1f4"]);
G2L["1f5"]["BorderSizePixel"] = 0;
G2L["1f5"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1f5"]["Position"] = UDim2.new(0, 120, 0, 80);
G2L["1f5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f5"]["Name"] = [[ShadowsOption]];
G2L["1f5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ShadowsOption.Label
G2L["1f6"] = Instance.new("TextLabel", G2L["1f5"]);
G2L["1f6"]["TextWrapped"] = true;
G2L["1f6"]["TextStrokeTransparency"] = 0;
G2L["1f6"]["BorderSizePixel"] = 0;
G2L["1f6"]["TextSize"] = 10;
G2L["1f6"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1f6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1f6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f6"]["BackgroundTransparency"] = 1;
G2L["1f6"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["1f6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f6"]["Text"] = [[Shadows]];
G2L["1f6"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ShadowsOption.Checkbox
G2L["1f7"] = Instance.new("ImageButton", G2L["1f5"]);
G2L["1f7"]["BorderSizePixel"] = 0;
G2L["1f7"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1f7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f7"]["ImageColor3"] = Color3.fromRGB(242, 242, 242);
G2L["1f7"]["Image"] = [[rbxassetid://401518903]];
G2L["1f7"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["1f7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f7"]["Name"] = [[Checkbox]];
G2L["1f7"]["Position"] = UDim2.new(0, 55, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption
G2L["1f8"] = Instance.new("Frame", G2L["1f4"]);
G2L["1f8"]["BorderSizePixel"] = 0;
G2L["1f8"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["1f8"]["Position"] = UDim2.new(0, 0, 0, 80);
G2L["1f8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f8"]["Name"] = [[SideOption]];
G2L["1f8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Label
G2L["1f9"] = Instance.new("TextLabel", G2L["1f8"]);
G2L["1f9"]["TextWrapped"] = true;
G2L["1f9"]["TextStrokeTransparency"] = 0;
G2L["1f9"]["BorderSizePixel"] = 0;
G2L["1f9"]["TextSize"] = 10;
G2L["1f9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1f9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f9"]["BackgroundTransparency"] = 1;
G2L["1f9"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["1f9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1f9"]["Text"] = [[Side]];
G2L["1f9"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown
G2L["1fa"] = Instance.new("TextButton", G2L["1f8"]);
G2L["1fa"]["TextStrokeTransparency"] = 0.8;
G2L["1fa"]["BorderSizePixel"] = 0;
G2L["1fa"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1fa"]["TextSize"] = 10;
G2L["1fa"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fa"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1fa"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1fa"]["BackgroundTransparency"] = 0.3;
G2L["1fa"]["Size"] = UDim2.new(0, 72, 0, 25);
G2L["1fa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1fa"]["Text"] = [[]];
G2L["1fa"]["Name"] = [[Dropdown]];
G2L["1fa"]["Position"] = UDim2.new(0, 30, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.Icon
G2L["1fb"] = Instance.new("ImageLabel", G2L["1fa"]);
G2L["1fb"]["ZIndex"] = 3;
G2L["1fb"]["BorderSizePixel"] = 0;
G2L["1fb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["1fb"]["Image"] = [[rbxassetid://134367382]];
G2L["1fb"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["1fb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1fb"]["BackgroundTransparency"] = 1;
G2L["1fb"]["Name"] = [[Icon]];
G2L["1fb"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.OptionButton
G2L["1fc"] = Instance.new("TextButton", G2L["1fa"]);
G2L["1fc"]["TextStrokeTransparency"] = 0.8;
G2L["1fc"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1fc"]["TextSize"] = 10;
G2L["1fc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1fc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1fc"]["ZIndex"] = 4;
G2L["1fc"]["BackgroundTransparency"] = 0.3;
G2L["1fc"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["1fc"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1fc"]["Text"] = [[]];
G2L["1fc"]["Name"] = [[OptionButton]];
G2L["1fc"]["Visible"] = false;
G2L["1fc"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.OptionButton.OptionLabel
G2L["1fd"] = Instance.new("TextLabel", G2L["1fc"]);
G2L["1fd"]["ZIndex"] = 4;
G2L["1fd"]["BorderSizePixel"] = 0;
G2L["1fd"]["TextSize"] = 10;
G2L["1fd"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["1fd"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["1fd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fd"]["BackgroundTransparency"] = 1;
G2L["1fd"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["1fd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1fd"]["Text"] = [[ALL]];
G2L["1fd"]["Name"] = [[OptionLabel]];
G2L["1fd"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.Options
G2L["1fe"] = Instance.new("Folder", G2L["1fa"]);
G2L["1fe"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.Border
G2L["1ff"] = Instance.new("Frame", G2L["1fa"]);
G2L["1ff"]["BorderSizePixel"] = 0;
G2L["1ff"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ff"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["1ff"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["1ff"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["1ff"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.CurrentOption
G2L["200"] = Instance.new("TextLabel", G2L["1fa"]);
G2L["200"]["ZIndex"] = 3;
G2L["200"]["BorderSizePixel"] = 0;
G2L["200"]["TextSize"] = 10;
G2L["200"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["200"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["200"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["200"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["200"]["BackgroundTransparency"] = 1;
G2L["200"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["200"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["200"]["Text"] = [[]];
G2L["200"]["Name"] = [[CurrentOption]];
G2L["200"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.[Component]
G2L["201"] = Instance.new("LocalScript", G2L["1fa"]);
G2L["201"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption
G2L["202"] = Instance.new("Frame", G2L["1f4"]);
G2L["202"]["BorderSizePixel"] = 0;
G2L["202"]["Size"] = UDim2.new(0, 80, 0, 25);
G2L["202"]["Position"] = UDim2.new(0, 110, 0, 10);
G2L["202"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["202"]["Name"] = [[RangeOption]];
G2L["202"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption.Input
G2L["203"] = Instance.new("Frame", G2L["202"]);
G2L["203"]["BorderSizePixel"] = 0;
G2L["203"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["203"]["Position"] = UDim2.new(0, 40, 0, 0);
G2L["203"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["203"]["Name"] = [[Input]];
G2L["203"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption.Input.TextBox
G2L["204"] = Instance.new("TextBox", G2L["203"]);
G2L["204"]["ZIndex"] = 2;
G2L["204"]["BorderSizePixel"] = 0;
G2L["204"]["TextSize"] = 10;
G2L["204"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["204"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["204"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["204"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["204"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["204"]["Text"] = [[16]];
G2L["204"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption.Input.Background
G2L["205"] = Instance.new("ImageLabel", G2L["203"]);
G2L["205"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["205"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["205"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["205"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["205"]["BackgroundTransparency"] = 1;
G2L["205"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption.Input.SelectedIndicator
G2L["206"] = Instance.new("Frame", G2L["203"]);
G2L["206"]["BorderSizePixel"] = 0;
G2L["206"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["206"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["206"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["206"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["206"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.RangeOption.Label
G2L["207"] = Instance.new("TextLabel", G2L["202"]);
G2L["207"]["TextWrapped"] = true;
G2L["207"]["TextStrokeTransparency"] = 0;
G2L["207"]["BorderSizePixel"] = 0;
G2L["207"]["TextSize"] = 10;
G2L["207"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["207"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["207"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["207"]["BackgroundTransparency"] = 1;
G2L["207"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["207"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["207"]["Text"] = [[Range]];
G2L["207"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption
G2L["208"] = Instance.new("Frame", G2L["1f4"]);
G2L["208"]["BorderSizePixel"] = 0;
G2L["208"]["Size"] = UDim2.new(1, -115, 0, 25);
G2L["208"]["Position"] = UDim2.new(0, 120, 0, 46);
G2L["208"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["208"]["Name"] = [[AngleOption]];
G2L["208"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption.Input
G2L["209"] = Instance.new("Frame", G2L["208"]);
G2L["209"]["BorderSizePixel"] = 0;
G2L["209"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["209"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["209"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["209"]["Name"] = [[Input]];
G2L["209"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption.Input.TextBox
G2L["20a"] = Instance.new("TextBox", G2L["209"]);
G2L["20a"]["ZIndex"] = 2;
G2L["20a"]["BorderSizePixel"] = 0;
G2L["20a"]["TextSize"] = 10;
G2L["20a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["20a"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["20a"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["20a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20a"]["Text"] = [[90]];
G2L["20a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption.Input.SelectedIndicator
G2L["20b"] = Instance.new("Frame", G2L["209"]);
G2L["20b"]["BorderSizePixel"] = 0;
G2L["20b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20b"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["20b"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["20b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20b"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption.Input.Background
G2L["20c"] = Instance.new("ImageLabel", G2L["209"]);
G2L["20c"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["20c"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["20c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["20c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20c"]["BackgroundTransparency"] = 1;
G2L["20c"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.AngleOption.Label
G2L["20d"] = Instance.new("TextLabel", G2L["208"]);
G2L["20d"]["TextWrapped"] = true;
G2L["20d"]["TextStrokeTransparency"] = 0;
G2L["20d"]["BorderSizePixel"] = 0;
G2L["20d"]["TextSize"] = 10;
G2L["20d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["20d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["20d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20d"]["BackgroundTransparency"] = 1;
G2L["20d"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["20d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20d"]["Text"] = [[Angle]];
G2L["20d"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption
G2L["20e"] = Instance.new("Frame", G2L["1f4"]);
G2L["20e"]["BorderSizePixel"] = 0;
G2L["20e"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["20e"]["Position"] = UDim2.new(0, 0, 0, 45);
G2L["20e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20e"]["Name"] = [[BrightnessOption]];
G2L["20e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption.Input
G2L["20f"] = Instance.new("Frame", G2L["20e"]);
G2L["20f"]["BorderSizePixel"] = 0;
G2L["20f"]["Size"] = UDim2.new(0, 38, 0, 25);
G2L["20f"]["Position"] = UDim2.new(0, 60, 0, 0);
G2L["20f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["20f"]["Name"] = [[Input]];
G2L["20f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption.Input.TextBox
G2L["210"] = Instance.new("TextBox", G2L["20f"]);
G2L["210"]["ZIndex"] = 2;
G2L["210"]["BorderSizePixel"] = 0;
G2L["210"]["TextSize"] = 10;
G2L["210"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["210"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["210"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["210"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["210"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["210"]["Text"] = [[1]];
G2L["210"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption.Input.Background
G2L["211"] = Instance.new("ImageLabel", G2L["20f"]);
G2L["211"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["211"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["211"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["211"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["211"]["BackgroundTransparency"] = 1;
G2L["211"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption.Input.SelectedIndicator
G2L["212"] = Instance.new("Frame", G2L["20f"]);
G2L["212"]["BorderSizePixel"] = 0;
G2L["212"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["212"]["Size"] = UDim2.new(1, -3, 0, 2);
G2L["212"]["Position"] = UDim2.new(0, 3, 0, -2);
G2L["212"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["212"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.BrightnessOption.Label
G2L["213"] = Instance.new("TextLabel", G2L["20e"]);
G2L["213"]["TextWrapped"] = true;
G2L["213"]["TextStrokeTransparency"] = 0;
G2L["213"]["BorderSizePixel"] = 0;
G2L["213"]["TextSize"] = 10;
G2L["213"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["213"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["213"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["213"]["BackgroundTransparency"] = 1;
G2L["213"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["213"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["213"]["Text"] = [[Brightness]];
G2L["213"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption
G2L["214"] = Instance.new("Frame", G2L["1f4"]);
G2L["214"]["BorderSizePixel"] = 0;
G2L["214"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["214"]["Position"] = UDim2.new(0, 0, 0, 10);
G2L["214"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["214"]["Name"] = [[ColorOption]];
G2L["214"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.HSVPicker
G2L["215"] = Instance.new("ImageButton", G2L["214"]);
G2L["215"]["BorderSizePixel"] = 0;
G2L["215"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["215"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["215"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["215"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["215"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["215"]["Name"] = [[HSVPicker]];
G2L["215"]["Position"] = UDim2.new(0, 60, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.HSVPicker.Shadow
G2L["216"] = Instance.new("Frame", G2L["215"]);
G2L["216"]["BorderSizePixel"] = 0;
G2L["216"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["216"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["216"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["216"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["216"]["Name"] = [[Shadow]];
G2L["216"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.Label
G2L["217"] = Instance.new("TextLabel", G2L["214"]);
G2L["217"]["TextWrapped"] = true;
G2L["217"]["TextStrokeTransparency"] = 0;
G2L["217"]["BorderSizePixel"] = 0;
G2L["217"]["TextSize"] = 10;
G2L["217"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["217"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["217"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["217"]["BackgroundTransparency"] = 1;
G2L["217"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["217"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["217"]["Text"] = [[Color]];
G2L["217"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.Indicator
G2L["218"] = Instance.new("Frame", G2L["214"]);
G2L["218"]["BorderSizePixel"] = 0;
G2L["218"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["218"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["218"]["Position"] = UDim2.new(0, 35, 0, 0);
G2L["218"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["218"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.Indicator.Shadow
G2L["219"] = Instance.new("Frame", G2L["218"]);
G2L["219"]["BorderSizePixel"] = 0;
G2L["219"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["219"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["219"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["219"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["219"]["Name"] = [[Shadow]];
G2L["219"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.ColorOption.Indicator.Varies
G2L["21a"] = Instance.new("TextLabel", G2L["218"]);
G2L["21a"]["TextWrapped"] = true;
G2L["21a"]["TextStrokeTransparency"] = 0.75;
G2L["21a"]["BorderSizePixel"] = 0;
G2L["21a"]["TextSize"] = 14;
G2L["21a"]["TextScaled"] = true;
G2L["21a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["21a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21a"]["BackgroundTransparency"] = 1;
G2L["21a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["21a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21a"]["Text"] = [[]];
G2L["21a"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI
G2L["21b"] = Instance.new("Frame", G2L["52"]);
G2L["21b"]["Active"] = true;
G2L["21b"]["BorderSizePixel"] = 0;
G2L["21b"]["Size"] = UDim2.new(0, 200, 0, 145);
G2L["21b"]["Position"] = UDim2.new(0, 0, 0.4, 0);
G2L["21b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21b"]["Name"] = [[BTMaterialToolGUI]];
G2L["21b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Title
G2L["21c"] = Instance.new("Frame", G2L["21b"]);
G2L["21c"]["BorderSizePixel"] = 0;
G2L["21c"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["21c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21c"]["Name"] = [[Title]];
G2L["21c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Title.ColorBar
G2L["21d"] = Instance.new("Frame", G2L["21c"]);
G2L["21d"]["BorderSizePixel"] = 0;
G2L["21d"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["21d"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["21d"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["21d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21d"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Title.Label
G2L["21e"] = Instance.new("TextLabel", G2L["21c"]);
G2L["21e"]["TextWrapped"] = true;
G2L["21e"]["TextStrokeTransparency"] = 0;
G2L["21e"]["BorderSizePixel"] = 0;
G2L["21e"]["TextSize"] = 10;
G2L["21e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["21e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["21e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21e"]["BackgroundTransparency"] = 1;
G2L["21e"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["21e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21e"]["Text"] = [[MATERIAL TOOL]];
G2L["21e"]["Name"] = [[Label]];
G2L["21e"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Title.F3XSignature
G2L["21f"] = Instance.new("TextLabel", G2L["21c"]);
G2L["21f"]["TextWrapped"] = true;
G2L["21f"]["TextStrokeTransparency"] = 0.9;
G2L["21f"]["BorderSizePixel"] = 0;
G2L["21f"]["TextSize"] = 14;
G2L["21f"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["21f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["21f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21f"]["BackgroundTransparency"] = 1;
G2L["21f"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["21f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["21f"]["Text"] = [[F3X]];
G2L["21f"]["Name"] = [[F3XSignature]];
G2L["21f"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption
G2L["220"] = Instance.new("Frame", G2L["21b"]);
G2L["220"]["BorderSizePixel"] = 0;
G2L["220"]["Size"] = UDim2.new(1, -14, 0, 25);
G2L["220"]["Position"] = UDim2.new(0, 14, 0, 30);
G2L["220"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["220"]["Name"] = [[MaterialOption]];
G2L["220"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Label
G2L["221"] = Instance.new("TextLabel", G2L["220"]);
G2L["221"]["TextWrapped"] = true;
G2L["221"]["TextStrokeTransparency"] = 0;
G2L["221"]["BorderSizePixel"] = 0;
G2L["221"]["TextSize"] = 10;
G2L["221"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["221"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["221"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["221"]["BackgroundTransparency"] = 1;
G2L["221"]["Size"] = UDim2.new(0, 40, 0, 25);
G2L["221"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["221"]["Text"] = [[Material]];
G2L["221"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown
G2L["222"] = Instance.new("TextButton", G2L["220"]);
G2L["222"]["TextStrokeTransparency"] = 0.8;
G2L["222"]["BorderSizePixel"] = 0;
G2L["222"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["222"]["TextSize"] = 10;
G2L["222"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["222"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["222"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["222"]["BackgroundTransparency"] = 0.3;
G2L["222"]["Size"] = UDim2.new(0, 130, 0, 25);
G2L["222"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["222"]["Text"] = [[]];
G2L["222"]["Name"] = [[Dropdown]];
G2L["222"]["Position"] = UDim2.new(0, 50, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.Icon
G2L["223"] = Instance.new("ImageLabel", G2L["222"]);
G2L["223"]["ZIndex"] = 3;
G2L["223"]["BorderSizePixel"] = 0;
G2L["223"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["223"]["Image"] = [[rbxassetid://134367382]];
G2L["223"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["223"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["223"]["BackgroundTransparency"] = 1;
G2L["223"]["Name"] = [[Icon]];
G2L["223"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.OptionButton
G2L["224"] = Instance.new("TextButton", G2L["222"]);
G2L["224"]["TextStrokeTransparency"] = 0.8;
G2L["224"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["224"]["TextSize"] = 10;
G2L["224"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["224"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["224"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["224"]["ZIndex"] = 4;
G2L["224"]["BackgroundTransparency"] = 0.3;
G2L["224"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["224"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["224"]["Text"] = [[]];
G2L["224"]["Name"] = [[OptionButton]];
G2L["224"]["Visible"] = false;
G2L["224"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.OptionButton.OptionLabel
G2L["225"] = Instance.new("TextLabel", G2L["224"]);
G2L["225"]["ZIndex"] = 4;
G2L["225"]["BorderSizePixel"] = 0;
G2L["225"]["TextSize"] = 10;
G2L["225"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["225"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["225"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["225"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["225"]["BackgroundTransparency"] = 1;
G2L["225"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["225"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["225"]["Text"] = [[ALL]];
G2L["225"]["Name"] = [[OptionLabel]];
G2L["225"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.Options
G2L["226"] = Instance.new("Folder", G2L["222"]);
G2L["226"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.Border
G2L["227"] = Instance.new("Frame", G2L["222"]);
G2L["227"]["BorderSizePixel"] = 0;
G2L["227"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["227"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["227"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["227"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["227"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.CurrentOption
G2L["228"] = Instance.new("TextLabel", G2L["222"]);
G2L["228"]["ZIndex"] = 3;
G2L["228"]["BorderSizePixel"] = 0;
G2L["228"]["TextSize"] = 10;
G2L["228"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["228"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["228"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["228"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["228"]["BackgroundTransparency"] = 1;
G2L["228"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["228"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["228"]["Text"] = [[]];
G2L["228"]["Name"] = [[CurrentOption]];
G2L["228"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.[Component]
G2L["229"] = Instance.new("LocalScript", G2L["222"]);
G2L["229"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption
G2L["22a"] = Instance.new("Frame", G2L["21b"]);
G2L["22a"]["BorderSizePixel"] = 0;
G2L["22a"]["Size"] = UDim2.new(1, 0, 0, 24);
G2L["22a"]["Position"] = UDim2.new(0, 0, 0, 65);
G2L["22a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22a"]["Name"] = [[TransparencyOption]];
G2L["22a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption.Label
G2L["22b"] = Instance.new("TextLabel", G2L["22a"]);
G2L["22b"]["TextWrapped"] = true;
G2L["22b"]["TextStrokeTransparency"] = 0;
G2L["22b"]["BorderSizePixel"] = 0;
G2L["22b"]["TextSize"] = 10;
G2L["22b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["22b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["22b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["22b"]["BackgroundTransparency"] = 1;
G2L["22b"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["22b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22b"]["Text"] = [[Transparency]];
G2L["22b"]["Name"] = [[Label]];
G2L["22b"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption.Input
G2L["22c"] = Instance.new("Frame", G2L["22a"]);
G2L["22c"]["BorderSizePixel"] = 0;
G2L["22c"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["22c"]["Position"] = UDim2.new(0, 90, 0, 0);
G2L["22c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22c"]["Name"] = [[Input]];
G2L["22c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption.Input.Background
G2L["22d"] = Instance.new("ImageLabel", G2L["22c"]);
G2L["22d"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["22d"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["22d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["22d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22d"]["BackgroundTransparency"] = 1;
G2L["22d"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption.Input.SelectedIndicator
G2L["22e"] = Instance.new("Frame", G2L["22c"]);
G2L["22e"]["BorderSizePixel"] = 0;
G2L["22e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["22e"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["22e"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["22e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22e"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.TransparencyOption.Input.TextBox
G2L["22f"] = Instance.new("TextBox", G2L["22c"]);
G2L["22f"]["BorderSizePixel"] = 0;
G2L["22f"]["TextSize"] = 10;
G2L["22f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["22f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["22f"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["22f"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["22f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["22f"]["Text"] = [[]];
G2L["22f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption
G2L["230"] = Instance.new("Frame", G2L["21b"]);
G2L["230"]["BorderSizePixel"] = 0;
G2L["230"]["Size"] = UDim2.new(1, 0, 0, 24);
G2L["230"]["Position"] = UDim2.new(0, 0, 0, 100);
G2L["230"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["230"]["Name"] = [[ReflectanceOption]];
G2L["230"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption.Label
G2L["231"] = Instance.new("TextLabel", G2L["230"]);
G2L["231"]["TextWrapped"] = true;
G2L["231"]["TextStrokeTransparency"] = 0;
G2L["231"]["BorderSizePixel"] = 0;
G2L["231"]["TextSize"] = 10;
G2L["231"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["231"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["231"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["231"]["BackgroundTransparency"] = 1;
G2L["231"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["231"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["231"]["Text"] = [[Reflectance]];
G2L["231"]["Name"] = [[Label]];
G2L["231"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption.Input
G2L["232"] = Instance.new("Frame", G2L["230"]);
G2L["232"]["BorderSizePixel"] = 0;
G2L["232"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["232"]["Position"] = UDim2.new(0, 85, 0, 0);
G2L["232"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["232"]["Name"] = [[Input]];
G2L["232"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption.Input.SelectedIndicator
G2L["233"] = Instance.new("Frame", G2L["232"]);
G2L["233"]["BorderSizePixel"] = 0;
G2L["233"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["233"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["233"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["233"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["233"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption.Input.Background
G2L["234"] = Instance.new("ImageLabel", G2L["232"]);
G2L["234"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["234"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["234"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["234"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["234"]["BackgroundTransparency"] = 1;
G2L["234"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.ReflectanceOption.Input.TextBox
G2L["235"] = Instance.new("TextBox", G2L["232"]);
G2L["235"]["BorderSizePixel"] = 0;
G2L["235"]["TextSize"] = 10;
G2L["235"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["235"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["235"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["235"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["235"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["235"]["Text"] = [[]];
G2L["235"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Bottom
G2L["236"] = Instance.new("Frame", G2L["21b"]);
G2L["236"]["BorderSizePixel"] = 0;
G2L["236"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["236"]["Position"] = UDim2.new(0, 5, 1, -10);
G2L["236"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["236"]["Name"] = [[Bottom]];
G2L["236"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.Bottom.ColorBar
G2L["237"] = Instance.new("Frame", G2L["236"]);
G2L["237"]["BorderSizePixel"] = 0;
G2L["237"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["237"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["237"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["237"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.SelectNote
G2L["238"] = Instance.new("TextLabel", G2L["21b"]);
G2L["238"]["TextWrapped"] = true;
G2L["238"]["TextStrokeTransparency"] = 0.5;
G2L["238"]["BorderSizePixel"] = 0;
G2L["238"]["TextSize"] = 14;
G2L["238"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["238"]["TextScaled"] = true;
G2L["238"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["238"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["238"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["238"]["BackgroundTransparency"] = 1;
G2L["238"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["238"]["Visible"] = false;
G2L["238"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["238"]["Text"] = [[Select something to use this tool.]];
G2L["238"]["Name"] = [[SelectNote]];
G2L["238"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI
G2L["239"] = Instance.new("Frame", G2L["52"]);
G2L["239"]["Active"] = true;
G2L["239"]["BorderSizePixel"] = 0;
G2L["239"]["Size"] = UDim2.new(0, 200, 0, 55);
G2L["239"]["Position"] = UDim2.new(0, 0, 0.4, 0);
G2L["239"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["239"]["Name"] = [[BTMeshToolGUI]];
G2L["239"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.Title
G2L["23a"] = Instance.new("Frame", G2L["239"]);
G2L["23a"]["BorderSizePixel"] = 0;
G2L["23a"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["23a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23a"]["Name"] = [[Title]];
G2L["23a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.Title.ColorBar
G2L["23b"] = Instance.new("Frame", G2L["23a"]);
G2L["23b"]["BorderSizePixel"] = 0;
G2L["23b"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["23b"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["23b"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["23b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23b"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.Title.Label
G2L["23c"] = Instance.new("TextLabel", G2L["23a"]);
G2L["23c"]["TextWrapped"] = true;
G2L["23c"]["TextStrokeTransparency"] = 0;
G2L["23c"]["BorderSizePixel"] = 0;
G2L["23c"]["TextSize"] = 10;
G2L["23c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["23c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["23c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["23c"]["BackgroundTransparency"] = 1;
G2L["23c"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["23c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23c"]["Text"] = [[MESH TOOL]];
G2L["23c"]["Name"] = [[Label]];
G2L["23c"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.Title.F3XSignature
G2L["23d"] = Instance.new("TextLabel", G2L["23a"]);
G2L["23d"]["TextWrapped"] = true;
G2L["23d"]["TextStrokeTransparency"] = 0.9;
G2L["23d"]["BorderSizePixel"] = 0;
G2L["23d"]["TextSize"] = 14;
G2L["23d"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["23d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["23d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["23d"]["BackgroundTransparency"] = 1;
G2L["23d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["23d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23d"]["Text"] = [[F3X]];
G2L["23d"]["Name"] = [[F3XSignature]];
G2L["23d"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption
G2L["23e"] = Instance.new("Frame", G2L["239"]);
G2L["23e"]["Visible"] = false;
G2L["23e"]["BorderSizePixel"] = 0;
G2L["23e"]["Size"] = UDim2.new(1, -14, 0, 25);
G2L["23e"]["Position"] = UDim2.new(0, 14, 0, 65);
G2L["23e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23e"]["Name"] = [[TypeOption]];
G2L["23e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Label
G2L["23f"] = Instance.new("TextLabel", G2L["23e"]);
G2L["23f"]["TextWrapped"] = true;
G2L["23f"]["TextStrokeTransparency"] = 0;
G2L["23f"]["BorderSizePixel"] = 0;
G2L["23f"]["TextSize"] = 10;
G2L["23f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["23f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["23f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["23f"]["BackgroundTransparency"] = 1;
G2L["23f"]["Size"] = UDim2.new(0, 30, 0, 25);
G2L["23f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["23f"]["Text"] = [[Type]];
G2L["23f"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown
G2L["240"] = Instance.new("TextButton", G2L["23e"]);
G2L["240"]["TextStrokeTransparency"] = 0.8;
G2L["240"]["BorderSizePixel"] = 0;
G2L["240"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["240"]["TextSize"] = 10;
G2L["240"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["240"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["240"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["240"]["BackgroundTransparency"] = 0.3;
G2L["240"]["Size"] = UDim2.new(1, -40, 0, 25);
G2L["240"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["240"]["Text"] = [[]];
G2L["240"]["Name"] = [[Dropdown]];
G2L["240"]["Position"] = UDim2.new(0, 40, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.Icon
G2L["241"] = Instance.new("ImageLabel", G2L["240"]);
G2L["241"]["ZIndex"] = 3;
G2L["241"]["BorderSizePixel"] = 0;
G2L["241"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["241"]["Image"] = [[rbxassetid://134367382]];
G2L["241"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["241"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["241"]["BackgroundTransparency"] = 1;
G2L["241"]["Name"] = [[Icon]];
G2L["241"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.OptionButton
G2L["242"] = Instance.new("TextButton", G2L["240"]);
G2L["242"]["TextStrokeTransparency"] = 0.8;
G2L["242"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["242"]["TextSize"] = 10;
G2L["242"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["242"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["242"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["242"]["ZIndex"] = 4;
G2L["242"]["BackgroundTransparency"] = 0.3;
G2L["242"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["242"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["242"]["Text"] = [[]];
G2L["242"]["Name"] = [[OptionButton]];
G2L["242"]["Visible"] = false;
G2L["242"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.OptionButton.OptionLabel
G2L["243"] = Instance.new("TextLabel", G2L["242"]);
G2L["243"]["ZIndex"] = 4;
G2L["243"]["BorderSizePixel"] = 0;
G2L["243"]["TextSize"] = 10;
G2L["243"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["243"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["243"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["243"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["243"]["BackgroundTransparency"] = 1;
G2L["243"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["243"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["243"]["Text"] = [[ALL]];
G2L["243"]["Name"] = [[OptionLabel]];
G2L["243"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.Options
G2L["244"] = Instance.new("Folder", G2L["240"]);
G2L["244"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.Border
G2L["245"] = Instance.new("Frame", G2L["240"]);
G2L["245"]["BorderSizePixel"] = 0;
G2L["245"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["245"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["245"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["245"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["245"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.CurrentOption
G2L["246"] = Instance.new("TextLabel", G2L["240"]);
G2L["246"]["ZIndex"] = 3;
G2L["246"]["BorderSizePixel"] = 0;
G2L["246"]["TextSize"] = 10;
G2L["246"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["246"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["246"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["246"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["246"]["BackgroundTransparency"] = 1;
G2L["246"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["246"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["246"]["Text"] = [[]];
G2L["246"]["Name"] = [[CurrentOption]];
G2L["246"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.[Component]
G2L["247"] = Instance.new("LocalScript", G2L["240"]);
G2L["247"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption
G2L["248"] = Instance.new("Frame", G2L["239"]);
G2L["248"]["Visible"] = false;
G2L["248"]["BorderSizePixel"] = 0;
G2L["248"]["Size"] = UDim2.new(0, 200, 0, 25);
G2L["248"]["Position"] = UDim2.new(0, 0, 0, 100);
G2L["248"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["248"]["Name"] = [[ScaleOption]];
G2L["248"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.Label
G2L["249"] = Instance.new("TextLabel", G2L["248"]);
G2L["249"]["TextWrapped"] = true;
G2L["249"]["TextStrokeTransparency"] = 0;
G2L["249"]["BorderSizePixel"] = 0;
G2L["249"]["TextSize"] = 10;
G2L["249"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["249"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["249"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["249"]["BackgroundTransparency"] = 1;
G2L["249"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["249"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["249"]["Text"] = [[Scale]];
G2L["249"]["Name"] = [[Label]];
G2L["249"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.XInput
G2L["24a"] = Instance.new("Frame", G2L["248"]);
G2L["24a"]["BorderSizePixel"] = 0;
G2L["24a"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["24a"]["Position"] = UDim2.new(0, 55, 0, 0);
G2L["24a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24a"]["Name"] = [[XInput]];
G2L["24a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.XInput.Background
G2L["24b"] = Instance.new("ImageLabel", G2L["24a"]);
G2L["24b"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["24b"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["24b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["24b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24b"]["BackgroundTransparency"] = 1;
G2L["24b"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.XInput.SelectedIndicator
G2L["24c"] = Instance.new("Frame", G2L["24a"]);
G2L["24c"]["BorderSizePixel"] = 0;
G2L["24c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["24c"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["24c"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["24c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24c"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.XInput.TextBox
G2L["24d"] = Instance.new("TextBox", G2L["24a"]);
G2L["24d"]["BorderSizePixel"] = 0;
G2L["24d"]["TextSize"] = 10;
G2L["24d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["24d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["24d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["24d"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["24d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24d"]["Text"] = [[1]];
G2L["24d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.YInput
G2L["24e"] = Instance.new("Frame", G2L["248"]);
G2L["24e"]["BorderSizePixel"] = 0;
G2L["24e"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["24e"]["Position"] = UDim2.new(0, 100, 0, 0);
G2L["24e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24e"]["Name"] = [[YInput]];
G2L["24e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.YInput.Background
G2L["24f"] = Instance.new("ImageLabel", G2L["24e"]);
G2L["24f"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["24f"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["24f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["24f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["24f"]["BackgroundTransparency"] = 1;
G2L["24f"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.YInput.SelectedIndicator
G2L["250"] = Instance.new("Frame", G2L["24e"]);
G2L["250"]["BorderSizePixel"] = 0;
G2L["250"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["250"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["250"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["250"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["250"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.YInput.TextBox
G2L["251"] = Instance.new("TextBox", G2L["24e"]);
G2L["251"]["BorderSizePixel"] = 0;
G2L["251"]["TextSize"] = 10;
G2L["251"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["251"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["251"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["251"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["251"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["251"]["Text"] = [[1]];
G2L["251"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.ZInput
G2L["252"] = Instance.new("Frame", G2L["248"]);
G2L["252"]["BorderSizePixel"] = 0;
G2L["252"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["252"]["Position"] = UDim2.new(0, 145, 0, 0);
G2L["252"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["252"]["Name"] = [[ZInput]];
G2L["252"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.ZInput.Background
G2L["253"] = Instance.new("ImageLabel", G2L["252"]);
G2L["253"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["253"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["253"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["253"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["253"]["BackgroundTransparency"] = 1;
G2L["253"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.ZInput.SelectedIndicator
G2L["254"] = Instance.new("Frame", G2L["252"]);
G2L["254"]["BorderSizePixel"] = 0;
G2L["254"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["254"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["254"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["254"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["254"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.ScaleOption.ZInput.TextBox
G2L["255"] = Instance.new("TextBox", G2L["252"]);
G2L["255"]["BorderSizePixel"] = 0;
G2L["255"]["TextSize"] = 10;
G2L["255"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["255"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["255"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["255"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["255"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["255"]["Text"] = [[1]];
G2L["255"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.AddButton
G2L["256"] = Instance.new("Frame", G2L["239"]);
G2L["256"]["Visible"] = false;
G2L["256"]["BorderSizePixel"] = 0;
G2L["256"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["256"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["256"]["Position"] = UDim2.new(0, 10, 0, 30);
G2L["256"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["256"]["Name"] = [[AddButton]];
G2L["256"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.AddButton.Button
G2L["257"] = Instance.new("TextButton", G2L["256"]);
G2L["257"]["TextStrokeTransparency"] = 0.8;
G2L["257"]["BorderSizePixel"] = 0;
G2L["257"]["TextSize"] = 10;
G2L["257"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["257"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["257"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["257"]["BackgroundTransparency"] = 0.45;
G2L["257"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["257"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["257"]["Text"] = [[ADD MESH]];
G2L["257"]["Name"] = [[Button]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.AddButton.Shadow
G2L["258"] = Instance.new("Frame", G2L["256"]);
G2L["258"]["ZIndex"] = 2;
G2L["258"]["BorderSizePixel"] = 0;
G2L["258"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["258"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["258"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["258"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["258"]["Name"] = [[Shadow]];
G2L["258"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption
G2L["259"] = Instance.new("Frame", G2L["239"]);
G2L["259"]["Visible"] = false;
G2L["259"]["BorderSizePixel"] = 0;
G2L["259"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["259"]["Position"] = UDim2.new(0, 14, 0, 135);
G2L["259"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["259"]["Name"] = [[MeshIdOption]];
G2L["259"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.Label
G2L["25a"] = Instance.new("TextLabel", G2L["259"]);
G2L["25a"]["TextWrapped"] = true;
G2L["25a"]["TextStrokeTransparency"] = 0;
G2L["25a"]["BorderSizePixel"] = 0;
G2L["25a"]["TextSize"] = 10;
G2L["25a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["25a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["25a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25a"]["BackgroundTransparency"] = 1;
G2L["25a"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["25a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["25a"]["Text"] = [[Mesh ID]];
G2L["25a"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBox
G2L["25b"] = Instance.new("TextBox", G2L["259"]);
G2L["25b"]["TextStrokeTransparency"] = 0.5;
G2L["25b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["25b"]["BorderSizePixel"] = 0;
G2L["25b"]["TextWrapped"] = true;
G2L["25b"]["TextSize"] = 10;
G2L["25b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25b"]["TextScaled"] = true;
G2L["25b"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["25b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["25b"]["Size"] = UDim2.new(0, 80, 0, 18);
G2L["25b"]["Position"] = UDim2.new(0, 60, 0, -1);
G2L["25b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["25b"]["Text"] = [[]];
G2L["25b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBoxBorder
G2L["25c"] = Instance.new("Frame", G2L["259"]);
G2L["25c"]["BorderSizePixel"] = 0;
G2L["25c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25c"]["Size"] = UDim2.new(0, 85, 0, 3);
G2L["25c"]["Position"] = UDim2.new(0, 56, 0, 17);
G2L["25c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["25c"]["Name"] = [[TextBoxBorder]];
G2L["25c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBoxBorder.BottomBorder
G2L["25d"] = Instance.new("Frame", G2L["25c"]);
G2L["25d"]["BorderSizePixel"] = 0;
G2L["25d"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["25d"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["25d"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["25d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["25d"]["Name"] = [[BottomBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBoxBorder.LeftBorder
G2L["25e"] = Instance.new("Frame", G2L["25c"]);
G2L["25e"]["BorderSizePixel"] = 0;
G2L["25e"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["25e"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["25e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["25e"]["Name"] = [[LeftBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBoxBorder.RightBorder
G2L["25f"] = Instance.new("Frame", G2L["25c"]);
G2L["25f"]["BorderSizePixel"] = 0;
G2L["25f"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["25f"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["25f"]["Position"] = UDim2.new(1, -1, 0, 0);
G2L["25f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["25f"]["Name"] = [[RightBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.MeshIdOption.TextBoxBackground
G2L["260"] = Instance.new("Frame", G2L["259"]);
G2L["260"]["BorderSizePixel"] = 0;
G2L["260"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["260"]["Size"] = UDim2.new(0, 86, 0, 22);
G2L["260"]["Position"] = UDim2.new(0, 55, 0, -2);
G2L["260"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["260"]["Name"] = [[TextBoxBackground]];
G2L["260"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.BottomColorBar
G2L["261"] = Instance.new("Frame", G2L["239"]);
G2L["261"]["BorderSizePixel"] = 0;
G2L["261"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["261"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["261"]["Position"] = UDim2.new(0, 5, 1, -2);
G2L["261"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["261"]["Name"] = [[BottomColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption
G2L["262"] = Instance.new("Frame", G2L["239"]);
G2L["262"]["Visible"] = false;
G2L["262"]["BorderSizePixel"] = 0;
G2L["262"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["262"]["Position"] = UDim2.new(0, 14, 0, 165);
G2L["262"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["262"]["Name"] = [[TextureIdOption]];
G2L["262"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.Label
G2L["263"] = Instance.new("TextLabel", G2L["262"]);
G2L["263"]["TextWrapped"] = true;
G2L["263"]["TextStrokeTransparency"] = 0;
G2L["263"]["BorderSizePixel"] = 0;
G2L["263"]["TextSize"] = 10;
G2L["263"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["263"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["263"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["263"]["BackgroundTransparency"] = 1;
G2L["263"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["263"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["263"]["Text"] = [[Texture ID]];
G2L["263"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBox
G2L["264"] = Instance.new("TextBox", G2L["262"]);
G2L["264"]["TextStrokeTransparency"] = 0.5;
G2L["264"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["264"]["BorderSizePixel"] = 0;
G2L["264"]["TextWrapped"] = true;
G2L["264"]["TextSize"] = 10;
G2L["264"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["264"]["TextScaled"] = true;
G2L["264"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["264"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["264"]["Size"] = UDim2.new(0, 80, 0, 18);
G2L["264"]["Position"] = UDim2.new(0, 65, 0, -1);
G2L["264"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["264"]["Text"] = [[]];
G2L["264"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBoxBorder
G2L["265"] = Instance.new("Frame", G2L["262"]);
G2L["265"]["BorderSizePixel"] = 0;
G2L["265"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["265"]["Size"] = UDim2.new(0, 85, 0, 3);
G2L["265"]["Position"] = UDim2.new(0, 61, 0, 17);
G2L["265"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["265"]["Name"] = [[TextBoxBorder]];
G2L["265"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBoxBorder.BottomBorder
G2L["266"] = Instance.new("Frame", G2L["265"]);
G2L["266"]["BorderSizePixel"] = 0;
G2L["266"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["266"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["266"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["266"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["266"]["Name"] = [[BottomBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBoxBorder.LeftBorder
G2L["267"] = Instance.new("Frame", G2L["265"]);
G2L["267"]["BorderSizePixel"] = 0;
G2L["267"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["267"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["267"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["267"]["Name"] = [[LeftBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBoxBorder.RightBorder
G2L["268"] = Instance.new("Frame", G2L["265"]);
G2L["268"]["BorderSizePixel"] = 0;
G2L["268"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["268"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["268"]["Position"] = UDim2.new(1, -1, 0, 0);
G2L["268"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["268"]["Name"] = [[RightBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TextureIdOption.TextBoxBackground
G2L["269"] = Instance.new("Frame", G2L["262"]);
G2L["269"]["BorderSizePixel"] = 0;
G2L["269"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["269"]["Size"] = UDim2.new(0, 86, 0, 22);
G2L["269"]["Position"] = UDim2.new(0, 60, 0, -2);
G2L["269"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["269"]["Name"] = [[TextBoxBackground]];
G2L["269"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.RemoveButton
G2L["26a"] = Instance.new("Frame", G2L["239"]);
G2L["26a"]["Visible"] = false;
G2L["26a"]["BorderSizePixel"] = 0;
G2L["26a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["26a"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["26a"]["Position"] = UDim2.new(0, 10, 1, -30);
G2L["26a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26a"]["Name"] = [[RemoveButton]];
G2L["26a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.RemoveButton.Button
G2L["26b"] = Instance.new("TextButton", G2L["26a"]);
G2L["26b"]["TextStrokeTransparency"] = 0.8;
G2L["26b"]["BorderSizePixel"] = 0;
G2L["26b"]["TextSize"] = 10;
G2L["26b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["26b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["26b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["26b"]["BackgroundTransparency"] = 0.45;
G2L["26b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["26b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26b"]["Text"] = [[REMOVE MESH]];
G2L["26b"]["Name"] = [[Button]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.RemoveButton.Shadow
G2L["26c"] = Instance.new("Frame", G2L["26a"]);
G2L["26c"]["ZIndex"] = 2;
G2L["26c"]["BorderSizePixel"] = 0;
G2L["26c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["26c"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["26c"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["26c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26c"]["Name"] = [[Shadow]];
G2L["26c"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption
G2L["26d"] = Instance.new("Frame", G2L["239"]);
G2L["26d"]["Visible"] = false;
G2L["26d"]["BorderSizePixel"] = 0;
G2L["26d"]["Size"] = UDim2.new(0, 100, 0, 24);
G2L["26d"]["Position"] = UDim2.new(0, 0, 0, 200);
G2L["26d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26d"]["Name"] = [[TintOption]];
G2L["26d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.Label
G2L["26e"] = Instance.new("TextLabel", G2L["26d"]);
G2L["26e"]["TextWrapped"] = true;
G2L["26e"]["TextStrokeTransparency"] = 0;
G2L["26e"]["BorderSizePixel"] = 0;
G2L["26e"]["TextSize"] = 10;
G2L["26e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["26e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["26e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["26e"]["BackgroundTransparency"] = 1;
G2L["26e"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["26e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26e"]["Text"] = [[Tint]];
G2L["26e"]["Name"] = [[Label]];
G2L["26e"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.Indicator
G2L["26f"] = Instance.new("Frame", G2L["26d"]);
G2L["26f"]["BorderSizePixel"] = 0;
G2L["26f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["26f"]["Size"] = UDim2.new(0, 22, 0, 24);
G2L["26f"]["Position"] = UDim2.new(0, 45, 0, 0);
G2L["26f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["26f"]["Name"] = [[Indicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.Indicator.Shadow
G2L["270"] = Instance.new("Frame", G2L["26f"]);
G2L["270"]["BorderSizePixel"] = 0;
G2L["270"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["270"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["270"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["270"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["270"]["Name"] = [[Shadow]];
G2L["270"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.Indicator.Varies
G2L["271"] = Instance.new("TextLabel", G2L["26f"]);
G2L["271"]["TextWrapped"] = true;
G2L["271"]["TextStrokeTransparency"] = 0.75;
G2L["271"]["BorderSizePixel"] = 0;
G2L["271"]["TextSize"] = 14;
G2L["271"]["TextScaled"] = true;
G2L["271"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["271"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["271"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["271"]["BackgroundTransparency"] = 1;
G2L["271"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["271"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["271"]["Text"] = [[]];
G2L["271"]["Name"] = [[Varies]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.HSVPicker
G2L["272"] = Instance.new("ImageButton", G2L["26d"]);
G2L["272"]["BorderSizePixel"] = 0;
G2L["272"]["BackgroundTransparency"] = 0.4;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["272"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["272"]["Image"] = [[http://www.roblox.com/asset/?id=141313631]];
G2L["272"]["Size"] = UDim2.new(0, 24, 0, 24);
G2L["272"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["272"]["Name"] = [[HSVPicker]];
G2L["272"]["Position"] = UDim2.new(0, 70, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TintOption.HSVPicker.Shadow
G2L["273"] = Instance.new("Frame", G2L["272"]);
G2L["273"]["BorderSizePixel"] = 0;
G2L["273"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["273"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["273"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["273"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["273"]["Name"] = [[Shadow]];
G2L["273"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.SelectNote
G2L["274"] = Instance.new("TextLabel", G2L["239"]);
G2L["274"]["TextWrapped"] = true;
G2L["274"]["TextStrokeTransparency"] = 0.5;
G2L["274"]["BorderSizePixel"] = 0;
G2L["274"]["TextSize"] = 14;
G2L["274"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["274"]["TextScaled"] = true;
G2L["274"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["274"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["274"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["274"]["BackgroundTransparency"] = 1;
G2L["274"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["274"]["Visible"] = false;
G2L["274"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["274"]["Text"] = [[Select something to use this tool.]];
G2L["274"]["Name"] = [[SelectNote]];
G2L["274"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption
G2L["275"] = Instance.new("Frame", G2L["239"]);
G2L["275"]["Visible"] = false;
G2L["275"]["BorderSizePixel"] = 0;
G2L["275"]["Size"] = UDim2.new(0, 200, 0, 25);
G2L["275"]["Position"] = UDim2.new(0, 0, 0, 100);
G2L["275"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["275"]["Name"] = [[OffsetOption]];
G2L["275"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.Label
G2L["276"] = Instance.new("TextLabel", G2L["275"]);
G2L["276"]["TextWrapped"] = true;
G2L["276"]["TextStrokeTransparency"] = 0;
G2L["276"]["BorderSizePixel"] = 0;
G2L["276"]["TextSize"] = 10;
G2L["276"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["276"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["276"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["276"]["BackgroundTransparency"] = 1;
G2L["276"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["276"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["276"]["Text"] = [[Offset]];
G2L["276"]["Name"] = [[Label]];
G2L["276"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.XInput
G2L["277"] = Instance.new("Frame", G2L["275"]);
G2L["277"]["BorderSizePixel"] = 0;
G2L["277"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["277"]["Position"] = UDim2.new(0, 55, 0, 0);
G2L["277"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["277"]["Name"] = [[XInput]];
G2L["277"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.XInput.Background
G2L["278"] = Instance.new("ImageLabel", G2L["277"]);
G2L["278"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["278"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["278"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["278"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["278"]["BackgroundTransparency"] = 1;
G2L["278"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.XInput.SelectedIndicator
G2L["279"] = Instance.new("Frame", G2L["277"]);
G2L["279"]["BorderSizePixel"] = 0;
G2L["279"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["279"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["279"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["279"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["279"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.XInput.TextBox
G2L["27a"] = Instance.new("TextBox", G2L["277"]);
G2L["27a"]["BorderSizePixel"] = 0;
G2L["27a"]["TextSize"] = 10;
G2L["27a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["27a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["27a"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["27a"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["27a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27a"]["Text"] = [[1]];
G2L["27a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.YInput
G2L["27b"] = Instance.new("Frame", G2L["275"]);
G2L["27b"]["BorderSizePixel"] = 0;
G2L["27b"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["27b"]["Position"] = UDim2.new(0, 100, 0, 0);
G2L["27b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27b"]["Name"] = [[YInput]];
G2L["27b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.YInput.Background
G2L["27c"] = Instance.new("ImageLabel", G2L["27b"]);
G2L["27c"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["27c"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["27c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["27c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27c"]["BackgroundTransparency"] = 1;
G2L["27c"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.YInput.SelectedIndicator
G2L["27d"] = Instance.new("Frame", G2L["27b"]);
G2L["27d"]["BorderSizePixel"] = 0;
G2L["27d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["27d"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["27d"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["27d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27d"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.YInput.TextBox
G2L["27e"] = Instance.new("TextBox", G2L["27b"]);
G2L["27e"]["BorderSizePixel"] = 0;
G2L["27e"]["TextSize"] = 10;
G2L["27e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["27e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["27e"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["27e"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["27e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27e"]["Text"] = [[1]];
G2L["27e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.ZInput
G2L["27f"] = Instance.new("Frame", G2L["275"]);
G2L["27f"]["BorderSizePixel"] = 0;
G2L["27f"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["27f"]["Position"] = UDim2.new(0, 145, 0, 0);
G2L["27f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["27f"]["Name"] = [[ZInput]];
G2L["27f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.ZInput.Background
G2L["280"] = Instance.new("ImageLabel", G2L["27f"]);
G2L["280"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["280"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["280"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["280"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["280"]["BackgroundTransparency"] = 1;
G2L["280"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.ZInput.SelectedIndicator
G2L["281"] = Instance.new("Frame", G2L["27f"]);
G2L["281"]["BorderSizePixel"] = 0;
G2L["281"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["281"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["281"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["281"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["281"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.OffsetOption.ZInput.TextBox
G2L["282"] = Instance.new("TextBox", G2L["27f"]);
G2L["282"]["BorderSizePixel"] = 0;
G2L["282"]["TextSize"] = 10;
G2L["282"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["282"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["282"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["282"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["282"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["282"]["Text"] = [[1]];
G2L["282"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI
G2L["283"] = Instance.new("Frame", G2L["52"]);
G2L["283"]["Active"] = true;
G2L["283"]["BorderSizePixel"] = 0;
G2L["283"]["Size"] = UDim2.new(0, 245, 0, 90);
G2L["283"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["283"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["283"]["Name"] = [[BTMoveToolGUI]];
G2L["283"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Changes
G2L["284"] = Instance.new("Frame", G2L["283"]);
G2L["284"]["BorderSizePixel"] = 0;
G2L["284"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["284"]["Position"] = UDim2.new(0, 5, 1, 10);
G2L["284"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["284"]["Name"] = [[Changes]];
G2L["284"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Changes.Text
G2L["285"] = Instance.new("TextLabel", G2L["284"]);
G2L["285"]["TextWrapped"] = true;
G2L["285"]["TextStrokeTransparency"] = 0.5;
G2L["285"]["BorderSizePixel"] = 0;
G2L["285"]["TextSize"] = 10;
G2L["285"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["285"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["285"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["285"]["BackgroundTransparency"] = 1;
G2L["285"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["285"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["285"]["Text"] = [[moved 0 studs]];
G2L["285"]["Name"] = [[Text]];
G2L["285"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Changes.ColorBar
G2L["286"] = Instance.new("Frame", G2L["284"]);
G2L["286"]["BorderSizePixel"] = 0;
G2L["286"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["286"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["286"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["286"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info
G2L["287"] = Instance.new("Frame", G2L["283"]);
G2L["287"]["Visible"] = false;
G2L["287"]["BorderSizePixel"] = 0;
G2L["287"]["Size"] = UDim2.new(1, -5, 0, 60);
G2L["287"]["Position"] = UDim2.new(0, 5, 0, 100);
G2L["287"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["287"]["Name"] = [[Info]];
G2L["287"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center
G2L["288"] = Instance.new("Frame", G2L["287"]);
G2L["288"]["BorderSizePixel"] = 0;
G2L["288"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["288"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["288"]["Name"] = [[Center]];
G2L["288"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Z
G2L["289"] = Instance.new("Frame", G2L["288"]);
G2L["289"]["BorderSizePixel"] = 0;
G2L["289"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["289"]["Position"] = UDim2.new(0, 164, 0, 0);
G2L["289"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["289"]["Name"] = [[Z]];
G2L["289"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Z.Background
G2L["28a"] = Instance.new("ImageLabel", G2L["289"]);
G2L["28a"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["28a"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["28a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["28a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28a"]["BackgroundTransparency"] = 1;
G2L["28a"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Z.TextBox
G2L["28b"] = Instance.new("TextBox", G2L["289"]);
G2L["28b"]["ZIndex"] = 2;
G2L["28b"]["BorderSizePixel"] = 0;
G2L["28b"]["TextSize"] = 10;
G2L["28b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["28b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["28b"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["28b"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["28b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28b"]["Text"] = [[]];
G2L["28b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Y
G2L["28c"] = Instance.new("Frame", G2L["288"]);
G2L["28c"]["BorderSizePixel"] = 0;
G2L["28c"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["28c"]["Position"] = UDim2.new(0, 117, 0, 0);
G2L["28c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28c"]["Name"] = [[Y]];
G2L["28c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Y.TextBox
G2L["28d"] = Instance.new("TextBox", G2L["28c"]);
G2L["28d"]["ZIndex"] = 2;
G2L["28d"]["BorderSizePixel"] = 0;
G2L["28d"]["TextSize"] = 10;
G2L["28d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["28d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["28d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["28d"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["28d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28d"]["Text"] = [[]];
G2L["28d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.Y.Background
G2L["28e"] = Instance.new("ImageLabel", G2L["28c"]);
G2L["28e"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["28e"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["28e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["28e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28e"]["BackgroundTransparency"] = 1;
G2L["28e"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.X
G2L["28f"] = Instance.new("Frame", G2L["288"]);
G2L["28f"]["BorderSizePixel"] = 0;
G2L["28f"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["28f"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["28f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["28f"]["Name"] = [[X]];
G2L["28f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.X.TextBox
G2L["290"] = Instance.new("TextBox", G2L["28f"]);
G2L["290"]["ZIndex"] = 2;
G2L["290"]["BorderSizePixel"] = 0;
G2L["290"]["TextSize"] = 10;
G2L["290"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["290"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["290"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["290"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["290"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["290"]["Text"] = [[]];
G2L["290"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.X.Background
G2L["291"] = Instance.new("ImageLabel", G2L["28f"]);
G2L["291"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["291"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["291"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["291"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["291"]["BackgroundTransparency"] = 1;
G2L["291"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Center.TextLabel
G2L["292"] = Instance.new("TextLabel", G2L["288"]);
G2L["292"]["TextWrapped"] = true;
G2L["292"]["TextStrokeTransparency"] = 0;
G2L["292"]["BorderSizePixel"] = 0;
G2L["292"]["TextSize"] = 10;
G2L["292"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["292"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["292"]["BackgroundTransparency"] = 1;
G2L["292"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["292"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["292"]["Text"] = [[Position]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.Label
G2L["293"] = Instance.new("TextLabel", G2L["287"]);
G2L["293"]["TextWrapped"] = true;
G2L["293"]["TextStrokeTransparency"] = 0;
G2L["293"]["BorderSizePixel"] = 0;
G2L["293"]["TextSize"] = 10;
G2L["293"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["293"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["293"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["293"]["BackgroundTransparency"] = 1;
G2L["293"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["293"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["293"]["Text"] = [[SELECTION INFO]];
G2L["293"]["Name"] = [[Label]];
G2L["293"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Info.ColorBar
G2L["294"] = Instance.new("Frame", G2L["287"]);
G2L["294"]["BorderSizePixel"] = 0;
G2L["294"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["294"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["294"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["294"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption
G2L["295"] = Instance.new("Frame", G2L["283"]);
G2L["295"]["BorderSizePixel"] = 0;
G2L["295"]["Position"] = UDim2.new(0, 0, 0, 65);
G2L["295"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["295"]["Name"] = [[IncrementOption]];
G2L["295"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Label
G2L["296"] = Instance.new("Frame", G2L["295"]);
G2L["296"]["BorderSizePixel"] = 0;
G2L["296"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["296"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["296"]["Name"] = [[Label]];
G2L["296"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Label.TextLabel
G2L["297"] = Instance.new("TextLabel", G2L["296"]);
G2L["297"]["TextWrapped"] = true;
G2L["297"]["TextStrokeTransparency"] = 0;
G2L["297"]["BorderSizePixel"] = 0;
G2L["297"]["TextSize"] = 10;
G2L["297"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["297"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["297"]["BackgroundTransparency"] = 1;
G2L["297"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["297"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["297"]["Text"] = [[Increment]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Increment
G2L["298"] = Instance.new("Frame", G2L["295"]);
G2L["298"]["BorderSizePixel"] = 0;
G2L["298"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["298"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["298"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["298"]["Name"] = [[Increment]];
G2L["298"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Increment.Background
G2L["299"] = Instance.new("ImageLabel", G2L["298"]);
G2L["299"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["299"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["299"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["299"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["299"]["BackgroundTransparency"] = 1;
G2L["299"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Increment.TextBox
G2L["29a"] = Instance.new("TextBox", G2L["298"]);
G2L["29a"]["ZIndex"] = 2;
G2L["29a"]["BorderSizePixel"] = 0;
G2L["29a"]["TextSize"] = 10;
G2L["29a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["29a"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["29a"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["29a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29a"]["Text"] = [[1]];
G2L["29a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.IncrementOption.Increment.SelectedIndicator
G2L["29b"] = Instance.new("Frame", G2L["298"]);
G2L["29b"]["BorderSizePixel"] = 0;
G2L["29b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29b"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["29b"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["29b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29b"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Title
G2L["29c"] = Instance.new("Frame", G2L["283"]);
G2L["29c"]["BorderSizePixel"] = 0;
G2L["29c"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["29c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29c"]["Name"] = [[Title]];
G2L["29c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Title.F3XSignature
G2L["29d"] = Instance.new("TextLabel", G2L["29c"]);
G2L["29d"]["TextWrapped"] = true;
G2L["29d"]["TextStrokeTransparency"] = 0.9;
G2L["29d"]["BorderSizePixel"] = 0;
G2L["29d"]["TextSize"] = 14;
G2L["29d"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["29d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["29d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29d"]["BackgroundTransparency"] = 1;
G2L["29d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["29d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29d"]["Text"] = [[F3X]];
G2L["29d"]["Name"] = [[F3XSignature]];
G2L["29d"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Title.Label
G2L["29e"] = Instance.new("TextLabel", G2L["29c"]);
G2L["29e"]["TextWrapped"] = true;
G2L["29e"]["TextStrokeTransparency"] = 0;
G2L["29e"]["BorderSizePixel"] = 0;
G2L["29e"]["TextSize"] = 10;
G2L["29e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["29e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["29e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29e"]["BackgroundTransparency"] = 1;
G2L["29e"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["29e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29e"]["Text"] = [[MOVE TOOL]];
G2L["29e"]["Name"] = [[Label]];
G2L["29e"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.Title.ColorBar
G2L["29f"] = Instance.new("Frame", G2L["29c"]);
G2L["29f"]["BorderSizePixel"] = 0;
G2L["29f"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["29f"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["29f"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["29f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["29f"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption
G2L["2a0"] = Instance.new("Frame", G2L["283"]);
G2L["2a0"]["BorderSizePixel"] = 0;
G2L["2a0"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["2a0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a0"]["Name"] = [[AxesOption]];
G2L["2a0"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Label
G2L["2a1"] = Instance.new("Frame", G2L["2a0"]);
G2L["2a1"]["BorderSizePixel"] = 0;
G2L["2a1"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["2a1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a1"]["Name"] = [[Label]];
G2L["2a1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Label.TextLabel
G2L["2a2"] = Instance.new("TextLabel", G2L["2a1"]);
G2L["2a2"]["TextWrapped"] = true;
G2L["2a2"]["TextStrokeTransparency"] = 0;
G2L["2a2"]["BorderSizePixel"] = 0;
G2L["2a2"]["TextSize"] = 10;
G2L["2a2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2a2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a2"]["BackgroundTransparency"] = 1;
G2L["2a2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2a2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a2"]["Text"] = [[Axes]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Last
G2L["2a3"] = Instance.new("Frame", G2L["2a0"]);
G2L["2a3"]["BorderSizePixel"] = 0;
G2L["2a3"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["2a3"]["Position"] = UDim2.new(0, 175, 0, 0);
G2L["2a3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a3"]["Name"] = [[Last]];
G2L["2a3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Last.Label
G2L["2a4"] = Instance.new("TextLabel", G2L["2a3"]);
G2L["2a4"]["ZIndex"] = 2;
G2L["2a4"]["BorderSizePixel"] = 0;
G2L["2a4"]["TextSize"] = 10;
G2L["2a4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2a4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a4"]["BackgroundTransparency"] = 1;
G2L["2a4"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2a4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a4"]["Text"] = [[LAST]];
G2L["2a4"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Last.Background
G2L["2a5"] = Instance.new("ImageLabel", G2L["2a3"]);
G2L["2a5"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2a5"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["2a5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2a5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a5"]["BackgroundTransparency"] = 1;
G2L["2a5"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Last.Button
G2L["2a6"] = Instance.new("TextButton", G2L["2a3"]);
G2L["2a6"]["BorderSizePixel"] = 0;
G2L["2a6"]["TextTransparency"] = 1;
G2L["2a6"]["ZIndex"] = 2;
G2L["2a6"]["BackgroundTransparency"] = 1;
G2L["2a6"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["2a6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a6"]["Text"] = [[]];
G2L["2a6"]["Name"] = [[Button]];
G2L["2a6"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Last.SelectedIndicator
G2L["2a7"] = Instance.new("Frame", G2L["2a3"]);
G2L["2a7"]["BorderSizePixel"] = 0;
G2L["2a7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a7"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["2a7"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["2a7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a7"]["Name"] = [[SelectedIndicator]];
G2L["2a7"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Local
G2L["2a8"] = Instance.new("Frame", G2L["2a0"]);
G2L["2a8"]["BorderSizePixel"] = 0;
G2L["2a8"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["2a8"]["Position"] = UDim2.new(0, 110, 0, 0);
G2L["2a8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a8"]["Name"] = [[Local]];
G2L["2a8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Local.Label
G2L["2a9"] = Instance.new("TextLabel", G2L["2a8"]);
G2L["2a9"]["ZIndex"] = 2;
G2L["2a9"]["BorderSizePixel"] = 0;
G2L["2a9"]["TextSize"] = 10;
G2L["2a9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2a9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a9"]["BackgroundTransparency"] = 1;
G2L["2a9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2a9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2a9"]["Text"] = [[LOCAL]];
G2L["2a9"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Local.Background
G2L["2aa"] = Instance.new("ImageLabel", G2L["2a8"]);
G2L["2aa"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2aa"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["2aa"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2aa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2aa"]["BackgroundTransparency"] = 1;
G2L["2aa"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Local.Button
G2L["2ab"] = Instance.new("TextButton", G2L["2a8"]);
G2L["2ab"]["BorderSizePixel"] = 0;
G2L["2ab"]["TextTransparency"] = 1;
G2L["2ab"]["ZIndex"] = 2;
G2L["2ab"]["BackgroundTransparency"] = 1;
G2L["2ab"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["2ab"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ab"]["Text"] = [[]];
G2L["2ab"]["Name"] = [[Button]];
G2L["2ab"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Local.SelectedIndicator
G2L["2ac"] = Instance.new("Frame", G2L["2a8"]);
G2L["2ac"]["BorderSizePixel"] = 0;
G2L["2ac"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ac"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["2ac"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["2ac"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ac"]["Name"] = [[SelectedIndicator]];
G2L["2ac"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Global
G2L["2ad"] = Instance.new("Frame", G2L["2a0"]);
G2L["2ad"]["BorderSizePixel"] = 0;
G2L["2ad"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["2ad"]["Position"] = UDim2.new(0, 45, 0, 0);
G2L["2ad"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ad"]["Name"] = [[Global]];
G2L["2ad"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Global.Label
G2L["2ae"] = Instance.new("TextLabel", G2L["2ad"]);
G2L["2ae"]["ZIndex"] = 2;
G2L["2ae"]["BorderSizePixel"] = 0;
G2L["2ae"]["TextSize"] = 10;
G2L["2ae"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ae"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ae"]["BackgroundTransparency"] = 1;
G2L["2ae"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ae"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ae"]["Text"] = [[GLOBAL]];
G2L["2ae"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Global.Background
G2L["2af"] = Instance.new("ImageLabel", G2L["2ad"]);
G2L["2af"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2af"]["Image"] = [[http://www.roblox.com/asset/?id=127774197]];
G2L["2af"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2af"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2af"]["BackgroundTransparency"] = 1;
G2L["2af"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Global.Button
G2L["2b0"] = Instance.new("TextButton", G2L["2ad"]);
G2L["2b0"]["BorderSizePixel"] = 0;
G2L["2b0"]["TextTransparency"] = 1;
G2L["2b0"]["ZIndex"] = 2;
G2L["2b0"]["BackgroundTransparency"] = 1;
G2L["2b0"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["2b0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b0"]["Text"] = [[]];
G2L["2b0"]["Name"] = [[Button]];
G2L["2b0"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMoveToolGUI.AxesOption.Global.SelectedIndicator
G2L["2b1"] = Instance.new("Frame", G2L["2ad"]);
G2L["2b1"]["BorderSizePixel"] = 0;
G2L["2b1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2b1"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["2b1"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["2b1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b1"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI
G2L["2b2"] = Instance.new("Frame", G2L["52"]);
G2L["2b2"]["Active"] = true;
G2L["2b2"]["BorderSizePixel"] = 0;
G2L["2b2"]["Size"] = UDim2.new(0, 220, 0, 90);
G2L["2b2"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["2b2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b2"]["Name"] = [[BTNewPartToolGUI]];
G2L["2b2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Title
G2L["2b3"] = Instance.new("Frame", G2L["2b2"]);
G2L["2b3"]["BorderSizePixel"] = 0;
G2L["2b3"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["2b3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b3"]["Name"] = [[Title]];
G2L["2b3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Title.ColorBar
G2L["2b4"] = Instance.new("Frame", G2L["2b3"]);
G2L["2b4"]["BorderSizePixel"] = 0;
G2L["2b4"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["2b4"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["2b4"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["2b4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b4"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Title.Label
G2L["2b5"] = Instance.new("TextLabel", G2L["2b3"]);
G2L["2b5"]["TextWrapped"] = true;
G2L["2b5"]["TextStrokeTransparency"] = 0;
G2L["2b5"]["BorderSizePixel"] = 0;
G2L["2b5"]["TextSize"] = 10;
G2L["2b5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2b5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2b5"]["BackgroundTransparency"] = 1;
G2L["2b5"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["2b5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b5"]["Text"] = [[NEW PART TOOL]];
G2L["2b5"]["Name"] = [[Label]];
G2L["2b5"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Title.F3XSignature
G2L["2b6"] = Instance.new("TextLabel", G2L["2b3"]);
G2L["2b6"]["TextWrapped"] = true;
G2L["2b6"]["TextStrokeTransparency"] = 0.9;
G2L["2b6"]["BorderSizePixel"] = 0;
G2L["2b6"]["TextSize"] = 14;
G2L["2b6"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["2b6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2b6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2b6"]["BackgroundTransparency"] = 1;
G2L["2b6"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["2b6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b6"]["Text"] = [[F3X]];
G2L["2b6"]["Name"] = [[F3XSignature]];
G2L["2b6"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption
G2L["2b7"] = Instance.new("Frame", G2L["2b2"]);
G2L["2b7"]["BorderSizePixel"] = 0;
G2L["2b7"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["2b7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b7"]["Name"] = [[TypeOption]];
G2L["2b7"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Label
G2L["2b8"] = Instance.new("TextLabel", G2L["2b7"]);
G2L["2b8"]["TextWrapped"] = true;
G2L["2b8"]["TextStrokeTransparency"] = 0;
G2L["2b8"]["BorderSizePixel"] = 0;
G2L["2b8"]["TextSize"] = 10;
G2L["2b8"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2b8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2b8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2b8"]["BackgroundTransparency"] = 1;
G2L["2b8"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["2b8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b8"]["Text"] = [[Part Type]];
G2L["2b8"]["Name"] = [[Label]];
G2L["2b8"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown
G2L["2b9"] = Instance.new("TextButton", G2L["2b7"]);
G2L["2b9"]["TextStrokeTransparency"] = 0.8;
G2L["2b9"]["BorderSizePixel"] = 0;
G2L["2b9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2b9"]["TextSize"] = 10;
G2L["2b9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2b9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2b9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2b9"]["BackgroundTransparency"] = 0.3;
G2L["2b9"]["Size"] = UDim2.new(0, 140, 0, 25);
G2L["2b9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2b9"]["Text"] = [[]];
G2L["2b9"]["Name"] = [[Dropdown]];
G2L["2b9"]["Position"] = UDim2.new(0, 70, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.Icon
G2L["2ba"] = Instance.new("ImageLabel", G2L["2b9"]);
G2L["2ba"]["ZIndex"] = 3;
G2L["2ba"]["BorderSizePixel"] = 0;
G2L["2ba"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ba"]["Image"] = [[rbxassetid://134367382]];
G2L["2ba"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["2ba"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ba"]["BackgroundTransparency"] = 1;
G2L["2ba"]["Name"] = [[Icon]];
G2L["2ba"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.OptionButton
G2L["2bb"] = Instance.new("TextButton", G2L["2b9"]);
G2L["2bb"]["TextStrokeTransparency"] = 0.8;
G2L["2bb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2bb"]["TextSize"] = 10;
G2L["2bb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2bb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2bb"]["ZIndex"] = 4;
G2L["2bb"]["BackgroundTransparency"] = 0.3;
G2L["2bb"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["2bb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2bb"]["Text"] = [[]];
G2L["2bb"]["Name"] = [[OptionButton]];
G2L["2bb"]["Visible"] = false;
G2L["2bb"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.OptionButton.OptionLabel
G2L["2bc"] = Instance.new("TextLabel", G2L["2bb"]);
G2L["2bc"]["ZIndex"] = 4;
G2L["2bc"]["BorderSizePixel"] = 0;
G2L["2bc"]["TextSize"] = 10;
G2L["2bc"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2bc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2bc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bc"]["BackgroundTransparency"] = 1;
G2L["2bc"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["2bc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2bc"]["Text"] = [[ALL]];
G2L["2bc"]["Name"] = [[OptionLabel]];
G2L["2bc"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.Options
G2L["2bd"] = Instance.new("Folder", G2L["2b9"]);
G2L["2bd"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.Border
G2L["2be"] = Instance.new("Frame", G2L["2b9"]);
G2L["2be"]["BorderSizePixel"] = 0;
G2L["2be"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2be"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["2be"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["2be"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2be"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.CurrentOption
G2L["2bf"] = Instance.new("TextLabel", G2L["2b9"]);
G2L["2bf"]["ZIndex"] = 3;
G2L["2bf"]["BorderSizePixel"] = 0;
G2L["2bf"]["TextSize"] = 10;
G2L["2bf"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2bf"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bf"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2bf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bf"]["BackgroundTransparency"] = 1;
G2L["2bf"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["2bf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2bf"]["Text"] = [[]];
G2L["2bf"]["Name"] = [[CurrentOption]];
G2L["2bf"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.[Component]
G2L["2c0"] = Instance.new("LocalScript", G2L["2b9"]);
G2L["2c0"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Tip
G2L["2c1"] = Instance.new("Frame", G2L["2b2"]);
G2L["2c1"]["BorderSizePixel"] = 0;
G2L["2c1"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["2c1"]["Position"] = UDim2.new(0, 5, 0, 70);
G2L["2c1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c1"]["Name"] = [[Tip]];
G2L["2c1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Tip.ColorBar
G2L["2c2"] = Instance.new("Frame", G2L["2c1"]);
G2L["2c2"]["BorderSizePixel"] = 0;
G2L["2c2"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["2c2"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["2c2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c2"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.Tip.Text
G2L["2c3"] = Instance.new("TextLabel", G2L["2c1"]);
G2L["2c3"]["TextWrapped"] = true;
G2L["2c3"]["TextStrokeTransparency"] = 0.5;
G2L["2c3"]["BorderSizePixel"] = 0;
G2L["2c3"]["TextSize"] = 10;
G2L["2c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c3"]["BackgroundTransparency"] = 1;
G2L["2c3"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["2c3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c3"]["Text"] = [[TIP: Point and click for a new part.]];
G2L["2c3"]["Name"] = [[Text]];
G2L["2c3"]["Position"] = UDim2.new(0, 0, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI
G2L["2c4"] = Instance.new("Frame", G2L["52"]);
G2L["2c4"]["Active"] = true;
G2L["2c4"]["BorderSizePixel"] = 0;
G2L["2c4"]["Size"] = UDim2.new(0, 205, 0, 285);
G2L["2c4"]["Position"] = UDim2.new(0, 5, 0.35, 0);
G2L["2c4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c4"]["Name"] = [[BTPaintToolGUI]];
G2L["2c4"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Title
G2L["2c5"] = Instance.new("Frame", G2L["2c4"]);
G2L["2c5"]["BorderSizePixel"] = 0;
G2L["2c5"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["2c5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c5"]["Name"] = [[Title]];
G2L["2c5"]["LayoutOrder"] = 1;
G2L["2c5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Title.ColorBar
G2L["2c6"] = Instance.new("Frame", G2L["2c5"]);
G2L["2c6"]["BorderSizePixel"] = 0;
G2L["2c6"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["2c6"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["2c6"]["Position"] = UDim2.new(0, 0, 0, -3);
G2L["2c6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c6"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Title.Label
G2L["2c7"] = Instance.new("TextLabel", G2L["2c5"]);
G2L["2c7"]["TextWrapped"] = true;
G2L["2c7"]["TextStrokeTransparency"] = 0;
G2L["2c7"]["BorderSizePixel"] = 0;
G2L["2c7"]["TextSize"] = 10;
G2L["2c7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["2c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c7"]["BackgroundTransparency"] = 1;
G2L["2c7"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["2c7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c7"]["Text"] = [[PAINT TOOL]];
G2L["2c7"]["Name"] = [[Label]];
G2L["2c7"]["Position"] = UDim2.new(0, 5, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Title.F3XSignature
G2L["2c8"] = Instance.new("TextLabel", G2L["2c5"]);
G2L["2c8"]["TextWrapped"] = true;
G2L["2c8"]["TextStrokeTransparency"] = 0.9;
G2L["2c8"]["BorderSizePixel"] = 0;
G2L["2c8"]["TextSize"] = 14;
G2L["2c8"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["2c8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2c8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c8"]["BackgroundTransparency"] = 1;
G2L["2c8"]["Size"] = UDim2.new(1, -3, 0, 20);
G2L["2c8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2c8"]["Text"] = [[F3X]];
G2L["2c8"]["Name"] = [[F3XSignature]];
G2L["2c8"]["Position"] = UDim2.new(0, 0, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.UIListLayout
G2L["2c9"] = Instance.new("UIListLayout", G2L["2c4"]);
G2L["2c9"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette
G2L["2ca"] = Instance.new("Frame", G2L["2c4"]);
G2L["2ca"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ca"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2ca"]["Size"] = UDim2.new(1, 0, 0, 228);
G2L["2ca"]["Position"] = UDim2.new(0, 0, 0, 25);
G2L["2ca"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ca"]["Name"] = [[Palette]];
G2L["2ca"]["LayoutOrder"] = 2;
G2L["2ca"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.UIListLayout
G2L["2cb"] = Instance.new("UIListLayout", G2L["2ca"]);
G2L["2cb"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["2cb"]["VerticalAlignment"] = Enum.VerticalAlignment.Center;
G2L["2cb"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["2cb"]["FillDirection"] = Enum.FillDirection.Horizontal;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays
G2L["2cc"] = Instance.new("Frame", G2L["2ca"]);
G2L["2cc"]["BorderSizePixel"] = 0;
G2L["2cc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2cc"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["2cc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2cc"]["Name"] = [[Grays]];
G2L["2cc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.UIListLayout
G2L["2cd"] = Instance.new("UIListLayout", G2L["2cc"]);
G2L["2cd"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["2cd"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Institutional white
G2L["2ce"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2ce"]["TextWrapped"] = true;
G2L["2ce"]["TextStrokeTransparency"] = 0.5;
G2L["2ce"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ce"]["BorderSizePixel"] = 0;
G2L["2ce"]["Modal"] = true;
G2L["2ce"]["TextSize"] = 10;
G2L["2ce"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ce"]["BackgroundColor3"] = Color3.fromRGB(249, 249, 249);
G2L["2ce"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ce"]["ZIndex"] = 2;
G2L["2ce"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ce"]["LayoutOrder"] = 1;
G2L["2ce"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ce"]["Text"] = [[]];
G2L["2ce"]["Name"] = [[Institutional white]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.White
G2L["2cf"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2cf"]["TextWrapped"] = true;
G2L["2cf"]["TextStrokeTransparency"] = 0.5;
G2L["2cf"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2cf"]["BorderSizePixel"] = 0;
G2L["2cf"]["Modal"] = true;
G2L["2cf"]["TextSize"] = 10;
G2L["2cf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2cf"]["BackgroundColor3"] = Color3.fromRGB(243, 244, 244);
G2L["2cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2cf"]["ZIndex"] = 2;
G2L["2cf"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2cf"]["LayoutOrder"] = 2;
G2L["2cf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2cf"]["Text"] = [[]];
G2L["2cf"]["Name"] = [[White]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Light stone grey
G2L["2d0"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d0"]["TextWrapped"] = true;
G2L["2d0"]["TextStrokeTransparency"] = 0.5;
G2L["2d0"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d0"]["BorderSizePixel"] = 0;
G2L["2d0"]["Modal"] = true;
G2L["2d0"]["TextSize"] = 10;
G2L["2d0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d0"]["BackgroundColor3"] = Color3.fromRGB(230, 229, 224);
G2L["2d0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d0"]["ZIndex"] = 2;
G2L["2d0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d0"]["LayoutOrder"] = 3;
G2L["2d0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d0"]["Text"] = [[]];
G2L["2d0"]["Name"] = [[Light stone grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Lily white
G2L["2d1"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d1"]["TextWrapped"] = true;
G2L["2d1"]["TextStrokeTransparency"] = 0.5;
G2L["2d1"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d1"]["BorderSizePixel"] = 0;
G2L["2d1"]["Modal"] = true;
G2L["2d1"]["TextSize"] = 10;
G2L["2d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d1"]["BackgroundColor3"] = Color3.fromRGB(238, 235, 235);
G2L["2d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d1"]["ZIndex"] = 2;
G2L["2d1"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d1"]["LayoutOrder"] = 4;
G2L["2d1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d1"]["Text"] = [[]];
G2L["2d1"]["Name"] = [[Lily white]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Pearl
G2L["2d2"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d2"]["TextWrapped"] = true;
G2L["2d2"]["TextStrokeTransparency"] = 0.5;
G2L["2d2"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d2"]["BorderSizePixel"] = 0;
G2L["2d2"]["Modal"] = true;
G2L["2d2"]["TextSize"] = 10;
G2L["2d2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d2"]["BackgroundColor3"] = Color3.fromRGB(232, 232, 237);
G2L["2d2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d2"]["ZIndex"] = 2;
G2L["2d2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d2"]["LayoutOrder"] = 5;
G2L["2d2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d2"]["Text"] = [[]];
G2L["2d2"]["Name"] = [[Pearl]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Quill grey
G2L["2d3"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d3"]["TextWrapped"] = true;
G2L["2d3"]["TextStrokeTransparency"] = 0.5;
G2L["2d3"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d3"]["BorderSizePixel"] = 0;
G2L["2d3"]["Modal"] = true;
G2L["2d3"]["TextSize"] = 10;
G2L["2d3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d3"]["BackgroundColor3"] = Color3.fromRGB(224, 224, 223);
G2L["2d3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d3"]["ZIndex"] = 2;
G2L["2d3"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d3"]["LayoutOrder"] = 6;
G2L["2d3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d3"]["Text"] = [[]];
G2L["2d3"]["Name"] = [[Quill grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Mid gray
G2L["2d4"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d4"]["TextWrapped"] = true;
G2L["2d4"]["TextStrokeTransparency"] = 0.5;
G2L["2d4"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d4"]["BorderSizePixel"] = 0;
G2L["2d4"]["Modal"] = true;
G2L["2d4"]["TextSize"] = 10;
G2L["2d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d4"]["BackgroundColor3"] = Color3.fromRGB(206, 206, 206);
G2L["2d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d4"]["ZIndex"] = 2;
G2L["2d4"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d4"]["LayoutOrder"] = 7;
G2L["2d4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d4"]["Text"] = [[]];
G2L["2d4"]["Name"] = [[Mid gray]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Ghost grey
G2L["2d5"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d5"]["TextWrapped"] = true;
G2L["2d5"]["TextStrokeTransparency"] = 0.5;
G2L["2d5"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d5"]["BorderSizePixel"] = 0;
G2L["2d5"]["Modal"] = true;
G2L["2d5"]["TextSize"] = 10;
G2L["2d5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d5"]["BackgroundColor3"] = Color3.fromRGB(203, 204, 210);
G2L["2d5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d5"]["ZIndex"] = 2;
G2L["2d5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d5"]["LayoutOrder"] = 8;
G2L["2d5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d5"]["Text"] = [[]];
G2L["2d5"]["Name"] = [[Ghost grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Medium stone grey
G2L["2d6"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d6"]["TextWrapped"] = true;
G2L["2d6"]["TextStrokeTransparency"] = 0.5;
G2L["2d6"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d6"]["BorderSizePixel"] = 0;
G2L["2d6"]["Modal"] = true;
G2L["2d6"]["TextSize"] = 10;
G2L["2d6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d6"]["ZIndex"] = 2;
G2L["2d6"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d6"]["LayoutOrder"] = 9;
G2L["2d6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d6"]["Text"] = [[]];
G2L["2d6"]["Name"] = [[Medium stone grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Dark stone grey
G2L["2d7"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d7"]["TextWrapped"] = true;
G2L["2d7"]["TextStrokeTransparency"] = 0.5;
G2L["2d7"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d7"]["BorderSizePixel"] = 0;
G2L["2d7"]["Modal"] = true;
G2L["2d7"]["TextSize"] = 10;
G2L["2d7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d7"]["BackgroundColor3"] = Color3.fromRGB(100, 96, 99);
G2L["2d7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d7"]["ZIndex"] = 2;
G2L["2d7"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d7"]["LayoutOrder"] = 10;
G2L["2d7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d7"]["Text"] = [[]];
G2L["2d7"]["Name"] = [[Dark stone grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Black
G2L["2d8"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d8"]["TextWrapped"] = true;
G2L["2d8"]["TextStrokeTransparency"] = 0.5;
G2L["2d8"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d8"]["BorderSizePixel"] = 0;
G2L["2d8"]["Modal"] = true;
G2L["2d8"]["TextSize"] = 10;
G2L["2d8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d8"]["BackgroundColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d8"]["ZIndex"] = 2;
G2L["2d8"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d8"]["LayoutOrder"] = 11;
G2L["2d8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d8"]["Text"] = [[]];
G2L["2d8"]["Name"] = [[Black]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Grays.Really black
G2L["2d9"] = Instance.new("TextButton", G2L["2cc"]);
G2L["2d9"]["TextWrapped"] = true;
G2L["2d9"]["TextStrokeTransparency"] = 0.5;
G2L["2d9"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2d9"]["BorderSizePixel"] = 0;
G2L["2d9"]["Modal"] = true;
G2L["2d9"]["TextSize"] = 10;
G2L["2d9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d9"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["2d9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2d9"]["ZIndex"] = 2;
G2L["2d9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2d9"]["LayoutOrder"] = 12;
G2L["2d9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2d9"]["Text"] = [[]];
G2L["2d9"]["Name"] = [[Really black]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds
G2L["2da"] = Instance.new("Frame", G2L["2ca"]);
G2L["2da"]["BorderSizePixel"] = 0;
G2L["2da"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2da"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["2da"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2da"]["Name"] = [[Reds]];
G2L["2da"]["LayoutOrder"] = 2;
G2L["2da"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.UIListLayout
G2L["2db"] = Instance.new("UIListLayout", G2L["2da"]);
G2L["2db"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["2db"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Really red
G2L["2dc"] = Instance.new("TextButton", G2L["2da"]);
G2L["2dc"]["TextWrapped"] = true;
G2L["2dc"]["TextStrokeTransparency"] = 0.5;
G2L["2dc"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2dc"]["BorderSizePixel"] = 0;
G2L["2dc"]["Modal"] = true;
G2L["2dc"]["TextSize"] = 10;
G2L["2dc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2dc"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["2dc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2dc"]["ZIndex"] = 2;
G2L["2dc"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2dc"]["LayoutOrder"] = 1;
G2L["2dc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2dc"]["Text"] = [[]];
G2L["2dc"]["Name"] = [[Really red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Bright red
G2L["2dd"] = Instance.new("TextButton", G2L["2da"]);
G2L["2dd"]["TextWrapped"] = true;
G2L["2dd"]["TextStrokeTransparency"] = 0.5;
G2L["2dd"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2dd"]["BorderSizePixel"] = 0;
G2L["2dd"]["Modal"] = true;
G2L["2dd"]["TextSize"] = 10;
G2L["2dd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2dd"]["BackgroundColor3"] = Color3.fromRGB(197, 41, 29);
G2L["2dd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2dd"]["ZIndex"] = 2;
G2L["2dd"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2dd"]["LayoutOrder"] = 2;
G2L["2dd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2dd"]["Text"] = [[]];
G2L["2dd"]["Name"] = [[Bright red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Crimson
G2L["2de"] = Instance.new("TextButton", G2L["2da"]);
G2L["2de"]["TextWrapped"] = true;
G2L["2de"]["TextStrokeTransparency"] = 0.5;
G2L["2de"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2de"]["BorderSizePixel"] = 0;
G2L["2de"]["Modal"] = true;
G2L["2de"]["TextSize"] = 10;
G2L["2de"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2de"]["BackgroundColor3"] = Color3.fromRGB(152, 0, 0);
G2L["2de"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2de"]["ZIndex"] = 2;
G2L["2de"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2de"]["LayoutOrder"] = 3;
G2L["2de"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2de"]["Text"] = [[]];
G2L["2de"]["Name"] = [[Crimson]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Maroon
G2L["2df"] = Instance.new("TextButton", G2L["2da"]);
G2L["2df"]["TextWrapped"] = true;
G2L["2df"]["TextStrokeTransparency"] = 0.5;
G2L["2df"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2df"]["BorderSizePixel"] = 0;
G2L["2df"]["Modal"] = true;
G2L["2df"]["TextSize"] = 10;
G2L["2df"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2df"]["BackgroundColor3"] = Color3.fromRGB(118, 0, 0);
G2L["2df"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2df"]["ZIndex"] = 2;
G2L["2df"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2df"]["LayoutOrder"] = 4;
G2L["2df"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2df"]["Text"] = [[]];
G2L["2df"]["Name"] = [[Maroon]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Dusty Rose
G2L["2e0"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e0"]["TextWrapped"] = true;
G2L["2e0"]["TextStrokeTransparency"] = 0.5;
G2L["2e0"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e0"]["BorderSizePixel"] = 0;
G2L["2e0"]["Modal"] = true;
G2L["2e0"]["TextSize"] = 10;
G2L["2e0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e0"]["BackgroundColor3"] = Color3.fromRGB(164, 76, 76);
G2L["2e0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e0"]["ZIndex"] = 2;
G2L["2e0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e0"]["LayoutOrder"] = 5;
G2L["2e0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e0"]["Text"] = [[]];
G2L["2e0"]["Name"] = [[Dusty Rose]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Terra Cotta
G2L["2e1"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e1"]["TextWrapped"] = true;
G2L["2e1"]["TextStrokeTransparency"] = 0.5;
G2L["2e1"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e1"]["BorderSizePixel"] = 0;
G2L["2e1"]["Modal"] = true;
G2L["2e1"]["TextSize"] = 10;
G2L["2e1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e1"]["BackgroundColor3"] = Color3.fromRGB(191, 105, 99);
G2L["2e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e1"]["ZIndex"] = 2;
G2L["2e1"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e1"]["LayoutOrder"] = 6;
G2L["2e1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e1"]["Text"] = [[]];
G2L["2e1"]["Name"] = [[Terra Cotta]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Persimmon
G2L["2e2"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e2"]["TextWrapped"] = true;
G2L["2e2"]["TextStrokeTransparency"] = 0.5;
G2L["2e2"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e2"]["BorderSizePixel"] = 0;
G2L["2e2"]["Modal"] = true;
G2L["2e2"]["TextSize"] = 10;
G2L["2e2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e2"]["BackgroundColor3"] = Color3.fromRGB(255, 90, 90);
G2L["2e2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e2"]["ZIndex"] = 2;
G2L["2e2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e2"]["LayoutOrder"] = 7;
G2L["2e2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e2"]["Text"] = [[]];
G2L["2e2"]["Name"] = [[Persimmon]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Tawny
G2L["2e3"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e3"]["TextWrapped"] = true;
G2L["2e3"]["TextStrokeTransparency"] = 0.5;
G2L["2e3"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e3"]["BorderSizePixel"] = 0;
G2L["2e3"]["Modal"] = true;
G2L["2e3"]["TextSize"] = 10;
G2L["2e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e3"]["BackgroundColor3"] = Color3.fromRGB(151, 86, 86);
G2L["2e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e3"]["ZIndex"] = 2;
G2L["2e3"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e3"]["LayoutOrder"] = 8;
G2L["2e3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e3"]["Text"] = [[]];
G2L["2e3"]["Name"] = [[Tawny]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Burgundy
G2L["2e4"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e4"]["TextWrapped"] = true;
G2L["2e4"]["TextStrokeTransparency"] = 0.5;
G2L["2e4"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e4"]["BorderSizePixel"] = 0;
G2L["2e4"]["Modal"] = true;
G2L["2e4"]["TextSize"] = 10;
G2L["2e4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e4"]["BackgroundColor3"] = Color3.fromRGB(137, 63, 63);
G2L["2e4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e4"]["ZIndex"] = 2;
G2L["2e4"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e4"]["LayoutOrder"] = 9;
G2L["2e4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e4"]["Text"] = [[]];
G2L["2e4"]["Name"] = [[Burgundy]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Reds.Cocoa
G2L["2e5"] = Instance.new("TextButton", G2L["2da"]);
G2L["2e5"]["TextWrapped"] = true;
G2L["2e5"]["TextStrokeTransparency"] = 0.5;
G2L["2e5"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e5"]["BorderSizePixel"] = 0;
G2L["2e5"]["Modal"] = true;
G2L["2e5"]["TextSize"] = 10;
G2L["2e5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e5"]["BackgroundColor3"] = Color3.fromRGB(87, 37, 37);
G2L["2e5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e5"]["ZIndex"] = 2;
G2L["2e5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e5"]["LayoutOrder"] = 10;
G2L["2e5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e5"]["Text"] = [[]];
G2L["2e5"]["Name"] = [[Cocoa]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows
G2L["2e6"] = Instance.new("Frame", G2L["2ca"]);
G2L["2e6"]["BorderSizePixel"] = 0;
G2L["2e6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e6"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["2e6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e6"]["Name"] = [[Yellows]];
G2L["2e6"]["LayoutOrder"] = 3;
G2L["2e6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.UIListLayout
G2L["2e7"] = Instance.new("UIListLayout", G2L["2e6"]);
G2L["2e7"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["2e7"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.New Yeller
G2L["2e8"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2e8"]["TextWrapped"] = true;
G2L["2e8"]["TextStrokeTransparency"] = 0.5;
G2L["2e8"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e8"]["BorderSizePixel"] = 0;
G2L["2e8"]["Modal"] = true;
G2L["2e8"]["TextSize"] = 10;
G2L["2e8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 0);
G2L["2e8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e8"]["ZIndex"] = 2;
G2L["2e8"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e8"]["LayoutOrder"] = 1;
G2L["2e8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e8"]["Text"] = [[]];
G2L["2e8"]["Name"] = [[New Yeller]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Bright yellow
G2L["2e9"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2e9"]["TextWrapped"] = true;
G2L["2e9"]["TextStrokeTransparency"] = 0.5;
G2L["2e9"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2e9"]["BorderSizePixel"] = 0;
G2L["2e9"]["Modal"] = true;
G2L["2e9"]["TextSize"] = 10;
G2L["2e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e9"]["BackgroundColor3"] = Color3.fromRGB(246, 206, 49);
G2L["2e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2e9"]["ZIndex"] = 2;
G2L["2e9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2e9"]["LayoutOrder"] = 2;
G2L["2e9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2e9"]["Text"] = [[]];
G2L["2e9"]["Name"] = [[Bright yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Deep orange
G2L["2ea"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2ea"]["TextWrapped"] = true;
G2L["2ea"]["TextStrokeTransparency"] = 0.5;
G2L["2ea"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ea"]["BorderSizePixel"] = 0;
G2L["2ea"]["Modal"] = true;
G2L["2ea"]["TextSize"] = 10;
G2L["2ea"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ea"]["BackgroundColor3"] = Color3.fromRGB(255, 176, 0);
G2L["2ea"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ea"]["ZIndex"] = 2;
G2L["2ea"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ea"]["LayoutOrder"] = 3;
G2L["2ea"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ea"]["Text"] = [[]];
G2L["2ea"]["Name"] = [[Deep orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Gold
G2L["2eb"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2eb"]["TextWrapped"] = true;
G2L["2eb"]["TextStrokeTransparency"] = 0.5;
G2L["2eb"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2eb"]["BorderSizePixel"] = 0;
G2L["2eb"]["Modal"] = true;
G2L["2eb"]["TextSize"] = 10;
G2L["2eb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2eb"]["BackgroundColor3"] = Color3.fromRGB(240, 185, 57);
G2L["2eb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2eb"]["ZIndex"] = 2;
G2L["2eb"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2eb"]["LayoutOrder"] = 4;
G2L["2eb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2eb"]["Text"] = [[]];
G2L["2eb"]["Name"] = [[Gold]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Neon orange
G2L["2ec"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2ec"]["TextWrapped"] = true;
G2L["2ec"]["TextStrokeTransparency"] = 0.5;
G2L["2ec"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ec"]["BorderSizePixel"] = 0;
G2L["2ec"]["Modal"] = true;
G2L["2ec"]["TextSize"] = 10;
G2L["2ec"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ec"]["BackgroundColor3"] = Color3.fromRGB(214, 116, 62);
G2L["2ec"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ec"]["ZIndex"] = 2;
G2L["2ec"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ec"]["LayoutOrder"] = 5;
G2L["2ec"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ec"]["Text"] = [[]];
G2L["2ec"]["Name"] = [[Neon orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Bright orange
G2L["2ed"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2ed"]["TextWrapped"] = true;
G2L["2ed"]["TextStrokeTransparency"] = 0.5;
G2L["2ed"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ed"]["BorderSizePixel"] = 0;
G2L["2ed"]["Modal"] = true;
G2L["2ed"]["TextSize"] = 10;
G2L["2ed"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ed"]["BackgroundColor3"] = Color3.fromRGB(219, 134, 66);
G2L["2ed"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ed"]["ZIndex"] = 2;
G2L["2ed"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ed"]["LayoutOrder"] = 6;
G2L["2ed"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ed"]["Text"] = [[]];
G2L["2ed"]["Name"] = [[Bright orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Br. yellowish orange
G2L["2ee"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2ee"]["TextWrapped"] = true;
G2L["2ee"]["TextStrokeTransparency"] = 0.5;
G2L["2ee"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ee"]["BorderSizePixel"] = 0;
G2L["2ee"]["Modal"] = true;
G2L["2ee"]["TextSize"] = 10;
G2L["2ee"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ee"]["BackgroundColor3"] = Color3.fromRGB(227, 156, 65);
G2L["2ee"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ee"]["ZIndex"] = 2;
G2L["2ee"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ee"]["LayoutOrder"] = 7;
G2L["2ee"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ee"]["Text"] = [[]];
G2L["2ee"]["Name"] = [[Br. yellowish orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Daisy orange
G2L["2ef"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2ef"]["TextWrapped"] = true;
G2L["2ef"]["TextStrokeTransparency"] = 0.5;
G2L["2ef"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ef"]["BorderSizePixel"] = 0;
G2L["2ef"]["Modal"] = true;
G2L["2ef"]["TextSize"] = 10;
G2L["2ef"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ef"]["BackgroundColor3"] = Color3.fromRGB(249, 218, 110);
G2L["2ef"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ef"]["ZIndex"] = 2;
G2L["2ef"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ef"]["LayoutOrder"] = 8;
G2L["2ef"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ef"]["Text"] = [[]];
G2L["2ef"]["Name"] = [[Daisy orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Cool yellow
G2L["2f0"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2f0"]["TextWrapped"] = true;
G2L["2f0"]["TextStrokeTransparency"] = 0.5;
G2L["2f0"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f0"]["BorderSizePixel"] = 0;
G2L["2f0"]["Modal"] = true;
G2L["2f0"]["TextSize"] = 10;
G2L["2f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f0"]["BackgroundColor3"] = Color3.fromRGB(254, 235, 142);
G2L["2f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f0"]["ZIndex"] = 2;
G2L["2f0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f0"]["LayoutOrder"] = 9;
G2L["2f0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f0"]["Text"] = [[]];
G2L["2f0"]["Name"] = [[Cool yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Buttermilk
G2L["2f1"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2f1"]["TextWrapped"] = true;
G2L["2f1"]["TextStrokeTransparency"] = 0.5;
G2L["2f1"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f1"]["BorderSizePixel"] = 0;
G2L["2f1"]["Modal"] = true;
G2L["2f1"]["TextSize"] = 10;
G2L["2f1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f1"]["BackgroundColor3"] = Color3.fromRGB(255, 244, 188);
G2L["2f1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f1"]["ZIndex"] = 2;
G2L["2f1"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f1"]["LayoutOrder"] = 10;
G2L["2f1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f1"]["Text"] = [[]];
G2L["2f1"]["Name"] = [[Buttermilk]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Yellows.Pastel yellow
G2L["2f2"] = Instance.new("TextButton", G2L["2e6"]);
G2L["2f2"]["TextWrapped"] = true;
G2L["2f2"]["TextStrokeTransparency"] = 0.5;
G2L["2f2"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f2"]["BorderSizePixel"] = 0;
G2L["2f2"]["Modal"] = true;
G2L["2f2"]["TextSize"] = 10;
G2L["2f2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 205);
G2L["2f2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f2"]["ZIndex"] = 2;
G2L["2f2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f2"]["LayoutOrder"] = 11;
G2L["2f2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f2"]["Text"] = [[]];
G2L["2f2"]["Name"] = [[Pastel yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens
G2L["2f3"] = Instance.new("Frame", G2L["2ca"]);
G2L["2f3"]["BorderSizePixel"] = 0;
G2L["2f3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f3"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["2f3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f3"]["Name"] = [[Greens]];
G2L["2f3"]["LayoutOrder"] = 4;
G2L["2f3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.UIListLayout
G2L["2f4"] = Instance.new("UIListLayout", G2L["2f3"]);
G2L["2f4"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["2f4"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Lime green
G2L["2f5"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2f5"]["TextWrapped"] = true;
G2L["2f5"]["TextStrokeTransparency"] = 0.5;
G2L["2f5"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f5"]["BorderSizePixel"] = 0;
G2L["2f5"]["Modal"] = true;
G2L["2f5"]["TextSize"] = 10;
G2L["2f5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f5"]["BackgroundColor3"] = Color3.fromRGB(0, 255, 0);
G2L["2f5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f5"]["ZIndex"] = 2;
G2L["2f5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f5"]["LayoutOrder"] = 1;
G2L["2f5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f5"]["Text"] = [[]];
G2L["2f5"]["Name"] = [[Lime green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Shamrock
G2L["2f6"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2f6"]["TextWrapped"] = true;
G2L["2f6"]["TextStrokeTransparency"] = 0.5;
G2L["2f6"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f6"]["BorderSizePixel"] = 0;
G2L["2f6"]["Modal"] = true;
G2L["2f6"]["TextSize"] = 10;
G2L["2f6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f6"]["BackgroundColor3"] = Color3.fromRGB(92, 155, 77);
G2L["2f6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f6"]["ZIndex"] = 2;
G2L["2f6"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f6"]["LayoutOrder"] = 2;
G2L["2f6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f6"]["Text"] = [[]];
G2L["2f6"]["Name"] = [[Shamrock]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Bright green
G2L["2f7"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2f7"]["TextWrapped"] = true;
G2L["2f7"]["TextStrokeTransparency"] = 0.5;
G2L["2f7"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f7"]["BorderSizePixel"] = 0;
G2L["2f7"]["Modal"] = true;
G2L["2f7"]["TextSize"] = 10;
G2L["2f7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f7"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["2f7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f7"]["ZIndex"] = 2;
G2L["2f7"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f7"]["LayoutOrder"] = 3;
G2L["2f7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f7"]["Text"] = [[]];
G2L["2f7"]["Name"] = [[Bright green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Sea green
G2L["2f8"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2f8"]["TextWrapped"] = true;
G2L["2f8"]["TextStrokeTransparency"] = 0.5;
G2L["2f8"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f8"]["BorderSizePixel"] = 0;
G2L["2f8"]["Modal"] = true;
G2L["2f8"]["TextSize"] = 10;
G2L["2f8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f8"]["BackgroundColor3"] = Color3.fromRGB(53, 143, 65);
G2L["2f8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f8"]["ZIndex"] = 2;
G2L["2f8"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f8"]["LayoutOrder"] = 4;
G2L["2f8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f8"]["Text"] = [[]];
G2L["2f8"]["Name"] = [[Sea green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Dark green
G2L["2f9"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2f9"]["TextWrapped"] = true;
G2L["2f9"]["TextStrokeTransparency"] = 0.5;
G2L["2f9"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2f9"]["BorderSizePixel"] = 0;
G2L["2f9"]["Modal"] = true;
G2L["2f9"]["TextSize"] = 10;
G2L["2f9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f9"]["BackgroundColor3"] = Color3.fromRGB(41, 128, 72);
G2L["2f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2f9"]["ZIndex"] = 2;
G2L["2f9"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2f9"]["LayoutOrder"] = 5;
G2L["2f9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2f9"]["Text"] = [[]];
G2L["2f9"]["Name"] = [[Dark green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Forest green
G2L["2fa"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2fa"]["TextWrapped"] = true;
G2L["2fa"]["TextStrokeTransparency"] = 0.5;
G2L["2fa"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2fa"]["BorderSizePixel"] = 0;
G2L["2fa"]["Modal"] = true;
G2L["2fa"]["TextSize"] = 10;
G2L["2fa"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fa"]["BackgroundColor3"] = Color3.fromRGB(32, 129, 30);
G2L["2fa"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2fa"]["ZIndex"] = 2;
G2L["2fa"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2fa"]["LayoutOrder"] = 6;
G2L["2fa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2fa"]["Text"] = [[]];
G2L["2fa"]["Name"] = [[Forest green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Camo
G2L["2fb"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2fb"]["TextWrapped"] = true;
G2L["2fb"]["TextStrokeTransparency"] = 0.5;
G2L["2fb"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2fb"]["BorderSizePixel"] = 0;
G2L["2fb"]["Modal"] = true;
G2L["2fb"]["TextSize"] = 10;
G2L["2fb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fb"]["BackgroundColor3"] = Color3.fromRGB(59, 126, 22);
G2L["2fb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2fb"]["ZIndex"] = 2;
G2L["2fb"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2fb"]["LayoutOrder"] = 7;
G2L["2fb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2fb"]["Text"] = [[]];
G2L["2fb"]["Name"] = [[Camo]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Parsley green
G2L["2fc"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2fc"]["TextWrapped"] = true;
G2L["2fc"]["TextStrokeTransparency"] = 0.5;
G2L["2fc"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2fc"]["BorderSizePixel"] = 0;
G2L["2fc"]["Modal"] = true;
G2L["2fc"]["TextSize"] = 10;
G2L["2fc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fc"]["BackgroundColor3"] = Color3.fromRGB(45, 102, 30);
G2L["2fc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2fc"]["ZIndex"] = 2;
G2L["2fc"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2fc"]["LayoutOrder"] = 8;
G2L["2fc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2fc"]["Text"] = [[]];
G2L["2fc"]["Name"] = [[Parsley green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Earth green
G2L["2fd"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2fd"]["TextWrapped"] = true;
G2L["2fd"]["TextStrokeTransparency"] = 0.5;
G2L["2fd"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2fd"]["BorderSizePixel"] = 0;
G2L["2fd"]["Modal"] = true;
G2L["2fd"]["TextSize"] = 10;
G2L["2fd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fd"]["BackgroundColor3"] = Color3.fromRGB(40, 71, 46);
G2L["2fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2fd"]["ZIndex"] = 2;
G2L["2fd"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2fd"]["LayoutOrder"] = 9;
G2L["2fd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2fd"]["Text"] = [[]];
G2L["2fd"]["Name"] = [[Earth green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Moss
G2L["2fe"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2fe"]["TextWrapped"] = true;
G2L["2fe"]["TextStrokeTransparency"] = 0.5;
G2L["2fe"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2fe"]["BorderSizePixel"] = 0;
G2L["2fe"]["Modal"] = true;
G2L["2fe"]["TextSize"] = 10;
G2L["2fe"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fe"]["BackgroundColor3"] = Color3.fromRGB(125, 157, 108);
G2L["2fe"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2fe"]["ZIndex"] = 2;
G2L["2fe"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2fe"]["LayoutOrder"] = 10;
G2L["2fe"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2fe"]["Text"] = [[]];
G2L["2fe"]["Name"] = [[Moss]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Laurel green
G2L["2ff"] = Instance.new("TextButton", G2L["2f3"]);
G2L["2ff"]["TextWrapped"] = true;
G2L["2ff"]["TextStrokeTransparency"] = 0.5;
G2L["2ff"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["2ff"]["BorderSizePixel"] = 0;
G2L["2ff"]["Modal"] = true;
G2L["2ff"]["TextSize"] = 10;
G2L["2ff"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2ff"]["BackgroundColor3"] = Color3.fromRGB(169, 190, 154);
G2L["2ff"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2ff"]["ZIndex"] = 2;
G2L["2ff"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2ff"]["LayoutOrder"] = 11;
G2L["2ff"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["2ff"]["Text"] = [[]];
G2L["2ff"]["Name"] = [[Laurel green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Greens.Sage green
G2L["300"] = Instance.new("TextButton", G2L["2f3"]);
G2L["300"]["TextWrapped"] = true;
G2L["300"]["TextStrokeTransparency"] = 0.5;
G2L["300"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["300"]["BorderSizePixel"] = 0;
G2L["300"]["Modal"] = true;
G2L["300"]["TextSize"] = 10;
G2L["300"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["300"]["BackgroundColor3"] = Color3.fromRGB(186, 197, 178);
G2L["300"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["300"]["ZIndex"] = 2;
G2L["300"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["300"]["LayoutOrder"] = 12;
G2L["300"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["300"]["Text"] = [[]];
G2L["300"]["Name"] = [[Sage green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens
G2L["301"] = Instance.new("Frame", G2L["2ca"]);
G2L["301"]["BorderSizePixel"] = 0;
G2L["301"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["301"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["301"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["301"]["Name"] = [[LightGreens]];
G2L["301"]["LayoutOrder"] = 5;
G2L["301"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.UIListLayout
G2L["302"] = Instance.new("UIListLayout", G2L["301"]);
G2L["302"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["302"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Pastel green
G2L["303"] = Instance.new("TextButton", G2L["301"]);
G2L["303"]["TextWrapped"] = true;
G2L["303"]["TextStrokeTransparency"] = 0.5;
G2L["303"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["303"]["BorderSizePixel"] = 0;
G2L["303"]["Modal"] = true;
G2L["303"]["TextSize"] = 10;
G2L["303"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["303"]["BackgroundColor3"] = Color3.fromRGB(205, 255, 205);
G2L["303"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["303"]["ZIndex"] = 2;
G2L["303"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["303"]["LayoutOrder"] = 1;
G2L["303"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["303"]["Text"] = [[]];
G2L["303"]["Name"] = [[Pastel green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Mint
G2L["304"] = Instance.new("TextButton", G2L["301"]);
G2L["304"]["TextWrapped"] = true;
G2L["304"]["TextStrokeTransparency"] = 0.5;
G2L["304"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["304"]["BorderSizePixel"] = 0;
G2L["304"]["Modal"] = true;
G2L["304"]["TextSize"] = 10;
G2L["304"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["304"]["BackgroundColor3"] = Color3.fromRGB(178, 230, 167);
G2L["304"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["304"]["ZIndex"] = 2;
G2L["304"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["304"]["LayoutOrder"] = 2;
G2L["304"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["304"]["Text"] = [[]];
G2L["304"]["Name"] = [[Mint]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Medium green
G2L["305"] = Instance.new("TextButton", G2L["301"]);
G2L["305"]["TextWrapped"] = true;
G2L["305"]["TextStrokeTransparency"] = 0.5;
G2L["305"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["305"]["BorderSizePixel"] = 0;
G2L["305"]["Modal"] = true;
G2L["305"]["TextSize"] = 10;
G2L["305"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["305"]["BackgroundColor3"] = Color3.fromRGB(162, 197, 141);
G2L["305"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["305"]["ZIndex"] = 2;
G2L["305"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["305"]["LayoutOrder"] = 3;
G2L["305"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["305"]["Text"] = [[]];
G2L["305"]["Name"] = [[Medium green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Olivine
G2L["306"] = Instance.new("TextButton", G2L["301"]);
G2L["306"]["TextWrapped"] = true;
G2L["306"]["TextStrokeTransparency"] = 0.5;
G2L["306"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["306"]["BorderSizePixel"] = 0;
G2L["306"]["Modal"] = true;
G2L["306"]["TextSize"] = 10;
G2L["306"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["306"]["BackgroundColor3"] = Color3.fromRGB(149, 191, 130);
G2L["306"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["306"]["ZIndex"] = 2;
G2L["306"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["306"]["LayoutOrder"] = 4;
G2L["306"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["306"]["Text"] = [[]];
G2L["306"]["Name"] = [[Olivine]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Artichoke
G2L["307"] = Instance.new("TextButton", G2L["301"]);
G2L["307"]["TextWrapped"] = true;
G2L["307"]["TextStrokeTransparency"] = 0.5;
G2L["307"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["307"]["BorderSizePixel"] = 0;
G2L["307"]["Modal"] = true;
G2L["307"]["TextSize"] = 10;
G2L["307"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["307"]["BackgroundColor3"] = Color3.fromRGB(139, 172, 134);
G2L["307"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["307"]["ZIndex"] = 2;
G2L["307"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["307"]["LayoutOrder"] = 5;
G2L["307"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["307"]["Text"] = [[]];
G2L["307"]["Name"] = [[Artichoke]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Br. yellowish green
G2L["308"] = Instance.new("TextButton", G2L["301"]);
G2L["308"]["TextWrapped"] = true;
G2L["308"]["TextStrokeTransparency"] = 0.5;
G2L["308"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["308"]["BorderSizePixel"] = 0;
G2L["308"]["Modal"] = true;
G2L["308"]["TextSize"] = 10;
G2L["308"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["308"]["BackgroundColor3"] = Color3.fromRGB(165, 190, 72);
G2L["308"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["308"]["ZIndex"] = 2;
G2L["308"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["308"]["LayoutOrder"] = 6;
G2L["308"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["308"]["Text"] = [[]];
G2L["308"]["Name"] = [[Br. yellowish green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Olive
G2L["309"] = Instance.new("TextButton", G2L["301"]);
G2L["309"]["TextWrapped"] = true;
G2L["309"]["TextStrokeTransparency"] = 0.5;
G2L["309"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["309"]["BorderSizePixel"] = 0;
G2L["309"]["Modal"] = true;
G2L["309"]["TextSize"] = 10;
G2L["309"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["309"]["BackgroundColor3"] = Color3.fromRGB(194, 191, 67);
G2L["309"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["309"]["ZIndex"] = 2;
G2L["309"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["309"]["LayoutOrder"] = 7;
G2L["309"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["309"]["Text"] = [[]];
G2L["309"]["Name"] = [[Olive]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Grime
G2L["30a"] = Instance.new("TextButton", G2L["301"]);
G2L["30a"]["TextWrapped"] = true;
G2L["30a"]["TextStrokeTransparency"] = 0.5;
G2L["30a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["30a"]["BorderSizePixel"] = 0;
G2L["30a"]["Modal"] = true;
G2L["30a"]["TextSize"] = 10;
G2L["30a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30a"]["BackgroundColor3"] = Color3.fromRGB(128, 143, 101);
G2L["30a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["30a"]["ZIndex"] = 2;
G2L["30a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["30a"]["LayoutOrder"] = 8;
G2L["30a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["30a"]["Text"] = [[]];
G2L["30a"]["Name"] = [[Grime]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Sand green
G2L["30b"] = Instance.new("TextButton", G2L["301"]);
G2L["30b"]["TextWrapped"] = true;
G2L["30b"]["TextStrokeTransparency"] = 0.5;
G2L["30b"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["30b"]["BorderSizePixel"] = 0;
G2L["30b"]["Modal"] = true;
G2L["30b"]["TextSize"] = 10;
G2L["30b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30b"]["BackgroundColor3"] = Color3.fromRGB(121, 145, 131);
G2L["30b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["30b"]["ZIndex"] = 2;
G2L["30b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["30b"]["LayoutOrder"] = 9;
G2L["30b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["30b"]["Text"] = [[]];
G2L["30b"]["Name"] = [[Sand green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Slime green
G2L["30c"] = Instance.new("TextButton", G2L["301"]);
G2L["30c"]["TextWrapped"] = true;
G2L["30c"]["TextStrokeTransparency"] = 0.5;
G2L["30c"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["30c"]["BorderSizePixel"] = 0;
G2L["30c"]["Modal"] = true;
G2L["30c"]["TextSize"] = 10;
G2L["30c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30c"]["BackgroundColor3"] = Color3.fromRGB(81, 110, 85);
G2L["30c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["30c"]["ZIndex"] = 2;
G2L["30c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["30c"]["LayoutOrder"] = 10;
G2L["30c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["30c"]["Text"] = [[]];
G2L["30c"]["Name"] = [[Slime green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.LightGreens.Flint
G2L["30d"] = Instance.new("TextButton", G2L["301"]);
G2L["30d"]["TextWrapped"] = true;
G2L["30d"]["TextStrokeTransparency"] = 0.5;
G2L["30d"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["30d"]["BorderSizePixel"] = 0;
G2L["30d"]["Modal"] = true;
G2L["30d"]["TextSize"] = 10;
G2L["30d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30d"]["BackgroundColor3"] = Color3.fromRGB(106, 103, 93);
G2L["30d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["30d"]["ZIndex"] = 2;
G2L["30d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["30d"]["LayoutOrder"] = 11;
G2L["30d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["30d"]["Text"] = [[]];
G2L["30d"]["Name"] = [[Flint]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues
G2L["30e"] = Instance.new("Frame", G2L["2ca"]);
G2L["30e"]["BorderSizePixel"] = 0;
G2L["30e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30e"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["30e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["30e"]["Name"] = [[GreenishBlues]];
G2L["30e"]["LayoutOrder"] = 6;
G2L["30e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.UIListLayout
G2L["30f"] = Instance.new("UIListLayout", G2L["30e"]);
G2L["30f"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["30f"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Toothpaste
G2L["310"] = Instance.new("TextButton", G2L["30e"]);
G2L["310"]["TextWrapped"] = true;
G2L["310"]["TextStrokeTransparency"] = 0.5;
G2L["310"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["310"]["BorderSizePixel"] = 0;
G2L["310"]["Modal"] = true;
G2L["310"]["TextSize"] = 10;
G2L["310"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["310"]["BackgroundColor3"] = Color3.fromRGB(0, 255, 255);
G2L["310"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["310"]["ZIndex"] = 2;
G2L["310"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["310"]["LayoutOrder"] = 1;
G2L["310"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["310"]["Text"] = [[]];
G2L["310"]["Name"] = [[Toothpaste]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Teal
G2L["311"] = Instance.new("TextButton", G2L["30e"]);
G2L["311"]["TextWrapped"] = true;
G2L["311"]["TextStrokeTransparency"] = 0.5;
G2L["311"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["311"]["BorderSizePixel"] = 0;
G2L["311"]["Modal"] = true;
G2L["311"]["TextSize"] = 10;
G2L["311"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["311"]["BackgroundColor3"] = Color3.fromRGB(19, 239, 213);
G2L["311"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["311"]["ZIndex"] = 2;
G2L["311"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["311"]["LayoutOrder"] = 2;
G2L["311"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["311"]["Text"] = [[]];
G2L["311"]["Name"] = [[Teal]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Pastel blue-green
G2L["312"] = Instance.new("TextButton", G2L["30e"]);
G2L["312"]["TextWrapped"] = true;
G2L["312"]["TextStrokeTransparency"] = 0.5;
G2L["312"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["312"]["BorderSizePixel"] = 0;
G2L["312"]["Modal"] = true;
G2L["312"]["TextSize"] = 10;
G2L["312"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["312"]["BackgroundColor3"] = Color3.fromRGB(160, 244, 234);
G2L["312"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["312"]["ZIndex"] = 2;
G2L["312"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["312"]["LayoutOrder"] = 3;
G2L["312"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["312"]["Text"] = [[]];
G2L["312"]["Name"] = [[Pastel blue-green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Pastel light blue
G2L["313"] = Instance.new("TextButton", G2L["30e"]);
G2L["313"]["TextWrapped"] = true;
G2L["313"]["TextStrokeTransparency"] = 0.5;
G2L["313"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["313"]["BorderSizePixel"] = 0;
G2L["313"]["Modal"] = true;
G2L["313"]["TextSize"] = 10;
G2L["313"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["313"]["BackgroundColor3"] = Color3.fromRGB(176, 222, 255);
G2L["313"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["313"]["ZIndex"] = 2;
G2L["313"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["313"]["LayoutOrder"] = 4;
G2L["313"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["313"]["Text"] = [[]];
G2L["313"]["Name"] = [[Pastel light blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Light blue
G2L["314"] = Instance.new("TextButton", G2L["30e"]);
G2L["314"]["TextWrapped"] = true;
G2L["314"]["TextStrokeTransparency"] = 0.5;
G2L["314"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["314"]["BorderSizePixel"] = 0;
G2L["314"]["Modal"] = true;
G2L["314"]["TextSize"] = 10;
G2L["314"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["314"]["BackgroundColor3"] = Color3.fromRGB(181, 211, 229);
G2L["314"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["314"]["ZIndex"] = 2;
G2L["314"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["314"]["LayoutOrder"] = 5;
G2L["314"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["314"]["Text"] = [[]];
G2L["314"]["Name"] = [[Light blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Fog
G2L["315"] = Instance.new("TextButton", G2L["30e"]);
G2L["315"]["TextWrapped"] = true;
G2L["315"]["TextStrokeTransparency"] = 0.5;
G2L["315"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["315"]["BorderSizePixel"] = 0;
G2L["315"]["Modal"] = true;
G2L["315"]["TextSize"] = 10;
G2L["315"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["315"]["BackgroundColor3"] = Color3.fromRGB(200, 213, 229);
G2L["315"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["315"]["ZIndex"] = 2;
G2L["315"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["315"]["LayoutOrder"] = 6;
G2L["315"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["315"]["Text"] = [[]];
G2L["315"]["Name"] = [[Fog]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Cadet blue
G2L["316"] = Instance.new("TextButton", G2L["30e"]);
G2L["316"]["TextWrapped"] = true;
G2L["316"]["TextStrokeTransparency"] = 0.5;
G2L["316"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["316"]["BorderSizePixel"] = 0;
G2L["316"]["Modal"] = true;
G2L["316"]["TextSize"] = 10;
G2L["316"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["316"]["BackgroundColor3"] = Color3.fromRGB(160, 174, 193);
G2L["316"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["316"]["ZIndex"] = 2;
G2L["316"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["316"]["LayoutOrder"] = 7;
G2L["316"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["316"]["Text"] = [[]];
G2L["316"]["Name"] = [[Cadet blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Fossil
G2L["317"] = Instance.new("TextButton", G2L["30e"]);
G2L["317"]["TextWrapped"] = true;
G2L["317"]["TextStrokeTransparency"] = 0.5;
G2L["317"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["317"]["BorderSizePixel"] = 0;
G2L["317"]["Modal"] = true;
G2L["317"]["TextSize"] = 10;
G2L["317"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["317"]["BackgroundColor3"] = Color3.fromRGB(160, 162, 173);
G2L["317"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["317"]["ZIndex"] = 2;
G2L["317"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["317"]["LayoutOrder"] = 8;
G2L["317"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["317"]["Text"] = [[]];
G2L["317"]["Name"] = [[Fossil]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Pastel Blue
G2L["318"] = Instance.new("TextButton", G2L["30e"]);
G2L["318"]["TextWrapped"] = true;
G2L["318"]["TextStrokeTransparency"] = 0.5;
G2L["318"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["318"]["BorderSizePixel"] = 0;
G2L["318"]["Modal"] = true;
G2L["318"]["TextSize"] = 10;
G2L["318"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["318"]["BackgroundColor3"] = Color3.fromRGB(129, 188, 220);
G2L["318"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["318"]["ZIndex"] = 2;
G2L["318"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["318"]["LayoutOrder"] = 9;
G2L["318"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["318"]["Text"] = [[]];
G2L["318"]["Name"] = [[Pastel Blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Baby blue
G2L["319"] = Instance.new("TextButton", G2L["30e"]);
G2L["319"]["TextWrapped"] = true;
G2L["319"]["TextStrokeTransparency"] = 0.5;
G2L["319"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["319"]["BorderSizePixel"] = 0;
G2L["319"]["Modal"] = true;
G2L["319"]["TextSize"] = 10;
G2L["319"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["319"]["BackgroundColor3"] = Color3.fromRGB(153, 195, 220);
G2L["319"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["319"]["ZIndex"] = 2;
G2L["319"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["319"]["LayoutOrder"] = 10;
G2L["319"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["319"]["Text"] = [[]];
G2L["319"]["Name"] = [[Baby blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Sand blue
G2L["31a"] = Instance.new("TextButton", G2L["30e"]);
G2L["31a"]["TextWrapped"] = true;
G2L["31a"]["TextStrokeTransparency"] = 0.5;
G2L["31a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["31a"]["BorderSizePixel"] = 0;
G2L["31a"]["Modal"] = true;
G2L["31a"]["TextSize"] = 10;
G2L["31a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31a"]["BackgroundColor3"] = Color3.fromRGB(117, 135, 158);
G2L["31a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["31a"]["ZIndex"] = 2;
G2L["31a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["31a"]["LayoutOrder"] = 11;
G2L["31a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["31a"]["Text"] = [[]];
G2L["31a"]["Name"] = [[Sand blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.GreenishBlues.Smoky grey
G2L["31b"] = Instance.new("TextButton", G2L["30e"]);
G2L["31b"]["TextWrapped"] = true;
G2L["31b"]["TextStrokeTransparency"] = 0.5;
G2L["31b"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["31b"]["BorderSizePixel"] = 0;
G2L["31b"]["Modal"] = true;
G2L["31b"]["TextSize"] = 10;
G2L["31b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31b"]["BackgroundColor3"] = Color3.fromRGB(92, 94, 106);
G2L["31b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["31b"]["ZIndex"] = 2;
G2L["31b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["31b"]["LayoutOrder"] = 12;
G2L["31b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["31b"]["Text"] = [[]];
G2L["31b"]["Name"] = [[Smoky grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues
G2L["31c"] = Instance.new("Frame", G2L["2ca"]);
G2L["31c"]["BorderSizePixel"] = 0;
G2L["31c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31c"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["31c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["31c"]["Name"] = [[Blues]];
G2L["31c"]["LayoutOrder"] = 7;
G2L["31c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.UIListLayout
G2L["31d"] = Instance.new("UIListLayout", G2L["31c"]);
G2L["31d"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["31d"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Really blue
G2L["31e"] = Instance.new("TextButton", G2L["31c"]);
G2L["31e"]["TextWrapped"] = true;
G2L["31e"]["TextStrokeTransparency"] = 0.5;
G2L["31e"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["31e"]["BorderSizePixel"] = 0;
G2L["31e"]["Modal"] = true;
G2L["31e"]["TextSize"] = 10;
G2L["31e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 255);
G2L["31e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["31e"]["ZIndex"] = 2;
G2L["31e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["31e"]["LayoutOrder"] = 1;
G2L["31e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["31e"]["Text"] = [[]];
G2L["31e"]["Name"] = [[Really blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Lapis
G2L["31f"] = Instance.new("TextButton", G2L["31c"]);
G2L["31f"]["TextWrapped"] = true;
G2L["31f"]["TextStrokeTransparency"] = 0.5;
G2L["31f"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["31f"]["BorderSizePixel"] = 0;
G2L["31f"]["Modal"] = true;
G2L["31f"]["TextSize"] = 10;
G2L["31f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31f"]["BackgroundColor3"] = Color3.fromRGB(17, 43, 221);
G2L["31f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["31f"]["ZIndex"] = 2;
G2L["31f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["31f"]["LayoutOrder"] = 2;
G2L["31f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["31f"]["Text"] = [[]];
G2L["31f"]["Name"] = [[Lapis]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Dark blue
G2L["320"] = Instance.new("TextButton", G2L["31c"]);
G2L["320"]["TextWrapped"] = true;
G2L["320"]["TextStrokeTransparency"] = 0.5;
G2L["320"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["320"]["BorderSizePixel"] = 0;
G2L["320"]["Modal"] = true;
G2L["320"]["TextSize"] = 10;
G2L["320"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["320"]["BackgroundColor3"] = Color3.fromRGB(0, 17, 177);
G2L["320"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["320"]["ZIndex"] = 2;
G2L["320"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["320"]["LayoutOrder"] = 3;
G2L["320"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["320"]["Text"] = [[]];
G2L["320"]["Name"] = [[Dark blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Navy blue
G2L["321"] = Instance.new("TextButton", G2L["31c"]);
G2L["321"]["TextWrapped"] = true;
G2L["321"]["TextStrokeTransparency"] = 0.5;
G2L["321"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["321"]["BorderSizePixel"] = 0;
G2L["321"]["Modal"] = true;
G2L["321"]["TextSize"] = 10;
G2L["321"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["321"]["BackgroundColor3"] = Color3.fromRGB(0, 33, 97);
G2L["321"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["321"]["ZIndex"] = 2;
G2L["321"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["321"]["LayoutOrder"] = 4;
G2L["321"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["321"]["Text"] = [[]];
G2L["321"]["Name"] = [[Navy blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Deep blue
G2L["322"] = Instance.new("TextButton", G2L["31c"]);
G2L["322"]["TextWrapped"] = true;
G2L["322"]["TextStrokeTransparency"] = 0.5;
G2L["322"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["322"]["BorderSizePixel"] = 0;
G2L["322"]["Modal"] = true;
G2L["322"]["TextSize"] = 10;
G2L["322"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["322"]["BackgroundColor3"] = Color3.fromRGB(34, 85, 186);
G2L["322"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["322"]["ZIndex"] = 2;
G2L["322"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["322"]["LayoutOrder"] = 5;
G2L["322"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["322"]["Text"] = [[]];
G2L["322"]["Name"] = [[Deep blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Steel blue
G2L["323"] = Instance.new("TextButton", G2L["31c"]);
G2L["323"]["TextWrapped"] = true;
G2L["323"]["TextStrokeTransparency"] = 0.5;
G2L["323"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["323"]["BorderSizePixel"] = 0;
G2L["323"]["Modal"] = true;
G2L["323"]["TextSize"] = 10;
G2L["323"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["323"]["BackgroundColor3"] = Color3.fromRGB(83, 125, 175);
G2L["323"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["323"]["ZIndex"] = 2;
G2L["323"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["323"]["LayoutOrder"] = 6;
G2L["323"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["323"]["Text"] = [[]];
G2L["323"]["Name"] = [[Steel blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Storm blue
G2L["324"] = Instance.new("TextButton", G2L["31c"]);
G2L["324"]["TextWrapped"] = true;
G2L["324"]["TextStrokeTransparency"] = 0.5;
G2L["324"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["324"]["BorderSizePixel"] = 0;
G2L["324"]["Modal"] = true;
G2L["324"]["TextSize"] = 10;
G2L["324"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["324"]["BackgroundColor3"] = Color3.fromRGB(52, 89, 131);
G2L["324"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["324"]["ZIndex"] = 2;
G2L["324"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["324"]["LayoutOrder"] = 7;
G2L["324"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["324"]["Text"] = [[]];
G2L["324"]["Name"] = [[Storm blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Medium blue
G2L["325"] = Instance.new("TextButton", G2L["31c"]);
G2L["325"]["TextWrapped"] = true;
G2L["325"]["TextStrokeTransparency"] = 0.5;
G2L["325"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["325"]["BorderSizePixel"] = 0;
G2L["325"]["Modal"] = true;
G2L["325"]["TextSize"] = 10;
G2L["325"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["325"]["BackgroundColor3"] = Color3.fromRGB(111, 154, 203);
G2L["325"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["325"]["ZIndex"] = 2;
G2L["325"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["325"]["LayoutOrder"] = 8;
G2L["325"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["325"]["Text"] = [[]];
G2L["325"]["Name"] = [[Medium blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Bright bluish green
G2L["326"] = Instance.new("TextButton", G2L["31c"]);
G2L["326"]["TextWrapped"] = true;
G2L["326"]["TextStrokeTransparency"] = 0.5;
G2L["326"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["326"]["BorderSizePixel"] = 0;
G2L["326"]["Modal"] = true;
G2L["326"]["TextSize"] = 10;
G2L["326"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["326"]["BackgroundColor3"] = Color3.fromRGB(0, 144, 157);
G2L["326"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["326"]["ZIndex"] = 2;
G2L["326"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["326"]["LayoutOrder"] = 9;
G2L["326"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["326"]["Text"] = [[]];
G2L["326"]["Name"] = [[Bright bluish green]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Electric blue
G2L["327"] = Instance.new("TextButton", G2L["31c"]);
G2L["327"]["TextWrapped"] = true;
G2L["327"]["TextStrokeTransparency"] = 0.5;
G2L["327"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["327"]["BorderSizePixel"] = 0;
G2L["327"]["Modal"] = true;
G2L["327"]["TextSize"] = 10;
G2L["327"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["327"]["BackgroundColor3"] = Color3.fromRGB(10, 138, 208);
G2L["327"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["327"]["ZIndex"] = 2;
G2L["327"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["327"]["LayoutOrder"] = 10;
G2L["327"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["327"]["Text"] = [[]];
G2L["327"]["Name"] = [[Electric blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Cyan
G2L["328"] = Instance.new("TextButton", G2L["31c"]);
G2L["328"]["TextWrapped"] = true;
G2L["328"]["TextStrokeTransparency"] = 0.5;
G2L["328"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["328"]["BorderSizePixel"] = 0;
G2L["328"]["Modal"] = true;
G2L["328"]["TextSize"] = 10;
G2L["328"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["328"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["328"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["328"]["ZIndex"] = 2;
G2L["328"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["328"]["LayoutOrder"] = 11;
G2L["328"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["328"]["Text"] = [[]];
G2L["328"]["Name"] = [[Cyan]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Blues.Bright blue
G2L["329"] = Instance.new("TextButton", G2L["31c"]);
G2L["329"]["TextWrapped"] = true;
G2L["329"]["TextStrokeTransparency"] = 0.5;
G2L["329"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["329"]["BorderSizePixel"] = 0;
G2L["329"]["Modal"] = true;
G2L["329"]["TextSize"] = 10;
G2L["329"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["329"]["BackgroundColor3"] = Color3.fromRGB(14, 106, 173);
G2L["329"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["329"]["ZIndex"] = 2;
G2L["329"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["329"]["LayoutOrder"] = 12;
G2L["329"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["329"]["Text"] = [[]];
G2L["329"]["Name"] = [[Bright blue]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples
G2L["32a"] = Instance.new("Frame", G2L["2ca"]);
G2L["32a"]["BorderSizePixel"] = 0;
G2L["32a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32a"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["32a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["32a"]["Name"] = [[Purples]];
G2L["32a"]["LayoutOrder"] = 8;
G2L["32a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.UIListLayout
G2L["32b"] = Instance.new("UIListLayout", G2L["32a"]);
G2L["32b"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["32b"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Magenta
G2L["32c"] = Instance.new("TextButton", G2L["32a"]);
G2L["32c"]["TextWrapped"] = true;
G2L["32c"]["TextStrokeTransparency"] = 0.5;
G2L["32c"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["32c"]["BorderSizePixel"] = 0;
G2L["32c"]["Modal"] = true;
G2L["32c"]["TextSize"] = 10;
G2L["32c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32c"]["BackgroundColor3"] = Color3.fromRGB(171, 0, 171);
G2L["32c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["32c"]["ZIndex"] = 2;
G2L["32c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["32c"]["LayoutOrder"] = 1;
G2L["32c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["32c"]["Text"] = [[]];
G2L["32c"]["Name"] = [[Magenta]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Eggplant
G2L["32d"] = Instance.new("TextButton", G2L["32a"]);
G2L["32d"]["TextWrapped"] = true;
G2L["32d"]["TextStrokeTransparency"] = 0.5;
G2L["32d"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["32d"]["BorderSizePixel"] = 0;
G2L["32d"]["Modal"] = true;
G2L["32d"]["TextSize"] = 10;
G2L["32d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32d"]["BackgroundColor3"] = Color3.fromRGB(124, 0, 124);
G2L["32d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["32d"]["ZIndex"] = 2;
G2L["32d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["32d"]["LayoutOrder"] = 2;
G2L["32d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["32d"]["Text"] = [[]];
G2L["32d"]["Name"] = [[Eggplant]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Mulberry
G2L["32e"] = Instance.new("TextButton", G2L["32a"]);
G2L["32e"]["TextWrapped"] = true;
G2L["32e"]["TextStrokeTransparency"] = 0.5;
G2L["32e"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["32e"]["BorderSizePixel"] = 0;
G2L["32e"]["Modal"] = true;
G2L["32e"]["TextSize"] = 10;
G2L["32e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32e"]["BackgroundColor3"] = Color3.fromRGB(90, 35, 90);
G2L["32e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["32e"]["ZIndex"] = 2;
G2L["32e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["32e"]["LayoutOrder"] = 3;
G2L["32e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["32e"]["Text"] = [[]];
G2L["32e"]["Name"] = [[Mulberry]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Plum
G2L["32f"] = Instance.new("TextButton", G2L["32a"]);
G2L["32f"]["TextWrapped"] = true;
G2L["32f"]["TextStrokeTransparency"] = 0.5;
G2L["32f"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["32f"]["BorderSizePixel"] = 0;
G2L["32f"]["Modal"] = true;
G2L["32f"]["TextSize"] = 10;
G2L["32f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32f"]["BackgroundColor3"] = Color3.fromRGB(124, 48, 124);
G2L["32f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["32f"]["ZIndex"] = 2;
G2L["32f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["32f"]["LayoutOrder"] = 4;
G2L["32f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["32f"]["Text"] = [[]];
G2L["32f"]["Name"] = [[Plum]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Bright violet
G2L["330"] = Instance.new("TextButton", G2L["32a"]);
G2L["330"]["TextWrapped"] = true;
G2L["330"]["TextStrokeTransparency"] = 0.5;
G2L["330"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["330"]["BorderSizePixel"] = 0;
G2L["330"]["Modal"] = true;
G2L["330"]["TextSize"] = 10;
G2L["330"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["330"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["330"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["330"]["ZIndex"] = 2;
G2L["330"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["330"]["LayoutOrder"] = 5;
G2L["330"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["330"]["Text"] = [[]];
G2L["330"]["Name"] = [[Bright violet]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Dark indigo
G2L["331"] = Instance.new("TextButton", G2L["32a"]);
G2L["331"]["TextWrapped"] = true;
G2L["331"]["TextStrokeTransparency"] = 0.5;
G2L["331"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["331"]["BorderSizePixel"] = 0;
G2L["331"]["Modal"] = true;
G2L["331"]["TextSize"] = 10;
G2L["331"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["331"]["BackgroundColor3"] = Color3.fromRGB(62, 22, 134);
G2L["331"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["331"]["ZIndex"] = 2;
G2L["331"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["331"]["LayoutOrder"] = 6;
G2L["331"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["331"]["Text"] = [[]];
G2L["331"]["Name"] = [[Dark indigo]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Royal purple
G2L["332"] = Instance.new("TextButton", G2L["32a"]);
G2L["332"]["TextWrapped"] = true;
G2L["332"]["TextStrokeTransparency"] = 0.5;
G2L["332"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["332"]["BorderSizePixel"] = 0;
G2L["332"]["Modal"] = true;
G2L["332"]["TextSize"] = 10;
G2L["332"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["332"]["BackgroundColor3"] = Color3.fromRGB(99, 38, 210);
G2L["332"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["332"]["ZIndex"] = 2;
G2L["332"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["332"]["LayoutOrder"] = 7;
G2L["332"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["332"]["Text"] = [[]];
G2L["332"]["Name"] = [[Royal purple]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Pastel violet
G2L["333"] = Instance.new("TextButton", G2L["32a"]);
G2L["333"]["TextWrapped"] = true;
G2L["333"]["TextStrokeTransparency"] = 0.5;
G2L["333"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["333"]["BorderSizePixel"] = 0;
G2L["333"]["Modal"] = true;
G2L["333"]["TextSize"] = 10;
G2L["333"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["333"]["BackgroundColor3"] = Color3.fromRGB(178, 168, 255);
G2L["333"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["333"]["ZIndex"] = 2;
G2L["333"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["333"]["LayoutOrder"] = 8;
G2L["333"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["333"]["Text"] = [[]];
G2L["333"]["Name"] = [[Pastel violet]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Alder
G2L["334"] = Instance.new("TextButton", G2L["32a"]);
G2L["334"]["TextWrapped"] = true;
G2L["334"]["TextStrokeTransparency"] = 0.5;
G2L["334"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["334"]["BorderSizePixel"] = 0;
G2L["334"]["Modal"] = true;
G2L["334"]["TextSize"] = 10;
G2L["334"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["334"]["BackgroundColor3"] = Color3.fromRGB(181, 129, 255);
G2L["334"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["334"]["ZIndex"] = 2;
G2L["334"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["334"]["LayoutOrder"] = 9;
G2L["334"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["334"]["Text"] = [[]];
G2L["334"]["Name"] = [[Alder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Lavender
G2L["335"] = Instance.new("TextButton", G2L["32a"]);
G2L["335"]["TextWrapped"] = true;
G2L["335"]["TextStrokeTransparency"] = 0.5;
G2L["335"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["335"]["BorderSizePixel"] = 0;
G2L["335"]["Modal"] = true;
G2L["335"]["TextSize"] = 10;
G2L["335"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["335"]["BackgroundColor3"] = Color3.fromRGB(141, 92, 160);
G2L["335"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["335"]["ZIndex"] = 2;
G2L["335"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["335"]["LayoutOrder"] = 10;
G2L["335"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["335"]["Text"] = [[]];
G2L["335"]["Name"] = [[Lavender]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Lilac
G2L["336"] = Instance.new("TextButton", G2L["32a"]);
G2L["336"]["TextWrapped"] = true;
G2L["336"]["TextStrokeTransparency"] = 0.5;
G2L["336"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["336"]["BorderSizePixel"] = 0;
G2L["336"]["Modal"] = true;
G2L["336"]["TextSize"] = 10;
G2L["336"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["336"]["BackgroundColor3"] = Color3.fromRGB(168, 95, 156);
G2L["336"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["336"]["ZIndex"] = 2;
G2L["336"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["336"]["LayoutOrder"] = 11;
G2L["336"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["336"]["Text"] = [[]];
G2L["336"]["Name"] = [[Lilac]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Purples.Sunrise
G2L["337"] = Instance.new("TextButton", G2L["32a"]);
G2L["337"]["TextWrapped"] = true;
G2L["337"]["TextStrokeTransparency"] = 0.5;
G2L["337"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["337"]["BorderSizePixel"] = 0;
G2L["337"]["Modal"] = true;
G2L["337"]["TextSize"] = 10;
G2L["337"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["337"]["BackgroundColor3"] = Color3.fromRGB(213, 145, 190);
G2L["337"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["337"]["ZIndex"] = 2;
G2L["337"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["337"]["LayoutOrder"] = 12;
G2L["337"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["337"]["Text"] = [[]];
G2L["337"]["Name"] = [[Sunrise]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks
G2L["338"] = Instance.new("Frame", G2L["2ca"]);
G2L["338"]["BorderSizePixel"] = 0;
G2L["338"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["338"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["338"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["338"]["Name"] = [[Pinks]];
G2L["338"]["LayoutOrder"] = 9;
G2L["338"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.UIListLayout
G2L["339"] = Instance.new("UIListLayout", G2L["338"]);
G2L["339"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["339"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Hot pink
G2L["33a"] = Instance.new("TextButton", G2L["338"]);
G2L["33a"]["TextWrapped"] = true;
G2L["33a"]["TextStrokeTransparency"] = 0.5;
G2L["33a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33a"]["BorderSizePixel"] = 0;
G2L["33a"]["Modal"] = true;
G2L["33a"]["TextSize"] = 10;
G2L["33a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33a"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 192);
G2L["33a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33a"]["ZIndex"] = 2;
G2L["33a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33a"]["LayoutOrder"] = 1;
G2L["33a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33a"]["Text"] = [[]];
G2L["33a"]["Name"] = [[Hot pink]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Pink
G2L["33b"] = Instance.new("TextButton", G2L["338"]);
G2L["33b"]["TextWrapped"] = true;
G2L["33b"]["TextStrokeTransparency"] = 0.5;
G2L["33b"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33b"]["BorderSizePixel"] = 0;
G2L["33b"]["Modal"] = true;
G2L["33b"]["TextSize"] = 10;
G2L["33b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33b"]["BackgroundColor3"] = Color3.fromRGB(255, 103, 205);
G2L["33b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33b"]["ZIndex"] = 2;
G2L["33b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33b"]["LayoutOrder"] = 2;
G2L["33b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33b"]["Text"] = [[]];
G2L["33b"]["Name"] = [[Pink]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Carnation pink
G2L["33c"] = Instance.new("TextButton", G2L["338"]);
G2L["33c"]["TextWrapped"] = true;
G2L["33c"]["TextStrokeTransparency"] = 0.5;
G2L["33c"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33c"]["BorderSizePixel"] = 0;
G2L["33c"]["Modal"] = true;
G2L["33c"]["TextSize"] = 10;
G2L["33c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33c"]["BackgroundColor3"] = Color3.fromRGB(255, 153, 221);
G2L["33c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33c"]["ZIndex"] = 2;
G2L["33c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33c"]["LayoutOrder"] = 3;
G2L["33c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33c"]["Text"] = [[]];
G2L["33c"]["Name"] = [[Carnation pink]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Mauve
G2L["33d"] = Instance.new("TextButton", G2L["338"]);
G2L["33d"]["TextWrapped"] = true;
G2L["33d"]["TextStrokeTransparency"] = 0.5;
G2L["33d"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33d"]["BorderSizePixel"] = 0;
G2L["33d"]["Modal"] = true;
G2L["33d"]["TextSize"] = 10;
G2L["33d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33d"]["BackgroundColor3"] = Color3.fromRGB(225, 179, 209);
G2L["33d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33d"]["ZIndex"] = 2;
G2L["33d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33d"]["LayoutOrder"] = 4;
G2L["33d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33d"]["Text"] = [[]];
G2L["33d"]["Name"] = [[Mauve]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Light reddish violet
G2L["33e"] = Instance.new("TextButton", G2L["338"]);
G2L["33e"]["TextWrapped"] = true;
G2L["33e"]["TextStrokeTransparency"] = 0.5;
G2L["33e"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33e"]["BorderSizePixel"] = 0;
G2L["33e"]["Modal"] = true;
G2L["33e"]["TextSize"] = 10;
G2L["33e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33e"]["BackgroundColor3"] = Color3.fromRGB(233, 187, 201);
G2L["33e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33e"]["ZIndex"] = 2;
G2L["33e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33e"]["LayoutOrder"] = 5;
G2L["33e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33e"]["Text"] = [[]];
G2L["33e"]["Name"] = [[Light reddish violet]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Pastel orange
G2L["33f"] = Instance.new("TextButton", G2L["338"]);
G2L["33f"]["TextWrapped"] = true;
G2L["33f"]["TextStrokeTransparency"] = 0.5;
G2L["33f"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["33f"]["BorderSizePixel"] = 0;
G2L["33f"]["Modal"] = true;
G2L["33f"]["TextSize"] = 10;
G2L["33f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["33f"]["BackgroundColor3"] = Color3.fromRGB(255, 202, 202);
G2L["33f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["33f"]["ZIndex"] = 2;
G2L["33f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["33f"]["LayoutOrder"] = 6;
G2L["33f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["33f"]["Text"] = [[]];
G2L["33f"]["Name"] = [[Pastel orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Salmon
G2L["340"] = Instance.new("TextButton", G2L["338"]);
G2L["340"]["TextWrapped"] = true;
G2L["340"]["TextStrokeTransparency"] = 0.5;
G2L["340"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["340"]["BorderSizePixel"] = 0;
G2L["340"]["Modal"] = true;
G2L["340"]["TextSize"] = 10;
G2L["340"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["340"]["BackgroundColor3"] = Color3.fromRGB(255, 149, 149);
G2L["340"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["340"]["ZIndex"] = 2;
G2L["340"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["340"]["LayoutOrder"] = 7;
G2L["340"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["340"]["Text"] = [[]];
G2L["340"]["Name"] = [[Salmon]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Medium red
G2L["341"] = Instance.new("TextButton", G2L["338"]);
G2L["341"]["TextWrapped"] = true;
G2L["341"]["TextStrokeTransparency"] = 0.5;
G2L["341"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["341"]["BorderSizePixel"] = 0;
G2L["341"]["Modal"] = true;
G2L["341"]["TextSize"] = 10;
G2L["341"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["341"]["BackgroundColor3"] = Color3.fromRGB(219, 135, 123);
G2L["341"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["341"]["ZIndex"] = 2;
G2L["341"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["341"]["LayoutOrder"] = 8;
G2L["341"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["341"]["Text"] = [[]];
G2L["341"]["Name"] = [[Medium red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Light orange
G2L["342"] = Instance.new("TextButton", G2L["338"]);
G2L["342"]["TextWrapped"] = true;
G2L["342"]["TextStrokeTransparency"] = 0.5;
G2L["342"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["342"]["BorderSizePixel"] = 0;
G2L["342"]["Modal"] = true;
G2L["342"]["TextSize"] = 10;
G2L["342"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["342"]["BackgroundColor3"] = Color3.fromRGB(235, 185, 147);
G2L["342"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["342"]["ZIndex"] = 2;
G2L["342"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["342"]["LayoutOrder"] = 9;
G2L["342"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["342"]["Text"] = [[]];
G2L["342"]["Name"] = [[Light orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Oyster
G2L["343"] = Instance.new("TextButton", G2L["338"]);
G2L["343"]["TextWrapped"] = true;
G2L["343"]["TextStrokeTransparency"] = 0.5;
G2L["343"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["343"]["BorderSizePixel"] = 0;
G2L["343"]["Modal"] = true;
G2L["343"]["TextSize"] = 10;
G2L["343"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["343"]["BackgroundColor3"] = Color3.fromRGB(188, 180, 179);
G2L["343"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["343"]["ZIndex"] = 2;
G2L["343"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["343"]["LayoutOrder"] = 10;
G2L["343"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["343"]["Text"] = [[]];
G2L["343"]["Name"] = [[Oyster]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Linen
G2L["344"] = Instance.new("TextButton", G2L["338"]);
G2L["344"]["TextWrapped"] = true;
G2L["344"]["TextStrokeTransparency"] = 0.5;
G2L["344"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["344"]["BorderSizePixel"] = 0;
G2L["344"]["Modal"] = true;
G2L["344"]["TextSize"] = 10;
G2L["344"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["344"]["BackgroundColor3"] = Color3.fromRGB(176, 149, 132);
G2L["344"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["344"]["ZIndex"] = 2;
G2L["344"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["344"]["LayoutOrder"] = 11;
G2L["344"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["344"]["Text"] = [[]];
G2L["344"]["Name"] = [[Linen]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Pinks.Hurricane grey
G2L["345"] = Instance.new("TextButton", G2L["338"]);
G2L["345"]["TextWrapped"] = true;
G2L["345"]["TextStrokeTransparency"] = 0.5;
G2L["345"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["345"]["BorderSizePixel"] = 0;
G2L["345"]["Modal"] = true;
G2L["345"]["TextSize"] = 10;
G2L["345"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["345"]["BackgroundColor3"] = Color3.fromRGB(150, 138, 137);
G2L["345"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["345"]["ZIndex"] = 2;
G2L["345"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["345"]["LayoutOrder"] = 12;
G2L["345"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["345"]["Text"] = [[]];
G2L["345"]["Name"] = [[Hurricane grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans
G2L["346"] = Instance.new("Frame", G2L["2ca"]);
G2L["346"]["BorderSizePixel"] = 0;
G2L["346"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["346"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["346"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["346"]["Name"] = [[Tans]];
G2L["346"]["LayoutOrder"] = 10;
G2L["346"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.UIListLayout
G2L["347"] = Instance.new("UIListLayout", G2L["346"]);
G2L["347"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["347"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Sand red
G2L["348"] = Instance.new("TextButton", G2L["346"]);
G2L["348"]["TextWrapped"] = true;
G2L["348"]["TextStrokeTransparency"] = 0.5;
G2L["348"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["348"]["BorderSizePixel"] = 0;
G2L["348"]["Modal"] = true;
G2L["348"]["TextSize"] = 10;
G2L["348"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["348"]["BackgroundColor3"] = Color3.fromRGB(150, 122, 120);
G2L["348"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["348"]["ZIndex"] = 2;
G2L["348"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["348"]["LayoutOrder"] = 1;
G2L["348"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["348"]["Text"] = [[]];
G2L["348"]["Name"] = [[Sand red]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Cloudy grey
G2L["349"] = Instance.new("TextButton", G2L["346"]);
G2L["349"]["TextWrapped"] = true;
G2L["349"]["TextStrokeTransparency"] = 0.5;
G2L["349"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["349"]["BorderSizePixel"] = 0;
G2L["349"]["Modal"] = true;
G2L["349"]["TextSize"] = 10;
G2L["349"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["349"]["BackgroundColor3"] = Color3.fromRGB(172, 169, 159);
G2L["349"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["349"]["ZIndex"] = 2;
G2L["349"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["349"]["LayoutOrder"] = 2;
G2L["349"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["349"]["Text"] = [[]];
G2L["349"]["Name"] = [[Cloudy grey]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Beige
G2L["34a"] = Instance.new("TextButton", G2L["346"]);
G2L["34a"]["TextWrapped"] = true;
G2L["34a"]["TextStrokeTransparency"] = 0.5;
G2L["34a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34a"]["BorderSizePixel"] = 0;
G2L["34a"]["Modal"] = true;
G2L["34a"]["TextSize"] = 10;
G2L["34a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34a"]["BackgroundColor3"] = Color3.fromRGB(203, 192, 164);
G2L["34a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34a"]["ZIndex"] = 2;
G2L["34a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34a"]["LayoutOrder"] = 3;
G2L["34a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34a"]["Text"] = [[]];
G2L["34a"]["Name"] = [[Beige]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Burlap
G2L["34b"] = Instance.new("TextButton", G2L["346"]);
G2L["34b"]["TextWrapped"] = true;
G2L["34b"]["TextStrokeTransparency"] = 0.5;
G2L["34b"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34b"]["BorderSizePixel"] = 0;
G2L["34b"]["Modal"] = true;
G2L["34b"]["TextSize"] = 10;
G2L["34b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34b"]["BackgroundColor3"] = Color3.fromRGB(200, 173, 121);
G2L["34b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34b"]["ZIndex"] = 2;
G2L["34b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34b"]["LayoutOrder"] = 4;
G2L["34b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34b"]["Text"] = [[]];
G2L["34b"]["Name"] = [[Burlap]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Cashmere
G2L["34c"] = Instance.new("TextButton", G2L["346"]);
G2L["34c"]["TextWrapped"] = true;
G2L["34c"]["TextStrokeTransparency"] = 0.5;
G2L["34c"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34c"]["BorderSizePixel"] = 0;
G2L["34c"]["Modal"] = true;
G2L["34c"]["TextSize"] = 10;
G2L["34c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34c"]["BackgroundColor3"] = Color3.fromRGB(212, 191, 151);
G2L["34c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34c"]["ZIndex"] = 2;
G2L["34c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34c"]["LayoutOrder"] = 5;
G2L["34c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34c"]["Text"] = [[]];
G2L["34c"]["Name"] = [[Cashmere]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Brick yellow
G2L["34d"] = Instance.new("TextButton", G2L["346"]);
G2L["34d"]["TextWrapped"] = true;
G2L["34d"]["TextStrokeTransparency"] = 0.5;
G2L["34d"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34d"]["BorderSizePixel"] = 0;
G2L["34d"]["Modal"] = true;
G2L["34d"]["TextSize"] = 10;
G2L["34d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34d"]["BackgroundColor3"] = Color3.fromRGB(216, 198, 155);
G2L["34d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34d"]["ZIndex"] = 2;
G2L["34d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34d"]["LayoutOrder"] = 6;
G2L["34d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34d"]["Text"] = [[]];
G2L["34d"]["Name"] = [[Brick yellow]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Wheat
G2L["34e"] = Instance.new("TextButton", G2L["346"]);
G2L["34e"]["TextWrapped"] = true;
G2L["34e"]["TextStrokeTransparency"] = 0.5;
G2L["34e"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34e"]["BorderSizePixel"] = 0;
G2L["34e"]["Modal"] = true;
G2L["34e"]["TextSize"] = 10;
G2L["34e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34e"]["BackgroundColor3"] = Color3.fromRGB(242, 232, 200);
G2L["34e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34e"]["ZIndex"] = 2;
G2L["34e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34e"]["LayoutOrder"] = 7;
G2L["34e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34e"]["Text"] = [[]];
G2L["34e"]["Name"] = [[Wheat]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Khaki
G2L["34f"] = Instance.new("TextButton", G2L["346"]);
G2L["34f"]["TextWrapped"] = true;
G2L["34f"]["TextStrokeTransparency"] = 0.5;
G2L["34f"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["34f"]["BorderSizePixel"] = 0;
G2L["34f"]["Modal"] = true;
G2L["34f"]["TextSize"] = 10;
G2L["34f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34f"]["BackgroundColor3"] = Color3.fromRGB(227, 221, 189);
G2L["34f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["34f"]["ZIndex"] = 2;
G2L["34f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["34f"]["LayoutOrder"] = 8;
G2L["34f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["34f"]["Text"] = [[]];
G2L["34f"]["Name"] = [[Khaki]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Seashell
G2L["350"] = Instance.new("TextButton", G2L["346"]);
G2L["350"]["TextWrapped"] = true;
G2L["350"]["TextStrokeTransparency"] = 0.5;
G2L["350"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["350"]["BorderSizePixel"] = 0;
G2L["350"]["Modal"] = true;
G2L["350"]["TextSize"] = 10;
G2L["350"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["350"]["BackgroundColor3"] = Color3.fromRGB(234, 219, 219);
G2L["350"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["350"]["ZIndex"] = 2;
G2L["350"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["350"]["LayoutOrder"] = 9;
G2L["350"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["350"]["Text"] = [[]];
G2L["350"]["Name"] = [[Seashell]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Pastel brown
G2L["351"] = Instance.new("TextButton", G2L["346"]);
G2L["351"]["TextWrapped"] = true;
G2L["351"]["TextStrokeTransparency"] = 0.5;
G2L["351"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["351"]["BorderSizePixel"] = 0;
G2L["351"]["Modal"] = true;
G2L["351"]["TextSize"] = 10;
G2L["351"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["351"]["BackgroundColor3"] = Color3.fromRGB(255, 205, 154);
G2L["351"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["351"]["ZIndex"] = 2;
G2L["351"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["351"]["LayoutOrder"] = 10;
G2L["351"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["351"]["Text"] = [[]];
G2L["351"]["Name"] = [[Pastel brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Nougat
G2L["352"] = Instance.new("TextButton", G2L["346"]);
G2L["352"]["TextWrapped"] = true;
G2L["352"]["TextStrokeTransparency"] = 0.5;
G2L["352"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["352"]["BorderSizePixel"] = 0;
G2L["352"]["Modal"] = true;
G2L["352"]["TextSize"] = 10;
G2L["352"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["352"]["BackgroundColor3"] = Color3.fromRGB(205, 143, 106);
G2L["352"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["352"]["ZIndex"] = 2;
G2L["352"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["352"]["LayoutOrder"] = 11;
G2L["352"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["352"]["Text"] = [[]];
G2L["352"]["Name"] = [[Nougat]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Tans.Copper
G2L["353"] = Instance.new("TextButton", G2L["346"]);
G2L["353"]["TextWrapped"] = true;
G2L["353"]["TextStrokeTransparency"] = 0.5;
G2L["353"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["353"]["BorderSizePixel"] = 0;
G2L["353"]["Modal"] = true;
G2L["353"]["TextSize"] = 10;
G2L["353"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["353"]["BackgroundColor3"] = Color3.fromRGB(151, 104, 103);
G2L["353"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["353"]["ZIndex"] = 2;
G2L["353"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["353"]["LayoutOrder"] = 12;
G2L["353"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["353"]["Text"] = [[]];
G2L["353"]["Name"] = [[Copper]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns
G2L["354"] = Instance.new("Frame", G2L["2ca"]);
G2L["354"]["BorderSizePixel"] = 0;
G2L["354"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["354"]["Size"] = UDim2.new(0.091, 0, 1, 0);
G2L["354"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["354"]["Name"] = [[Browns]];
G2L["354"]["LayoutOrder"] = 11;
G2L["354"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.UIListLayout
G2L["355"] = Instance.new("UIListLayout", G2L["354"]);
G2L["355"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Center;
G2L["355"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Dirt brown
G2L["356"] = Instance.new("TextButton", G2L["354"]);
G2L["356"]["TextWrapped"] = true;
G2L["356"]["TextStrokeTransparency"] = 0.5;
G2L["356"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["356"]["BorderSizePixel"] = 0;
G2L["356"]["Modal"] = true;
G2L["356"]["TextSize"] = 10;
G2L["356"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["356"]["BackgroundColor3"] = Color3.fromRGB(87, 67, 55);
G2L["356"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["356"]["ZIndex"] = 2;
G2L["356"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["356"]["LayoutOrder"] = 1;
G2L["356"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["356"]["Text"] = [[]];
G2L["356"]["Name"] = [[Dirt brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Pine Cone
G2L["357"] = Instance.new("TextButton", G2L["354"]);
G2L["357"]["TextWrapped"] = true;
G2L["357"]["TextStrokeTransparency"] = 0.5;
G2L["357"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["357"]["BorderSizePixel"] = 0;
G2L["357"]["Modal"] = true;
G2L["357"]["TextSize"] = 10;
G2L["357"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["357"]["BackgroundColor3"] = Color3.fromRGB(109, 89, 76);
G2L["357"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["357"]["ZIndex"] = 2;
G2L["357"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["357"]["LayoutOrder"] = 2;
G2L["357"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["357"]["Text"] = [[]];
G2L["357"]["Name"] = [[Pine Cone]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Bronze
G2L["358"] = Instance.new("TextButton", G2L["354"]);
G2L["358"]["TextWrapped"] = true;
G2L["358"]["TextStrokeTransparency"] = 0.5;
G2L["358"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["358"]["BorderSizePixel"] = 0;
G2L["358"]["Modal"] = true;
G2L["358"]["TextSize"] = 10;
G2L["358"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["358"]["BackgroundColor3"] = Color3.fromRGB(127, 105, 64);
G2L["358"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["358"]["ZIndex"] = 2;
G2L["358"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["358"]["LayoutOrder"] = 3;
G2L["358"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["358"]["Text"] = [[]];
G2L["358"]["Name"] = [[Bronze]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Fawn brown
G2L["359"] = Instance.new("TextButton", G2L["354"]);
G2L["359"]["TextWrapped"] = true;
G2L["359"]["TextStrokeTransparency"] = 0.5;
G2L["359"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["359"]["BorderSizePixel"] = 0;
G2L["359"]["Modal"] = true;
G2L["359"]["TextSize"] = 10;
G2L["359"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["359"]["BackgroundColor3"] = Color3.fromRGB(161, 133, 80);
G2L["359"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["359"]["ZIndex"] = 2;
G2L["359"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["359"]["LayoutOrder"] = 4;
G2L["359"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["359"]["Text"] = [[]];
G2L["359"]["Name"] = [[Fawn brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Cork
G2L["35a"] = Instance.new("TextButton", G2L["354"]);
G2L["35a"]["TextWrapped"] = true;
G2L["35a"]["TextStrokeTransparency"] = 0.5;
G2L["35a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35a"]["BorderSizePixel"] = 0;
G2L["35a"]["Modal"] = true;
G2L["35a"]["TextSize"] = 10;
G2L["35a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35a"]["BackgroundColor3"] = Color3.fromRGB(189, 156, 94);
G2L["35a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35a"]["ZIndex"] = 2;
G2L["35a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35a"]["LayoutOrder"] = 5;
G2L["35a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35a"]["Text"] = [[]];
G2L["35a"]["Name"] = [[Cork]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Burnt Sienna
G2L["35b"] = Instance.new("TextButton", G2L["354"]);
G2L["35b"]["TextWrapped"] = true;
G2L["35b"]["TextStrokeTransparency"] = 0.5;
G2L["35b"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35b"]["BorderSizePixel"] = 0;
G2L["35b"]["Modal"] = true;
G2L["35b"]["TextSize"] = 10;
G2L["35b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35b"]["BackgroundColor3"] = Color3.fromRGB(107, 58, 10);
G2L["35b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35b"]["ZIndex"] = 2;
G2L["35b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35b"]["LayoutOrder"] = 6;
G2L["35b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35b"]["Text"] = [[]];
G2L["35b"]["Name"] = [[Burnt Sienna]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Reddish brown
G2L["35c"] = Instance.new("TextButton", G2L["354"]);
G2L["35c"]["TextWrapped"] = true;
G2L["35c"]["TextStrokeTransparency"] = 0.5;
G2L["35c"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35c"]["BorderSizePixel"] = 0;
G2L["35c"]["Modal"] = true;
G2L["35c"]["TextSize"] = 10;
G2L["35c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35c"]["BackgroundColor3"] = Color3.fromRGB(106, 65, 41);
G2L["35c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35c"]["ZIndex"] = 2;
G2L["35c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35c"]["LayoutOrder"] = 7;
G2L["35c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35c"]["Text"] = [[]];
G2L["35c"]["Name"] = [[Reddish brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Dark orange
G2L["35d"] = Instance.new("TextButton", G2L["354"]);
G2L["35d"]["TextWrapped"] = true;
G2L["35d"]["TextStrokeTransparency"] = 0.5;
G2L["35d"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35d"]["BorderSizePixel"] = 0;
G2L["35d"]["Modal"] = true;
G2L["35d"]["TextSize"] = 10;
G2L["35d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35d"]["BackgroundColor3"] = Color3.fromRGB(161, 96, 54);
G2L["35d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35d"]["ZIndex"] = 2;
G2L["35d"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35d"]["LayoutOrder"] = 8;
G2L["35d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35d"]["Text"] = [[]];
G2L["35d"]["Name"] = [[Dark orange]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Brown
G2L["35e"] = Instance.new("TextButton", G2L["354"]);
G2L["35e"]["TextWrapped"] = true;
G2L["35e"]["TextStrokeTransparency"] = 0.5;
G2L["35e"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35e"]["BorderSizePixel"] = 0;
G2L["35e"]["Modal"] = true;
G2L["35e"]["TextSize"] = 10;
G2L["35e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35e"]["BackgroundColor3"] = Color3.fromRGB(125, 93, 71);
G2L["35e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35e"]["ZIndex"] = 2;
G2L["35e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35e"]["LayoutOrder"] = 9;
G2L["35e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35e"]["Text"] = [[]];
G2L["35e"]["Name"] = [[Brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Dark taupe
G2L["35f"] = Instance.new("TextButton", G2L["354"]);
G2L["35f"]["TextWrapped"] = true;
G2L["35f"]["TextStrokeTransparency"] = 0.5;
G2L["35f"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["35f"]["BorderSizePixel"] = 0;
G2L["35f"]["Modal"] = true;
G2L["35f"]["TextSize"] = 10;
G2L["35f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["35f"]["BackgroundColor3"] = Color3.fromRGB(91, 77, 67);
G2L["35f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["35f"]["ZIndex"] = 2;
G2L["35f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["35f"]["LayoutOrder"] = 10;
G2L["35f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["35f"]["Text"] = [[]];
G2L["35f"]["Name"] = [[Dark taupe]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.Rust
G2L["360"] = Instance.new("TextButton", G2L["354"]);
G2L["360"]["TextWrapped"] = true;
G2L["360"]["TextStrokeTransparency"] = 0.5;
G2L["360"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["360"]["BorderSizePixel"] = 0;
G2L["360"]["Modal"] = true;
G2L["360"]["TextSize"] = 10;
G2L["360"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["360"]["BackgroundColor3"] = Color3.fromRGB(144, 77, 43);
G2L["360"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["360"]["ZIndex"] = 2;
G2L["360"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["360"]["LayoutOrder"] = 11;
G2L["360"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["360"]["Text"] = [[]];
G2L["360"]["Name"] = [[Rust]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Palette.Browns.CGA brown
G2L["361"] = Instance.new("TextButton", G2L["354"]);
G2L["361"]["TextWrapped"] = true;
G2L["361"]["TextStrokeTransparency"] = 0.5;
G2L["361"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["361"]["BorderSizePixel"] = 0;
G2L["361"]["Modal"] = true;
G2L["361"]["TextSize"] = 10;
G2L["361"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["361"]["BackgroundColor3"] = Color3.fromRGB(171, 86, 0);
G2L["361"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["361"]["ZIndex"] = 2;
G2L["361"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["361"]["LayoutOrder"] = 12;
G2L["361"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["361"]["Text"] = [[]];
G2L["361"]["Name"] = [[CGA brown]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.ButtonBackground
G2L["362"] = Instance.new("ImageLabel", G2L["2c4"]);
G2L["362"]["BorderSizePixel"] = 0;
G2L["362"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["362"]["ImageColor3"] = Color3.fromRGB(181, 129, 255);
G2L["362"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["362"]["Image"] = [[rbxassetid://736379820]];
G2L["362"]["Size"] = UDim2.new(0.9, 0, 0.9, 0);
G2L["362"]["Visible"] = false;
G2L["362"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["362"]["BackgroundTransparency"] = 1;
G2L["362"]["Name"] = [[ButtonBackground]];
G2L["362"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.ButtonTemplate
G2L["363"] = Instance.new("TextButton", G2L["2c4"]);
G2L["363"]["TextWrapped"] = true;
G2L["363"]["TextStrokeTransparency"] = 0.15;
G2L["363"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["363"]["BorderSizePixel"] = 0;
G2L["363"]["Modal"] = true;
G2L["363"]["TextSize"] = 10;
G2L["363"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["363"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["363"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["363"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["363"]["LayoutOrder"] = 4;
G2L["363"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["363"]["Text"] = [[]];
G2L["363"]["Name"] = [[ButtonTemplate]];
G2L["363"]["Visible"] = false;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls
G2L["364"] = Instance.new("Frame", G2L["2c4"]);
G2L["364"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["364"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["364"]["Size"] = UDim2.new(1, 0, 0.15, 0);
G2L["364"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["364"]["Name"] = [[Controls]];
G2L["364"]["LayoutOrder"] = 3;
G2L["364"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.ColorPickerButton
G2L["365"] = Instance.new("ImageButton", G2L["364"]);
G2L["365"]["BorderSizePixel"] = 0;
G2L["365"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["365"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["365"]["ImageColor3"] = Color3.fromRGB(255, 0, 5);
G2L["365"]["Image"] = [[rbxassetid://879282065]];
G2L["365"]["Size"] = UDim2.new(0, 42, 0, 24);
G2L["365"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["365"]["Name"] = [[ColorPickerButton]];
G2L["365"]["Position"] = UDim2.new(0, -4, 0, 12);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.ColorPickerButton.Icons
G2L["366"] = Instance.new("ImageLabel", G2L["365"]);
G2L["366"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["366"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["366"]["Image"] = [[rbxassetid://879281598]];
G2L["366"]["Size"] = UDim2.new(0, 30, 0, 16);
G2L["366"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["366"]["BackgroundTransparency"] = 1;
G2L["366"]["Name"] = [[Icons]];
G2L["366"]["Position"] = UDim2.new(0.5, 0, 0.5, -1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.ColorBar
G2L["367"] = Instance.new("Frame", G2L["364"]);
G2L["367"]["BorderSizePixel"] = 0;
G2L["367"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
G2L["367"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["367"]["Position"] = UDim2.new(0, 0, 0, 8);
G2L["367"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["367"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.LastColorButton
G2L["368"] = Instance.new("TextButton", G2L["364"]);
G2L["368"]["BorderSizePixel"] = 0;
G2L["368"]["TextSize"] = 14;
G2L["368"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["368"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["368"]["AnchorPoint"] = Vector2.new(1, 0);
G2L["368"]["BackgroundTransparency"] = 1;
G2L["368"]["Size"] = UDim2.new(0.7, 0, 0, 23);
G2L["368"]["LayoutOrder"] = 4;
G2L["368"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["368"]["Text"] = [[]];
G2L["368"]["Name"] = [[LastColorButton]];
G2L["368"]["Position"] = UDim2.new(1, 0, 0, 12);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.LastColorButton.ColorName
G2L["369"] = Instance.new("TextLabel", G2L["368"]);
G2L["369"]["TextStrokeTransparency"] = 0.75;
G2L["369"]["BorderSizePixel"] = 0;
G2L["369"]["TextSize"] = 10;
G2L["369"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["369"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["369"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["369"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["369"]["BackgroundTransparency"] = 1;
G2L["369"]["Size"] = UDim2.new(1, -5, 1, 0);
G2L["369"]["Visible"] = false;
G2L["369"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["369"]["Text"] = [[Medium stone grey]];
G2L["369"]["Name"] = [[ColorName]];
G2L["369"]["Position"] = UDim2.new(0, 0, 0, -2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTPaintToolGUI.Controls.LastColorButton.ColorName.ColorSquare
G2L["36a"] = Instance.new("Frame", G2L["369"]);
G2L["36a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeYY;
G2L["36a"]["BorderSizePixel"] = 0;
G2L["36a"]["Size"] = UDim2.new(0.6, 0, 0.6, 0);
G2L["36a"]["Position"] = UDim2.new(0.5, -43, 0.2, 1);
G2L["36a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36a"]["Name"] = [[ColorSquare]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI
G2L["36b"] = Instance.new("Frame", G2L["52"]);
G2L["36b"]["Active"] = true;
G2L["36b"]["BorderSizePixel"] = 0;
G2L["36b"]["Size"] = UDim2.new(0, 245, 0, 90);
G2L["36b"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["36b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36b"]["Name"] = [[BTResizeToolGUI]];
G2L["36b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption
G2L["36c"] = Instance.new("Frame", G2L["36b"]);
G2L["36c"]["BorderSizePixel"] = 0;
G2L["36c"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["36c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36c"]["Name"] = [[DirectionsOption]];
G2L["36c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Normal
G2L["36d"] = Instance.new("Frame", G2L["36c"]);
G2L["36d"]["BorderSizePixel"] = 0;
G2L["36d"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["36d"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["36d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36d"]["Name"] = [[Normal]];
G2L["36d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Normal.SelectedIndicator
G2L["36e"] = Instance.new("Frame", G2L["36d"]);
G2L["36e"]["BorderSizePixel"] = 0;
G2L["36e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36e"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["36e"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["36e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36e"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Normal.Button
G2L["36f"] = Instance.new("TextButton", G2L["36d"]);
G2L["36f"]["BorderSizePixel"] = 0;
G2L["36f"]["TextTransparency"] = 1;
G2L["36f"]["ZIndex"] = 2;
G2L["36f"]["BackgroundTransparency"] = 1;
G2L["36f"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["36f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["36f"]["Text"] = [[]];
G2L["36f"]["Name"] = [[Button]];
G2L["36f"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Normal.Background
G2L["370"] = Instance.new("ImageLabel", G2L["36d"]);
G2L["370"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["370"]["Image"] = [[http://www.roblox.com/asset/?id=127774197]];
G2L["370"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["370"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["370"]["BackgroundTransparency"] = 1;
G2L["370"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Normal.Label
G2L["371"] = Instance.new("TextLabel", G2L["36d"]);
G2L["371"]["BorderSizePixel"] = 0;
G2L["371"]["TextSize"] = 10;
G2L["371"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["371"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["371"]["BackgroundTransparency"] = 1;
G2L["371"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["371"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["371"]["Text"] = [[NORMAL]];
G2L["371"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Both
G2L["372"] = Instance.new("Frame", G2L["36c"]);
G2L["372"]["BorderSizePixel"] = 0;
G2L["372"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["372"]["Position"] = UDim2.new(0, 135, 0, 0);
G2L["372"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["372"]["Name"] = [[Both]];
G2L["372"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Both.SelectedIndicator
G2L["373"] = Instance.new("Frame", G2L["372"]);
G2L["373"]["BorderSizePixel"] = 0;
G2L["373"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["373"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["373"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["373"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["373"]["Name"] = [[SelectedIndicator]];
G2L["373"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Both.Button
G2L["374"] = Instance.new("TextButton", G2L["372"]);
G2L["374"]["BorderSizePixel"] = 0;
G2L["374"]["TextTransparency"] = 1;
G2L["374"]["ZIndex"] = 2;
G2L["374"]["BackgroundTransparency"] = 1;
G2L["374"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["374"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["374"]["Text"] = [[]];
G2L["374"]["Name"] = [[Button]];
G2L["374"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Both.Background
G2L["375"] = Instance.new("ImageLabel", G2L["372"]);
G2L["375"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["375"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["375"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["375"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["375"]["BackgroundTransparency"] = 1;
G2L["375"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Both.Label
G2L["376"] = Instance.new("TextLabel", G2L["372"]);
G2L["376"]["BorderSizePixel"] = 0;
G2L["376"]["TextSize"] = 10;
G2L["376"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["376"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["376"]["BackgroundTransparency"] = 1;
G2L["376"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["376"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["376"]["Text"] = [[BOTH]];
G2L["376"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Label
G2L["377"] = Instance.new("Frame", G2L["36c"]);
G2L["377"]["BorderSizePixel"] = 0;
G2L["377"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["377"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["377"]["Name"] = [[Label]];
G2L["377"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.DirectionsOption.Label.TextLabel
G2L["378"] = Instance.new("TextLabel", G2L["377"]);
G2L["378"]["TextWrapped"] = true;
G2L["378"]["TextStrokeTransparency"] = 0;
G2L["378"]["BorderSizePixel"] = 0;
G2L["378"]["TextSize"] = 10;
G2L["378"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["378"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["378"]["BackgroundTransparency"] = 1;
G2L["378"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["378"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["378"]["Text"] = [[Directions]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Title
G2L["379"] = Instance.new("Frame", G2L["36b"]);
G2L["379"]["BorderSizePixel"] = 0;
G2L["379"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["379"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["379"]["Name"] = [[Title]];
G2L["379"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Title.ColorBar
G2L["37a"] = Instance.new("Frame", G2L["379"]);
G2L["37a"]["BorderSizePixel"] = 0;
G2L["37a"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["37a"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["37a"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["37a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37a"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Title.Label
G2L["37b"] = Instance.new("TextLabel", G2L["379"]);
G2L["37b"]["TextWrapped"] = true;
G2L["37b"]["TextStrokeTransparency"] = 0;
G2L["37b"]["BorderSizePixel"] = 0;
G2L["37b"]["TextSize"] = 10;
G2L["37b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["37b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["37b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["37b"]["BackgroundTransparency"] = 1;
G2L["37b"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["37b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37b"]["Text"] = [[RESIZE TOOL]];
G2L["37b"]["Name"] = [[Label]];
G2L["37b"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Title.F3XSignature
G2L["37c"] = Instance.new("TextLabel", G2L["379"]);
G2L["37c"]["TextWrapped"] = true;
G2L["37c"]["TextStrokeTransparency"] = 0.9;
G2L["37c"]["BorderSizePixel"] = 0;
G2L["37c"]["TextSize"] = 14;
G2L["37c"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["37c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["37c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["37c"]["BackgroundTransparency"] = 1;
G2L["37c"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["37c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37c"]["Text"] = [[F3X]];
G2L["37c"]["Name"] = [[F3XSignature]];
G2L["37c"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption
G2L["37d"] = Instance.new("Frame", G2L["36b"]);
G2L["37d"]["BorderSizePixel"] = 0;
G2L["37d"]["Position"] = UDim2.new(0, 0, 0, 65);
G2L["37d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37d"]["Name"] = [[IncrementOption]];
G2L["37d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Increment
G2L["37e"] = Instance.new("Frame", G2L["37d"]);
G2L["37e"]["BorderSizePixel"] = 0;
G2L["37e"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["37e"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["37e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37e"]["Name"] = [[Increment]];
G2L["37e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Increment.SelectedIndicator
G2L["37f"] = Instance.new("Frame", G2L["37e"]);
G2L["37f"]["BorderSizePixel"] = 0;
G2L["37f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["37f"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["37f"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["37f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["37f"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Increment.TextBox
G2L["380"] = Instance.new("TextBox", G2L["37e"]);
G2L["380"]["ZIndex"] = 2;
G2L["380"]["BorderSizePixel"] = 0;
G2L["380"]["TextSize"] = 10;
G2L["380"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["380"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["380"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["380"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["380"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["380"]["Text"] = [[1]];
G2L["380"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Increment.Background
G2L["381"] = Instance.new("ImageLabel", G2L["37e"]);
G2L["381"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["381"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["381"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["381"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["381"]["BackgroundTransparency"] = 1;
G2L["381"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Label
G2L["382"] = Instance.new("Frame", G2L["37d"]);
G2L["382"]["BorderSizePixel"] = 0;
G2L["382"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["382"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["382"]["Name"] = [[Label]];
G2L["382"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.IncrementOption.Label.TextLabel
G2L["383"] = Instance.new("TextLabel", G2L["382"]);
G2L["383"]["TextWrapped"] = true;
G2L["383"]["TextStrokeTransparency"] = 0;
G2L["383"]["BorderSizePixel"] = 0;
G2L["383"]["TextSize"] = 10;
G2L["383"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["383"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["383"]["BackgroundTransparency"] = 1;
G2L["383"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["383"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["383"]["Text"] = [[Increment]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info
G2L["384"] = Instance.new("Frame", G2L["36b"]);
G2L["384"]["Visible"] = false;
G2L["384"]["BorderSizePixel"] = 0;
G2L["384"]["Size"] = UDim2.new(1, -5, 0, 60);
G2L["384"]["Position"] = UDim2.new(0, 5, 0, 100);
G2L["384"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["384"]["Name"] = [[Info]];
G2L["384"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.ColorBar
G2L["385"] = Instance.new("Frame", G2L["384"]);
G2L["385"]["BorderSizePixel"] = 0;
G2L["385"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["385"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["385"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["385"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.Label
G2L["386"] = Instance.new("TextLabel", G2L["384"]);
G2L["386"]["TextWrapped"] = true;
G2L["386"]["TextStrokeTransparency"] = 0;
G2L["386"]["BorderSizePixel"] = 0;
G2L["386"]["TextSize"] = 10;
G2L["386"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["386"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["386"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["386"]["BackgroundTransparency"] = 1;
G2L["386"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["386"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["386"]["Text"] = [[SELECTION INFO]];
G2L["386"]["Name"] = [[Label]];
G2L["386"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo
G2L["387"] = Instance.new("Frame", G2L["384"]);
G2L["387"]["BorderSizePixel"] = 0;
G2L["387"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["387"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["387"]["Name"] = [[SizeInfo]];
G2L["387"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.TextLabel
G2L["388"] = Instance.new("TextLabel", G2L["387"]);
G2L["388"]["TextWrapped"] = true;
G2L["388"]["TextStrokeTransparency"] = 0;
G2L["388"]["BorderSizePixel"] = 0;
G2L["388"]["TextSize"] = 10;
G2L["388"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["388"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["388"]["BackgroundTransparency"] = 1;
G2L["388"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["388"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["388"]["Text"] = [[Size]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.X
G2L["389"] = Instance.new("Frame", G2L["387"]);
G2L["389"]["BorderSizePixel"] = 0;
G2L["389"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["389"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["389"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["389"]["Name"] = [[X]];
G2L["389"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.X.TextBox
G2L["38a"] = Instance.new("TextBox", G2L["389"]);
G2L["38a"]["ZIndex"] = 2;
G2L["38a"]["BorderSizePixel"] = 0;
G2L["38a"]["TextSize"] = 10;
G2L["38a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["38a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["38a"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["38a"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["38a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38a"]["Text"] = [[]];
G2L["38a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.X.Background
G2L["38b"] = Instance.new("ImageLabel", G2L["389"]);
G2L["38b"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["38b"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["38b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["38b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38b"]["BackgroundTransparency"] = 1;
G2L["38b"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Y
G2L["38c"] = Instance.new("Frame", G2L["387"]);
G2L["38c"]["BorderSizePixel"] = 0;
G2L["38c"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["38c"]["Position"] = UDim2.new(0, 117, 0, 0);
G2L["38c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38c"]["Name"] = [[Y]];
G2L["38c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Y.TextBox
G2L["38d"] = Instance.new("TextBox", G2L["38c"]);
G2L["38d"]["ZIndex"] = 2;
G2L["38d"]["BorderSizePixel"] = 0;
G2L["38d"]["TextSize"] = 10;
G2L["38d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["38d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["38d"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["38d"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["38d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38d"]["Text"] = [[]];
G2L["38d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Y.Background
G2L["38e"] = Instance.new("ImageLabel", G2L["38c"]);
G2L["38e"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["38e"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["38e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["38e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38e"]["BackgroundTransparency"] = 1;
G2L["38e"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Z
G2L["38f"] = Instance.new("Frame", G2L["387"]);
G2L["38f"]["BorderSizePixel"] = 0;
G2L["38f"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["38f"]["Position"] = UDim2.new(0, 164, 0, 0);
G2L["38f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["38f"]["Name"] = [[Z]];
G2L["38f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Z.TextBox
G2L["390"] = Instance.new("TextBox", G2L["38f"]);
G2L["390"]["ZIndex"] = 2;
G2L["390"]["BorderSizePixel"] = 0;
G2L["390"]["TextSize"] = 10;
G2L["390"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["390"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["390"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["390"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["390"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["390"]["Text"] = [[]];
G2L["390"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Info.SizeInfo.Z.Background
G2L["391"] = Instance.new("ImageLabel", G2L["38f"]);
G2L["391"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["391"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["391"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["391"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["391"]["BackgroundTransparency"] = 1;
G2L["391"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Changes
G2L["392"] = Instance.new("Frame", G2L["36b"]);
G2L["392"]["BorderSizePixel"] = 0;
G2L["392"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["392"]["Position"] = UDim2.new(0, 5, 1, 10);
G2L["392"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["392"]["Name"] = [[Changes]];
G2L["392"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Changes.ColorBar
G2L["393"] = Instance.new("Frame", G2L["392"]);
G2L["393"]["BorderSizePixel"] = 0;
G2L["393"]["BackgroundColor3"] = Color3.fromRGB(5, 176, 237);
G2L["393"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["393"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["393"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTResizeToolGUI.Changes.Text
G2L["394"] = Instance.new("TextLabel", G2L["392"]);
G2L["394"]["TextWrapped"] = true;
G2L["394"]["TextStrokeTransparency"] = 0.5;
G2L["394"]["BorderSizePixel"] = 0;
G2L["394"]["TextSize"] = 10;
G2L["394"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["394"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["394"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["394"]["BackgroundTransparency"] = 1;
G2L["394"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["394"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["394"]["Text"] = [[resized 0 studs]];
G2L["394"]["Name"] = [[Text]];
G2L["394"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI
G2L["395"] = Instance.new("Frame", G2L["52"]);
G2L["395"]["Active"] = true;
G2L["395"]["BorderSizePixel"] = 0;
G2L["395"]["Size"] = UDim2.new(0, 245, 0, 90);
G2L["395"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["395"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["395"]["Name"] = [[BTRotateToolGUI]];
G2L["395"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption
G2L["396"] = Instance.new("Frame", G2L["395"]);
G2L["396"]["BorderSizePixel"] = 0;
G2L["396"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["396"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["396"]["Name"] = [[PivotOption]];
G2L["396"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Center
G2L["397"] = Instance.new("Frame", G2L["396"]);
G2L["397"]["BorderSizePixel"] = 0;
G2L["397"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["397"]["Position"] = UDim2.new(0, 50, 0, 0);
G2L["397"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["397"]["Name"] = [[Center]];
G2L["397"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Center.SelectedIndicator
G2L["398"] = Instance.new("Frame", G2L["397"]);
G2L["398"]["BorderSizePixel"] = 0;
G2L["398"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["398"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["398"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["398"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["398"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Center.Button
G2L["399"] = Instance.new("TextButton", G2L["397"]);
G2L["399"]["BorderSizePixel"] = 0;
G2L["399"]["TextTransparency"] = 1;
G2L["399"]["ZIndex"] = 2;
G2L["399"]["BackgroundTransparency"] = 1;
G2L["399"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["399"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["399"]["Text"] = [[]];
G2L["399"]["Name"] = [[Button]];
G2L["399"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Center.Background
G2L["39a"] = Instance.new("ImageLabel", G2L["397"]);
G2L["39a"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["39a"]["Image"] = [[http://www.roblox.com/asset/?id=127774197]];
G2L["39a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["39a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39a"]["BackgroundTransparency"] = 1;
G2L["39a"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Center.Label
G2L["39b"] = Instance.new("TextLabel", G2L["397"]);
G2L["39b"]["BorderSizePixel"] = 0;
G2L["39b"]["TextSize"] = 10;
G2L["39b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["39b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["39b"]["BackgroundTransparency"] = 1;
G2L["39b"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["39b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39b"]["Text"] = [[CENTER]];
G2L["39b"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Local
G2L["39c"] = Instance.new("Frame", G2L["396"]);
G2L["39c"]["BorderSizePixel"] = 0;
G2L["39c"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["39c"]["Position"] = UDim2.new(0, 115, 0, 0);
G2L["39c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39c"]["Name"] = [[Local]];
G2L["39c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Local.SelectedIndicator
G2L["39d"] = Instance.new("Frame", G2L["39c"]);
G2L["39d"]["BorderSizePixel"] = 0;
G2L["39d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["39d"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["39d"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["39d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39d"]["Name"] = [[SelectedIndicator]];
G2L["39d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Local.Button
G2L["39e"] = Instance.new("TextButton", G2L["39c"]);
G2L["39e"]["BorderSizePixel"] = 0;
G2L["39e"]["TextTransparency"] = 1;
G2L["39e"]["ZIndex"] = 2;
G2L["39e"]["BackgroundTransparency"] = 1;
G2L["39e"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["39e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39e"]["Text"] = [[]];
G2L["39e"]["Name"] = [[Button]];
G2L["39e"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Local.Background
G2L["39f"] = Instance.new("ImageLabel", G2L["39c"]);
G2L["39f"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["39f"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["39f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["39f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["39f"]["BackgroundTransparency"] = 1;
G2L["39f"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Local.Label
G2L["3a0"] = Instance.new("TextLabel", G2L["39c"]);
G2L["3a0"]["BorderSizePixel"] = 0;
G2L["3a0"]["TextSize"] = 10;
G2L["3a0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3a0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a0"]["BackgroundTransparency"] = 1;
G2L["3a0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3a0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a0"]["Text"] = [[LOCAL]];
G2L["3a0"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Last
G2L["3a1"] = Instance.new("Frame", G2L["396"]);
G2L["3a1"]["BorderSizePixel"] = 0;
G2L["3a1"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["3a1"]["Position"] = UDim2.new(0, 180, 0, 0);
G2L["3a1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a1"]["Name"] = [[Last]];
G2L["3a1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Last.SelectedIndicator
G2L["3a2"] = Instance.new("Frame", G2L["3a1"]);
G2L["3a2"]["BorderSizePixel"] = 0;
G2L["3a2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a2"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["3a2"]["Position"] = UDim2.new(0, 6, 0, -2);
G2L["3a2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a2"]["Name"] = [[SelectedIndicator]];
G2L["3a2"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Last.Button
G2L["3a3"] = Instance.new("TextButton", G2L["3a1"]);
G2L["3a3"]["BorderSizePixel"] = 0;
G2L["3a3"]["TextTransparency"] = 1;
G2L["3a3"]["ZIndex"] = 2;
G2L["3a3"]["BackgroundTransparency"] = 1;
G2L["3a3"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3a3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a3"]["Text"] = [[]];
G2L["3a3"]["Name"] = [[Button]];
G2L["3a3"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Last.Background
G2L["3a4"] = Instance.new("ImageLabel", G2L["3a1"]);
G2L["3a4"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3a4"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3a4"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3a4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a4"]["BackgroundTransparency"] = 1;
G2L["3a4"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Last.Label
G2L["3a5"] = Instance.new("TextLabel", G2L["3a1"]);
G2L["3a5"]["BorderSizePixel"] = 0;
G2L["3a5"]["TextSize"] = 10;
G2L["3a5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3a5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a5"]["BackgroundTransparency"] = 1;
G2L["3a5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3a5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a5"]["Text"] = [[LAST]];
G2L["3a5"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Label
G2L["3a6"] = Instance.new("Frame", G2L["396"]);
G2L["3a6"]["BorderSizePixel"] = 0;
G2L["3a6"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["3a6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a6"]["Name"] = [[Label]];
G2L["3a6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.PivotOption.Label.TextLabel
G2L["3a7"] = Instance.new("TextLabel", G2L["3a6"]);
G2L["3a7"]["TextWrapped"] = true;
G2L["3a7"]["TextStrokeTransparency"] = 0;
G2L["3a7"]["BorderSizePixel"] = 0;
G2L["3a7"]["TextSize"] = 10;
G2L["3a7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3a7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a7"]["BackgroundTransparency"] = 1;
G2L["3a7"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3a7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a7"]["Text"] = [[Pivot]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Title
G2L["3a8"] = Instance.new("Frame", G2L["395"]);
G2L["3a8"]["BorderSizePixel"] = 0;
G2L["3a8"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["3a8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a8"]["Name"] = [[Title]];
G2L["3a8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Title.ColorBar
G2L["3a9"] = Instance.new("Frame", G2L["3a8"]);
G2L["3a9"]["BorderSizePixel"] = 0;
G2L["3a9"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["3a9"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["3a9"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["3a9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3a9"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Title.Label
G2L["3aa"] = Instance.new("TextLabel", G2L["3a8"]);
G2L["3aa"]["TextWrapped"] = true;
G2L["3aa"]["TextStrokeTransparency"] = 0;
G2L["3aa"]["BorderSizePixel"] = 0;
G2L["3aa"]["TextSize"] = 10;
G2L["3aa"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3aa"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3aa"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3aa"]["BackgroundTransparency"] = 1;
G2L["3aa"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3aa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3aa"]["Text"] = [[ROTATE TOOL]];
G2L["3aa"]["Name"] = [[Label]];
G2L["3aa"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Title.F3XSignature
G2L["3ab"] = Instance.new("TextLabel", G2L["3a8"]);
G2L["3ab"]["TextWrapped"] = true;
G2L["3ab"]["TextStrokeTransparency"] = 0.9;
G2L["3ab"]["BorderSizePixel"] = 0;
G2L["3ab"]["TextSize"] = 14;
G2L["3ab"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["3ab"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ab"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ab"]["BackgroundTransparency"] = 1;
G2L["3ab"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3ab"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ab"]["Text"] = [[F3X]];
G2L["3ab"]["Name"] = [[F3XSignature]];
G2L["3ab"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption
G2L["3ac"] = Instance.new("Frame", G2L["395"]);
G2L["3ac"]["BorderSizePixel"] = 0;
G2L["3ac"]["Position"] = UDim2.new(0, 0, 0, 65);
G2L["3ac"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ac"]["Name"] = [[IncrementOption]];
G2L["3ac"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Increment
G2L["3ad"] = Instance.new("Frame", G2L["3ac"]);
G2L["3ad"]["BorderSizePixel"] = 0;
G2L["3ad"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["3ad"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["3ad"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ad"]["Name"] = [[Increment]];
G2L["3ad"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Increment.SelectedIndicator
G2L["3ae"] = Instance.new("Frame", G2L["3ad"]);
G2L["3ae"]["BorderSizePixel"] = 0;
G2L["3ae"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ae"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["3ae"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["3ae"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ae"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Increment.TextBox
G2L["3af"] = Instance.new("TextBox", G2L["3ad"]);
G2L["3af"]["ZIndex"] = 2;
G2L["3af"]["BorderSizePixel"] = 0;
G2L["3af"]["TextSize"] = 10;
G2L["3af"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3af"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3af"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3af"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3af"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3af"]["Text"] = [[15]];
G2L["3af"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Increment.Background
G2L["3b0"] = Instance.new("ImageLabel", G2L["3ad"]);
G2L["3b0"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3b0"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3b0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3b0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b0"]["BackgroundTransparency"] = 1;
G2L["3b0"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Label
G2L["3b1"] = Instance.new("Frame", G2L["3ac"]);
G2L["3b1"]["BorderSizePixel"] = 0;
G2L["3b1"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["3b1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b1"]["Name"] = [[Label]];
G2L["3b1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.IncrementOption.Label.TextLabel
G2L["3b2"] = Instance.new("TextLabel", G2L["3b1"]);
G2L["3b2"]["TextWrapped"] = true;
G2L["3b2"]["TextStrokeTransparency"] = 0;
G2L["3b2"]["BorderSizePixel"] = 0;
G2L["3b2"]["TextSize"] = 10;
G2L["3b2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3b2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b2"]["BackgroundTransparency"] = 1;
G2L["3b2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3b2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b2"]["Text"] = [[Increment]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info
G2L["3b3"] = Instance.new("Frame", G2L["395"]);
G2L["3b3"]["Visible"] = false;
G2L["3b3"]["BorderSizePixel"] = 0;
G2L["3b3"]["Size"] = UDim2.new(1, -5, 0, 60);
G2L["3b3"]["Position"] = UDim2.new(0, 5, 0, 100);
G2L["3b3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b3"]["Name"] = [[Info]];
G2L["3b3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.ColorBar
G2L["3b4"] = Instance.new("Frame", G2L["3b3"]);
G2L["3b4"]["BorderSizePixel"] = 0;
G2L["3b4"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["3b4"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["3b4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b4"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.Label
G2L["3b5"] = Instance.new("TextLabel", G2L["3b3"]);
G2L["3b5"]["TextWrapped"] = true;
G2L["3b5"]["TextStrokeTransparency"] = 0;
G2L["3b5"]["BorderSizePixel"] = 0;
G2L["3b5"]["TextSize"] = 10;
G2L["3b5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3b5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b5"]["BackgroundTransparency"] = 1;
G2L["3b5"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["3b5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b5"]["Text"] = [[SELECTION INFO]];
G2L["3b5"]["Name"] = [[Label]];
G2L["3b5"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo
G2L["3b6"] = Instance.new("Frame", G2L["3b3"]);
G2L["3b6"]["BorderSizePixel"] = 0;
G2L["3b6"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["3b6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b6"]["Name"] = [[RotationInfo]];
G2L["3b6"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.TextLabel
G2L["3b7"] = Instance.new("TextLabel", G2L["3b6"]);
G2L["3b7"]["TextWrapped"] = true;
G2L["3b7"]["TextStrokeTransparency"] = 0;
G2L["3b7"]["BorderSizePixel"] = 0;
G2L["3b7"]["TextSize"] = 10;
G2L["3b7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3b7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b7"]["BackgroundTransparency"] = 1;
G2L["3b7"]["Size"] = UDim2.new(0, 75, 0, 25);
G2L["3b7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b7"]["Text"] = [[Rotation]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.X
G2L["3b8"] = Instance.new("Frame", G2L["3b6"]);
G2L["3b8"]["BorderSizePixel"] = 0;
G2L["3b8"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["3b8"]["Position"] = UDim2.new(0, 70, 0, 0);
G2L["3b8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b8"]["Name"] = [[X]];
G2L["3b8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.X.TextBox
G2L["3b9"] = Instance.new("TextBox", G2L["3b8"]);
G2L["3b9"]["ZIndex"] = 2;
G2L["3b9"]["BorderSizePixel"] = 0;
G2L["3b9"]["TextSize"] = 10;
G2L["3b9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3b9"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3b9"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3b9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3b9"]["Text"] = [[]];
G2L["3b9"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.X.Background
G2L["3ba"] = Instance.new("ImageLabel", G2L["3b8"]);
G2L["3ba"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3ba"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3ba"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3ba"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ba"]["BackgroundTransparency"] = 1;
G2L["3ba"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Y
G2L["3bb"] = Instance.new("Frame", G2L["3b6"]);
G2L["3bb"]["BorderSizePixel"] = 0;
G2L["3bb"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["3bb"]["Position"] = UDim2.new(0, 117, 0, 0);
G2L["3bb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3bb"]["Name"] = [[Y]];
G2L["3bb"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Y.TextBox
G2L["3bc"] = Instance.new("TextBox", G2L["3bb"]);
G2L["3bc"]["ZIndex"] = 2;
G2L["3bc"]["BorderSizePixel"] = 0;
G2L["3bc"]["TextSize"] = 10;
G2L["3bc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3bc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3bc"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3bc"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3bc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3bc"]["Text"] = [[]];
G2L["3bc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Y.Background
G2L["3bd"] = Instance.new("ImageLabel", G2L["3bb"]);
G2L["3bd"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3bd"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3bd"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3bd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3bd"]["BackgroundTransparency"] = 1;
G2L["3bd"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Z
G2L["3be"] = Instance.new("Frame", G2L["3b6"]);
G2L["3be"]["BorderSizePixel"] = 0;
G2L["3be"]["Size"] = UDim2.new(0, 50, 0, 25);
G2L["3be"]["Position"] = UDim2.new(0, 164, 0, 0);
G2L["3be"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3be"]["Name"] = [[Z]];
G2L["3be"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Z.TextBox
G2L["3bf"] = Instance.new("TextBox", G2L["3be"]);
G2L["3bf"]["ZIndex"] = 2;
G2L["3bf"]["BorderSizePixel"] = 0;
G2L["3bf"]["TextSize"] = 10;
G2L["3bf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3bf"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3bf"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3bf"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3bf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3bf"]["Text"] = [[]];
G2L["3bf"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Info.RotationInfo.Z.Background
G2L["3c0"] = Instance.new("ImageLabel", G2L["3be"]);
G2L["3c0"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3c0"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3c0"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3c0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c0"]["BackgroundTransparency"] = 1;
G2L["3c0"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Changes
G2L["3c1"] = Instance.new("Frame", G2L["395"]);
G2L["3c1"]["BorderSizePixel"] = 0;
G2L["3c1"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["3c1"]["Position"] = UDim2.new(0, 5, 1, 10);
G2L["3c1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c1"]["Name"] = [[Changes]];
G2L["3c1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Changes.ColorBar
G2L["3c2"] = Instance.new("Frame", G2L["3c1"]);
G2L["3c2"]["BorderSizePixel"] = 0;
G2L["3c2"]["BackgroundColor3"] = Color3.fromRGB(76, 152, 76);
G2L["3c2"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["3c2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c2"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTRotateToolGUI.Changes.Text
G2L["3c3"] = Instance.new("TextLabel", G2L["3c1"]);
G2L["3c3"]["TextWrapped"] = true;
G2L["3c3"]["TextStrokeTransparency"] = 0.5;
G2L["3c3"]["BorderSizePixel"] = 0;
G2L["3c3"]["TextSize"] = 10;
G2L["3c3"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["3c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c3"]["BackgroundTransparency"] = 1;
G2L["3c3"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["3c3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c3"]["Text"] = [[rotated 0 degrees]];
G2L["3c3"]["Name"] = [[Text]];
G2L["3c3"]["Position"] = UDim2.new(0, 10, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI
G2L["3c4"] = Instance.new("Frame", G2L["52"]);
G2L["3c4"]["Active"] = true;
G2L["3c4"]["BorderSizePixel"] = 0;
G2L["3c4"]["Size"] = UDim2.new(0, 245, 0, 90);
G2L["3c4"]["Position"] = UDim2.new(0, 0, 0.4, 0);
G2L["3c4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c4"]["Name"] = [[BTSurfaceToolGUI]];
G2L["3c4"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Title
G2L["3c5"] = Instance.new("Frame", G2L["3c4"]);
G2L["3c5"]["BorderSizePixel"] = 0;
G2L["3c5"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["3c5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c5"]["Name"] = [[Title]];
G2L["3c5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Title.ColorBar
G2L["3c6"] = Instance.new("Frame", G2L["3c5"]);
G2L["3c6"]["BorderSizePixel"] = 0;
G2L["3c6"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["3c6"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["3c6"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["3c6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c6"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Title.Label
G2L["3c7"] = Instance.new("TextLabel", G2L["3c5"]);
G2L["3c7"]["TextWrapped"] = true;
G2L["3c7"]["TextStrokeTransparency"] = 0;
G2L["3c7"]["BorderSizePixel"] = 0;
G2L["3c7"]["TextSize"] = 10;
G2L["3c7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c7"]["BackgroundTransparency"] = 1;
G2L["3c7"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3c7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c7"]["Text"] = [[SURFACE TOOL]];
G2L["3c7"]["Name"] = [[Label]];
G2L["3c7"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Title.F3XSignature
G2L["3c8"] = Instance.new("TextLabel", G2L["3c5"]);
G2L["3c8"]["TextWrapped"] = true;
G2L["3c8"]["TextStrokeTransparency"] = 0.9;
G2L["3c8"]["BorderSizePixel"] = 0;
G2L["3c8"]["TextSize"] = 14;
G2L["3c8"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["3c8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3c8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c8"]["BackgroundTransparency"] = 1;
G2L["3c8"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3c8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c8"]["Text"] = [[F3X]];
G2L["3c8"]["Name"] = [[F3XSignature]];
G2L["3c8"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption
G2L["3c9"] = Instance.new("Frame", G2L["3c4"]);
G2L["3c9"]["BorderSizePixel"] = 0;
G2L["3c9"]["Size"] = UDim2.new(0, 120, 0, 25);
G2L["3c9"]["Position"] = UDim2.new(0, 14, 0, 30);
G2L["3c9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3c9"]["Name"] = [[SideOption]];
G2L["3c9"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Label
G2L["3ca"] = Instance.new("TextLabel", G2L["3c9"]);
G2L["3ca"]["TextWrapped"] = true;
G2L["3ca"]["TextStrokeTransparency"] = 0;
G2L["3ca"]["BorderSizePixel"] = 0;
G2L["3ca"]["TextSize"] = 10;
G2L["3ca"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3ca"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ca"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ca"]["BackgroundTransparency"] = 1;
G2L["3ca"]["Size"] = UDim2.new(0, 40, 0, 25);
G2L["3ca"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ca"]["Text"] = [[Side]];
G2L["3ca"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown
G2L["3cb"] = Instance.new("TextButton", G2L["3c9"]);
G2L["3cb"]["TextStrokeTransparency"] = 0.8;
G2L["3cb"]["BorderSizePixel"] = 0;
G2L["3cb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3cb"]["TextSize"] = 10;
G2L["3cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3cb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3cb"]["BackgroundTransparency"] = 0.3;
G2L["3cb"]["Size"] = UDim2.new(0, 72, 0, 25);
G2L["3cb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3cb"]["Text"] = [[]];
G2L["3cb"]["Name"] = [[Dropdown]];
G2L["3cb"]["Position"] = UDim2.new(0, 30, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.Icon
G2L["3cc"] = Instance.new("ImageLabel", G2L["3cb"]);
G2L["3cc"]["ZIndex"] = 3;
G2L["3cc"]["BorderSizePixel"] = 0;
G2L["3cc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3cc"]["Image"] = [[rbxassetid://134367382]];
G2L["3cc"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["3cc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3cc"]["BackgroundTransparency"] = 1;
G2L["3cc"]["Name"] = [[Icon]];
G2L["3cc"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.OptionButton
G2L["3cd"] = Instance.new("TextButton", G2L["3cb"]);
G2L["3cd"]["TextStrokeTransparency"] = 0.8;
G2L["3cd"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3cd"]["TextSize"] = 10;
G2L["3cd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3cd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3cd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3cd"]["ZIndex"] = 4;
G2L["3cd"]["BackgroundTransparency"] = 0.3;
G2L["3cd"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["3cd"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3cd"]["Text"] = [[]];
G2L["3cd"]["Name"] = [[OptionButton]];
G2L["3cd"]["Visible"] = false;
G2L["3cd"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.OptionButton.OptionLabel
G2L["3ce"] = Instance.new("TextLabel", G2L["3cd"]);
G2L["3ce"]["ZIndex"] = 4;
G2L["3ce"]["BorderSizePixel"] = 0;
G2L["3ce"]["TextSize"] = 11;
G2L["3ce"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3ce"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ce"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ce"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ce"]["BackgroundTransparency"] = 1;
G2L["3ce"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["3ce"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ce"]["Text"] = [[ALL]];
G2L["3ce"]["Name"] = [[OptionLabel]];
G2L["3ce"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.Options
G2L["3cf"] = Instance.new("Folder", G2L["3cb"]);
G2L["3cf"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.Border
G2L["3d0"] = Instance.new("Frame", G2L["3cb"]);
G2L["3d0"]["BorderSizePixel"] = 0;
G2L["3d0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d0"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["3d0"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["3d0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d0"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.CurrentOption
G2L["3d1"] = Instance.new("TextLabel", G2L["3cb"]);
G2L["3d1"]["ZIndex"] = 3;
G2L["3d1"]["BorderSizePixel"] = 0;
G2L["3d1"]["TextSize"] = 10;
G2L["3d1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3d1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d1"]["BackgroundTransparency"] = 1;
G2L["3d1"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["3d1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d1"]["Text"] = [[ALL]];
G2L["3d1"]["Name"] = [[CurrentOption]];
G2L["3d1"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.[Component]
G2L["3d2"] = Instance.new("LocalScript", G2L["3cb"]);
G2L["3d2"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption
G2L["3d3"] = Instance.new("Frame", G2L["3c4"]);
G2L["3d3"]["BorderSizePixel"] = 0;
G2L["3d3"]["Size"] = UDim2.new(0, 120, 0, 25);
G2L["3d3"]["Position"] = UDim2.new(0, 124, 0, 30);
G2L["3d3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d3"]["Name"] = [[TypeOption]];
G2L["3d3"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Label
G2L["3d4"] = Instance.new("TextLabel", G2L["3d3"]);
G2L["3d4"]["TextWrapped"] = true;
G2L["3d4"]["TextStrokeTransparency"] = 0;
G2L["3d4"]["BorderSizePixel"] = 0;
G2L["3d4"]["TextSize"] = 10;
G2L["3d4"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d4"]["BackgroundTransparency"] = 1;
G2L["3d4"]["Size"] = UDim2.new(0, 40, 0, 25);
G2L["3d4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d4"]["Text"] = [[Type]];
G2L["3d4"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown
G2L["3d5"] = Instance.new("TextButton", G2L["3d3"]);
G2L["3d5"]["TextStrokeTransparency"] = 0.8;
G2L["3d5"]["BorderSizePixel"] = 0;
G2L["3d5"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3d5"]["TextSize"] = 10;
G2L["3d5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3d5"]["BackgroundTransparency"] = 0.3;
G2L["3d5"]["Size"] = UDim2.new(0, 91, 0, 25);
G2L["3d5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d5"]["Text"] = [[]];
G2L["3d5"]["Name"] = [[Dropdown]];
G2L["3d5"]["Position"] = UDim2.new(0, 30, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.Icon
G2L["3d6"] = Instance.new("ImageLabel", G2L["3d5"]);
G2L["3d6"]["ZIndex"] = 3;
G2L["3d6"]["BorderSizePixel"] = 0;
G2L["3d6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3d6"]["Image"] = [[rbxassetid://134367382]];
G2L["3d6"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["3d6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d6"]["BackgroundTransparency"] = 1;
G2L["3d6"]["Name"] = [[Icon]];
G2L["3d6"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.OptionButton
G2L["3d7"] = Instance.new("TextButton", G2L["3d5"]);
G2L["3d7"]["TextStrokeTransparency"] = 0.8;
G2L["3d7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3d7"]["TextSize"] = 10;
G2L["3d7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3d7"]["ZIndex"] = 4;
G2L["3d7"]["BackgroundTransparency"] = 0.3;
G2L["3d7"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["3d7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d7"]["Text"] = [[]];
G2L["3d7"]["Name"] = [[OptionButton]];
G2L["3d7"]["Visible"] = false;
G2L["3d7"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.OptionButton.OptionLabel
G2L["3d8"] = Instance.new("TextLabel", G2L["3d7"]);
G2L["3d8"]["ZIndex"] = 4;
G2L["3d8"]["BorderSizePixel"] = 0;
G2L["3d8"]["TextSize"] = 11;
G2L["3d8"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3d8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3d8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d8"]["BackgroundTransparency"] = 1;
G2L["3d8"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["3d8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3d8"]["Text"] = [[ALL]];
G2L["3d8"]["Name"] = [[OptionLabel]];
G2L["3d8"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.Options
G2L["3d9"] = Instance.new("Folder", G2L["3d5"]);
G2L["3d9"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.Border
G2L["3da"] = Instance.new("Frame", G2L["3d5"]);
G2L["3da"]["BorderSizePixel"] = 0;
G2L["3da"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3da"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["3da"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["3da"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3da"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.CurrentOption
G2L["3db"] = Instance.new("TextLabel", G2L["3d5"]);
G2L["3db"]["ZIndex"] = 3;
G2L["3db"]["BorderSizePixel"] = 0;
G2L["3db"]["TextSize"] = 10;
G2L["3db"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3db"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3db"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3db"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3db"]["BackgroundTransparency"] = 1;
G2L["3db"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["3db"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3db"]["Text"] = [[]];
G2L["3db"]["Name"] = [[CurrentOption]];
G2L["3db"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.[Component]
G2L["3dc"] = Instance.new("LocalScript", G2L["3d5"]);
G2L["3dc"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Tip
G2L["3dd"] = Instance.new("Frame", G2L["3c4"]);
G2L["3dd"]["BorderSizePixel"] = 0;
G2L["3dd"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["3dd"]["Position"] = UDim2.new(0, 5, 0, 70);
G2L["3dd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3dd"]["Name"] = [[Tip]];
G2L["3dd"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Tip.ColorBar
G2L["3de"] = Instance.new("Frame", G2L["3dd"]);
G2L["3de"]["BorderSizePixel"] = 0;
G2L["3de"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["3de"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["3de"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3de"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.Tip.Text
G2L["3df"] = Instance.new("TextLabel", G2L["3dd"]);
G2L["3df"]["TextWrapped"] = true;
G2L["3df"]["TextStrokeTransparency"] = 0.5;
G2L["3df"]["BorderSizePixel"] = 0;
G2L["3df"]["TextSize"] = 10;
G2L["3df"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3df"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3df"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3df"]["BackgroundTransparency"] = 1;
G2L["3df"]["Size"] = UDim2.new(1, -6, 0, 20);
G2L["3df"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3df"]["Text"] = [[TIP: Click on the side of a part to select it.]];
G2L["3df"]["Name"] = [[Text]];
G2L["3df"]["Position"] = UDim2.new(0, 6, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI
G2L["3e0"] = Instance.new("Frame", G2L["52"]);
G2L["3e0"]["Active"] = true;
G2L["3e0"]["BorderSizePixel"] = 0;
G2L["3e0"]["Size"] = UDim2.new(0, 200, 0, 205);
G2L["3e0"]["Position"] = UDim2.new(0, 0, 0.35, 0);
G2L["3e0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e0"]["Name"] = [[BTTextureToolGUI]];
G2L["3e0"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.Title
G2L["3e1"] = Instance.new("Frame", G2L["3e0"]);
G2L["3e1"]["BorderSizePixel"] = 0;
G2L["3e1"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["3e1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e1"]["Name"] = [[Title]];
G2L["3e1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.Title.ColorBar
G2L["3e2"] = Instance.new("Frame", G2L["3e1"]);
G2L["3e2"]["BorderSizePixel"] = 0;
G2L["3e2"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["3e2"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["3e2"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["3e2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e2"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.Title.Label
G2L["3e3"] = Instance.new("TextLabel", G2L["3e1"]);
G2L["3e3"]["TextWrapped"] = true;
G2L["3e3"]["TextStrokeTransparency"] = 0;
G2L["3e3"]["BorderSizePixel"] = 0;
G2L["3e3"]["TextSize"] = 10;
G2L["3e3"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e3"]["BackgroundTransparency"] = 1;
G2L["3e3"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3e3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e3"]["Text"] = [[TEXTURE TOOL]];
G2L["3e3"]["Name"] = [[Label]];
G2L["3e3"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.Title.F3XSignature
G2L["3e4"] = Instance.new("TextLabel", G2L["3e1"]);
G2L["3e4"]["TextWrapped"] = true;
G2L["3e4"]["TextStrokeTransparency"] = 0.9;
G2L["3e4"]["BorderSizePixel"] = 0;
G2L["3e4"]["TextSize"] = 14;
G2L["3e4"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["3e4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3e4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e4"]["BackgroundTransparency"] = 1;
G2L["3e4"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3e4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e4"]["Text"] = [[F3X]];
G2L["3e4"]["Name"] = [[F3XSignature]];
G2L["3e4"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption
G2L["3e5"] = Instance.new("Frame", G2L["3e0"]);
G2L["3e5"]["BorderSizePixel"] = 0;
G2L["3e5"]["Size"] = UDim2.new(1, -14, 0, 25);
G2L["3e5"]["Position"] = UDim2.new(0, 14, 0, 65);
G2L["3e5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e5"]["Name"] = [[SideOption]];
G2L["3e5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Label
G2L["3e6"] = Instance.new("TextLabel", G2L["3e5"]);
G2L["3e6"]["TextWrapped"] = true;
G2L["3e6"]["TextStrokeTransparency"] = 0;
G2L["3e6"]["BorderSizePixel"] = 0;
G2L["3e6"]["TextSize"] = 10;
G2L["3e6"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3e6"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3e6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e6"]["BackgroundTransparency"] = 1;
G2L["3e6"]["Size"] = UDim2.new(0, 30, 0, 25);
G2L["3e6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e6"]["Text"] = [[Side]];
G2L["3e6"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown
G2L["3e7"] = Instance.new("TextButton", G2L["3e5"]);
G2L["3e7"]["TextStrokeTransparency"] = 0.8;
G2L["3e7"]["BorderSizePixel"] = 0;
G2L["3e7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3e7"]["TextSize"] = 10;
G2L["3e7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3e7"]["BackgroundTransparency"] = 0.3;
G2L["3e7"]["Size"] = UDim2.new(1, -45, 0, 25);
G2L["3e7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e7"]["Text"] = [[]];
G2L["3e7"]["Name"] = [[Dropdown]];
G2L["3e7"]["Position"] = UDim2.new(0, 30, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.Icon
G2L["3e8"] = Instance.new("ImageLabel", G2L["3e7"]);
G2L["3e8"]["ZIndex"] = 3;
G2L["3e8"]["BorderSizePixel"] = 0;
G2L["3e8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3e8"]["Image"] = [[rbxassetid://134367382]];
G2L["3e8"]["Size"] = UDim2.new(0, 20, 0, 20);
G2L["3e8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3e8"]["BackgroundTransparency"] = 1;
G2L["3e8"]["Name"] = [[Icon]];
G2L["3e8"]["Position"] = UDim2.new(1, -21, 0, 3);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.OptionButton
G2L["3e9"] = Instance.new("TextButton", G2L["3e7"]);
G2L["3e9"]["TextStrokeTransparency"] = 0.8;
G2L["3e9"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3e9"]["TextSize"] = 10;
G2L["3e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3e9"]["ZIndex"] = 4;
G2L["3e9"]["BackgroundTransparency"] = 0.3;
G2L["3e9"]["Size"] = UDim2.new(1, -2, 1, 0);
G2L["3e9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e9"]["Text"] = [[]];
G2L["3e9"]["Name"] = [[OptionButton]];
G2L["3e9"]["Visible"] = false;
G2L["3e9"]["Position"] = UDim2.new(0, 1, 1, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.OptionButton.OptionLabel
G2L["3ea"] = Instance.new("TextLabel", G2L["3e9"]);
G2L["3ea"]["ZIndex"] = 4;
G2L["3ea"]["BorderSizePixel"] = 0;
G2L["3ea"]["TextSize"] = 10;
G2L["3ea"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3ea"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ea"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ea"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ea"]["BackgroundTransparency"] = 1;
G2L["3ea"]["Size"] = UDim2.new(0.9, 0, 1, 0);
G2L["3ea"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ea"]["Text"] = [[ALL]];
G2L["3ea"]["Name"] = [[OptionLabel]];
G2L["3ea"]["Position"] = UDim2.new(0.07, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.Options
G2L["3eb"] = Instance.new("Folder", G2L["3e7"]);
G2L["3eb"]["Name"] = [[Options]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.Border
G2L["3ec"] = Instance.new("Frame", G2L["3e7"]);
G2L["3ec"]["BorderSizePixel"] = 0;
G2L["3ec"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ec"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["3ec"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["3ec"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ec"]["Name"] = [[Border]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.CurrentOption
G2L["3ed"] = Instance.new("TextLabel", G2L["3e7"]);
G2L["3ed"]["ZIndex"] = 3;
G2L["3ed"]["BorderSizePixel"] = 0;
G2L["3ed"]["TextSize"] = 10;
G2L["3ed"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3ed"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ed"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ed"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ed"]["BackgroundTransparency"] = 1;
G2L["3ed"]["Size"] = UDim2.new(1, -21, 1, 0);
G2L["3ed"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ed"]["Text"] = [[]];
G2L["3ed"]["Name"] = [[CurrentOption]];
G2L["3ed"]["Position"] = UDim2.new(0, 6, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.[Component]
G2L["3ee"] = Instance.new("LocalScript", G2L["3e7"]);
G2L["3ee"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption
G2L["3ef"] = Instance.new("Frame", G2L["3e0"]);
G2L["3ef"]["Visible"] = false;
G2L["3ef"]["BorderSizePixel"] = 0;
G2L["3ef"]["Size"] = UDim2.new(0, 200, 0, 24);
G2L["3ef"]["Position"] = UDim2.new(0, 0, 0, 205);
G2L["3ef"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ef"]["Name"] = [[RepeatOption]];
G2L["3ef"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.Label
G2L["3f0"] = Instance.new("TextLabel", G2L["3ef"]);
G2L["3f0"]["TextWrapped"] = true;
G2L["3f0"]["TextStrokeTransparency"] = 0;
G2L["3f0"]["BorderSizePixel"] = 0;
G2L["3f0"]["TextSize"] = 10;
G2L["3f0"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f0"]["BackgroundTransparency"] = 1;
G2L["3f0"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["3f0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f0"]["Text"] = [[Repeat]];
G2L["3f0"]["Name"] = [[Label]];
G2L["3f0"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.XInput
G2L["3f1"] = Instance.new("Frame", G2L["3ef"]);
G2L["3f1"]["BorderSizePixel"] = 0;
G2L["3f1"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["3f1"]["Position"] = UDim2.new(0, 60, 0, 0);
G2L["3f1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f1"]["Name"] = [[XInput]];
G2L["3f1"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.XInput.Background
G2L["3f2"] = Instance.new("ImageLabel", G2L["3f1"]);
G2L["3f2"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3f2"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3f2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3f2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f2"]["BackgroundTransparency"] = 1;
G2L["3f2"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.XInput.SelectedIndicator
G2L["3f3"] = Instance.new("Frame", G2L["3f1"]);
G2L["3f3"]["BorderSizePixel"] = 0;
G2L["3f3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f3"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["3f3"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["3f3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f3"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.XInput.TextBox
G2L["3f4"] = Instance.new("TextBox", G2L["3f1"]);
G2L["3f4"]["BorderSizePixel"] = 0;
G2L["3f4"]["TextSize"] = 10;
G2L["3f4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3f4"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3f4"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3f4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f4"]["Text"] = [[2]];
G2L["3f4"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.YInput
G2L["3f5"] = Instance.new("Frame", G2L["3ef"]);
G2L["3f5"]["BorderSizePixel"] = 0;
G2L["3f5"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["3f5"]["Position"] = UDim2.new(0, 105, 0, 0);
G2L["3f5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f5"]["Name"] = [[YInput]];
G2L["3f5"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.YInput.Background
G2L["3f6"] = Instance.new("ImageLabel", G2L["3f5"]);
G2L["3f6"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3f6"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3f6"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3f6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f6"]["BackgroundTransparency"] = 1;
G2L["3f6"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.YInput.SelectedIndicator
G2L["3f7"] = Instance.new("Frame", G2L["3f5"]);
G2L["3f7"]["BorderSizePixel"] = 0;
G2L["3f7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f7"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["3f7"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["3f7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f7"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RepeatOption.YInput.TextBox
G2L["3f8"] = Instance.new("TextBox", G2L["3f5"]);
G2L["3f8"]["BorderSizePixel"] = 0;
G2L["3f8"]["TextSize"] = 10;
G2L["3f8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f8"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3f8"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3f8"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3f8"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f8"]["Text"] = [[2]];
G2L["3f8"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.BottomColorBar
G2L["3f9"] = Instance.new("Frame", G2L["3e0"]);
G2L["3f9"]["BorderSizePixel"] = 0;
G2L["3f9"]["BackgroundColor3"] = Color3.fromRGB(108, 51, 125);
G2L["3f9"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["3f9"]["Position"] = UDim2.new(0, 5, 1, -2);
G2L["3f9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3f9"]["Name"] = [[BottomColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption
G2L["3fa"] = Instance.new("Frame", G2L["3e0"]);
G2L["3fa"]["BorderSizePixel"] = 0;
G2L["3fa"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["3fa"]["Position"] = UDim2.new(0, 14, 0, 135);
G2L["3fa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fa"]["Name"] = [[TransparencyOption]];
G2L["3fa"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption.Label
G2L["3fb"] = Instance.new("TextLabel", G2L["3fa"]);
G2L["3fb"]["TextWrapped"] = true;
G2L["3fb"]["TextStrokeTransparency"] = 0;
G2L["3fb"]["BorderSizePixel"] = 0;
G2L["3fb"]["TextSize"] = 10;
G2L["3fb"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3fb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3fb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3fb"]["BackgroundTransparency"] = 1;
G2L["3fb"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["3fb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fb"]["Text"] = [[Transparency]];
G2L["3fb"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption.Input
G2L["3fc"] = Instance.new("Frame", G2L["3fa"]);
G2L["3fc"]["BorderSizePixel"] = 0;
G2L["3fc"]["Size"] = UDim2.new(0, 45, 0, 25);
G2L["3fc"]["Position"] = UDim2.new(0, 75, 0, 0);
G2L["3fc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fc"]["Name"] = [[Input]];
G2L["3fc"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption.Input.Background
G2L["3fd"] = Instance.new("ImageLabel", G2L["3fc"]);
G2L["3fd"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["3fd"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["3fd"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["3fd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fd"]["BackgroundTransparency"] = 1;
G2L["3fd"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption.Input.SelectedIndicator
G2L["3fe"] = Instance.new("Frame", G2L["3fc"]);
G2L["3fe"]["BorderSizePixel"] = 0;
G2L["3fe"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3fe"]["Size"] = UDim2.new(1, -4, 0, 2);
G2L["3fe"]["Position"] = UDim2.new(0, 5, 0, -2);
G2L["3fe"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fe"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.TransparencyOption.Input.TextBox
G2L["3ff"] = Instance.new("TextBox", G2L["3fc"]);
G2L["3ff"]["BorderSizePixel"] = 0;
G2L["3ff"]["TextSize"] = 10;
G2L["3ff"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ff"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["3ff"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["3ff"]["Position"] = UDim2.new(0, 5, 0, 0);
G2L["3ff"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ff"]["Text"] = [[0]];
G2L["3ff"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption
G2L["400"] = Instance.new("Frame", G2L["3e0"]);
G2L["400"]["BorderSizePixel"] = 0;
G2L["400"]["Size"] = UDim2.new(0, 200, 0, 23);
G2L["400"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["400"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["400"]["Name"] = [[ModeOption]];
G2L["400"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Label
G2L["401"] = Instance.new("TextLabel", G2L["400"]);
G2L["401"]["TextWrapped"] = true;
G2L["401"]["TextStrokeTransparency"] = 0;
G2L["401"]["BorderSizePixel"] = 0;
G2L["401"]["TextSize"] = 10;
G2L["401"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["401"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["401"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["401"]["BackgroundTransparency"] = 1;
G2L["401"]["Size"] = UDim2.new(0, 40, 0, 25);
G2L["401"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["401"]["Text"] = [[Mode]];
G2L["401"]["Name"] = [[Label]];
G2L["401"]["Position"] = UDim2.new(0, 14, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Decal
G2L["402"] = Instance.new("Frame", G2L["400"]);
G2L["402"]["BorderSizePixel"] = 0;
G2L["402"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["402"]["Position"] = UDim2.new(0, 55, 0, 0);
G2L["402"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["402"]["Name"] = [[Decal]];
G2L["402"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Decal.SelectedIndicator
G2L["403"] = Instance.new("Frame", G2L["402"]);
G2L["403"]["BorderSizePixel"] = 0;
G2L["403"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["403"]["Size"] = UDim2.new(1, -7, 0, 2);
G2L["403"]["Position"] = UDim2.new(0, 7, 0, -2);
G2L["403"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["403"]["Name"] = [[SelectedIndicator]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Decal.Button
G2L["404"] = Instance.new("TextButton", G2L["402"]);
G2L["404"]["BorderSizePixel"] = 0;
G2L["404"]["TextTransparency"] = 1;
G2L["404"]["ZIndex"] = 2;
G2L["404"]["BackgroundTransparency"] = 1;
G2L["404"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["404"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["404"]["Text"] = [[]];
G2L["404"]["Name"] = [[Button]];
G2L["404"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Decal.Background
G2L["405"] = Instance.new("ImageLabel", G2L["402"]);
G2L["405"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["405"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["405"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["405"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["405"]["BackgroundTransparency"] = 1;
G2L["405"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Decal.Label
G2L["406"] = Instance.new("TextLabel", G2L["402"]);
G2L["406"]["BorderSizePixel"] = 0;
G2L["406"]["TextSize"] = 10;
G2L["406"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["406"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["406"]["BackgroundTransparency"] = 1;
G2L["406"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["406"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["406"]["Text"] = [[DECAL]];
G2L["406"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Texture
G2L["407"] = Instance.new("Frame", G2L["400"]);
G2L["407"]["BorderSizePixel"] = 0;
G2L["407"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["407"]["Position"] = UDim2.new(0, 122, 0, 0);
G2L["407"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["407"]["Name"] = [[Texture]];
G2L["407"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Texture.Button
G2L["408"] = Instance.new("TextButton", G2L["407"]);
G2L["408"]["BorderSizePixel"] = 0;
G2L["408"]["TextTransparency"] = 1;
G2L["408"]["ZIndex"] = 2;
G2L["408"]["BackgroundTransparency"] = 1;
G2L["408"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["408"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["408"]["Text"] = [[]];
G2L["408"]["Name"] = [[Button]];
G2L["408"]["Position"] = UDim2.new(0, 5, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Texture.Background
G2L["409"] = Instance.new("ImageLabel", G2L["407"]);
G2L["409"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["409"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["409"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["409"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["409"]["BackgroundTransparency"] = 1;
G2L["409"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Texture.Label
G2L["40a"] = Instance.new("TextLabel", G2L["407"]);
G2L["40a"]["BorderSizePixel"] = 0;
G2L["40a"]["TextSize"] = 10;
G2L["40a"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["40a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40a"]["BackgroundTransparency"] = 1;
G2L["40a"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["40a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40a"]["Text"] = [[TEXTURE]];
G2L["40a"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ModeOption.Texture.SelectedIndicator
G2L["40b"] = Instance.new("Frame", G2L["407"]);
G2L["40b"]["BorderSizePixel"] = 0;
G2L["40b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40b"]["Size"] = UDim2.new(1, -7, 0, 2);
G2L["40b"]["Position"] = UDim2.new(0, 7, 0, -2);
G2L["40b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40b"]["Name"] = [[SelectedIndicator]];
G2L["40b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption
G2L["40c"] = Instance.new("Frame", G2L["3e0"]);
G2L["40c"]["BorderSizePixel"] = 0;
G2L["40c"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["40c"]["Position"] = UDim2.new(0, 14, 0, 100);
G2L["40c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40c"]["Name"] = [[ImageIDOption]];
G2L["40c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.Label
G2L["40d"] = Instance.new("TextLabel", G2L["40c"]);
G2L["40d"]["TextWrapped"] = true;
G2L["40d"]["TextStrokeTransparency"] = 0;
G2L["40d"]["BorderSizePixel"] = 0;
G2L["40d"]["TextSize"] = 10;
G2L["40d"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["40d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["40d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40d"]["BackgroundTransparency"] = 1;
G2L["40d"]["Size"] = UDim2.new(0, 70, 0, 25);
G2L["40d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40d"]["Text"] = [[Image ID]];
G2L["40d"]["Name"] = [[Label]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBoxBorder
G2L["40e"] = Instance.new("Frame", G2L["40c"]);
G2L["40e"]["BorderSizePixel"] = 0;
G2L["40e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40e"]["Size"] = UDim2.new(0, 85, 0, 3);
G2L["40e"]["Position"] = UDim2.new(0, 61, 0, 17);
G2L["40e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40e"]["Name"] = [[TextBoxBorder]];
G2L["40e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBoxBorder.BottomBorder
G2L["40f"] = Instance.new("Frame", G2L["40e"]);
G2L["40f"]["BorderSizePixel"] = 0;
G2L["40f"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["40f"]["Size"] = UDim2.new(1, 0, 0, 1);
G2L["40f"]["Position"] = UDim2.new(0, 0, 1, -1);
G2L["40f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40f"]["Name"] = [[BottomBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBoxBorder.LeftBorder
G2L["410"] = Instance.new("Frame", G2L["40e"]);
G2L["410"]["BorderSizePixel"] = 0;
G2L["410"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["410"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["410"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["410"]["Name"] = [[LeftBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBoxBorder.RightBorder
G2L["411"] = Instance.new("Frame", G2L["40e"]);
G2L["411"]["BorderSizePixel"] = 0;
G2L["411"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["411"]["Size"] = UDim2.new(0, 1, 1, 0);
G2L["411"]["Position"] = UDim2.new(1, -1, 0, 0);
G2L["411"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["411"]["Name"] = [[RightBorder]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBoxBackground
G2L["412"] = Instance.new("Frame", G2L["40c"]);
G2L["412"]["BorderSizePixel"] = 0;
G2L["412"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["412"]["Size"] = UDim2.new(0, 86, 0, 22);
G2L["412"]["Position"] = UDim2.new(0, 60, 0, -2);
G2L["412"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["412"]["Name"] = [[TextBoxBackground]];
G2L["412"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.ImageIDOption.TextBox
G2L["413"] = Instance.new("TextBox", G2L["40c"]);
G2L["413"]["TextStrokeTransparency"] = 0.5;
G2L["413"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["413"]["BorderSizePixel"] = 0;
G2L["413"]["TextWrapped"] = true;
G2L["413"]["TextSize"] = 10;
G2L["413"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["413"]["TextScaled"] = true;
G2L["413"]["BackgroundColor3"] = Color3.fromRGB(86, 0, 128);
G2L["413"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["413"]["Size"] = UDim2.new(0, 80, 0, 18);
G2L["413"]["Position"] = UDim2.new(0, 65, 0, -1);
G2L["413"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["413"]["Text"] = [[]];
G2L["413"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.AddButton
G2L["414"] = Instance.new("Frame", G2L["3e0"]);
G2L["414"]["Visible"] = false;
G2L["414"]["BorderSizePixel"] = 0;
G2L["414"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["414"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["414"]["Position"] = UDim2.new(0, 10, 0, 100);
G2L["414"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["414"]["Name"] = [[AddButton]];
G2L["414"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.AddButton.Button
G2L["415"] = Instance.new("TextButton", G2L["414"]);
G2L["415"]["TextStrokeTransparency"] = 0.8;
G2L["415"]["BorderSizePixel"] = 0;
G2L["415"]["TextSize"] = 10;
G2L["415"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["415"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["415"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["415"]["BackgroundTransparency"] = 0.45;
G2L["415"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["415"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["415"]["Text"] = [[ADD DECAL]];
G2L["415"]["Name"] = [[Button]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.AddButton.Shadow
G2L["416"] = Instance.new("Frame", G2L["414"]);
G2L["416"]["ZIndex"] = 2;
G2L["416"]["BorderSizePixel"] = 0;
G2L["416"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["416"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["416"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["416"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["416"]["Name"] = [[Shadow]];
G2L["416"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RemoveButton
G2L["417"] = Instance.new("Frame", G2L["3e0"]);
G2L["417"]["BorderSizePixel"] = 0;
G2L["417"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["417"]["Size"] = UDim2.new(1, -10, 0, 20);
G2L["417"]["Position"] = UDim2.new(0, 10, 1, -35);
G2L["417"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["417"]["Name"] = [[RemoveButton]];
G2L["417"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RemoveButton.Button
G2L["418"] = Instance.new("TextButton", G2L["417"]);
G2L["418"]["TextStrokeTransparency"] = 0.8;
G2L["418"]["BorderSizePixel"] = 0;
G2L["418"]["TextSize"] = 10;
G2L["418"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["418"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["418"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["418"]["BackgroundTransparency"] = 0.45;
G2L["418"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["418"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["418"]["Text"] = [[REMOVE DECAL]];
G2L["418"]["Name"] = [[Button]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.RemoveButton.Shadow
G2L["419"] = Instance.new("Frame", G2L["417"]);
G2L["419"]["ZIndex"] = 2;
G2L["419"]["BorderSizePixel"] = 0;
G2L["419"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["419"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["419"]["Position"] = UDim2.new(0, 0, 1, 0);
G2L["419"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["419"]["Name"] = [[Shadow]];
G2L["419"]["BackgroundTransparency"] = 0.3;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SelectNote
G2L["41a"] = Instance.new("TextLabel", G2L["3e0"]);
G2L["41a"]["TextWrapped"] = true;
G2L["41a"]["TextStrokeTransparency"] = 0.5;
G2L["41a"]["BorderSizePixel"] = 0;
G2L["41a"]["TextSize"] = 14;
G2L["41a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["41a"]["TextScaled"] = true;
G2L["41a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["41a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["41a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["41a"]["BackgroundTransparency"] = 1;
G2L["41a"]["Size"] = UDim2.new(1, -10, 0, 15);
G2L["41a"]["Visible"] = false;
G2L["41a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41a"]["Text"] = [[Select something to use this tool.]];
G2L["41a"]["Name"] = [[SelectNote]];
G2L["41a"]["Position"] = UDim2.new(0, 10, 0, 27);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI
G2L["41b"] = Instance.new("Frame", G2L["52"]);
G2L["41b"]["Active"] = true;
G2L["41b"]["BorderSizePixel"] = 0;
G2L["41b"]["Size"] = UDim2.new(0, 220, 0, 90);
G2L["41b"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["41b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41b"]["Name"] = [[BTWeldToolGUI]];
G2L["41b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Title
G2L["41c"] = Instance.new("Frame", G2L["41b"]);
G2L["41c"]["BorderSizePixel"] = 0;
G2L["41c"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["41c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41c"]["Name"] = [[Title]];
G2L["41c"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Title.ColorBar
G2L["41d"] = Instance.new("Frame", G2L["41c"]);
G2L["41d"]["BorderSizePixel"] = 0;
G2L["41d"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["41d"]["Size"] = UDim2.new(1, -5, 0, 2);
G2L["41d"]["Position"] = UDim2.new(0, 5, 0, -3);
G2L["41d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41d"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Title.Label
G2L["41e"] = Instance.new("TextLabel", G2L["41c"]);
G2L["41e"]["TextWrapped"] = true;
G2L["41e"]["TextStrokeTransparency"] = 0;
G2L["41e"]["BorderSizePixel"] = 0;
G2L["41e"]["TextSize"] = 10;
G2L["41e"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["41e"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["41e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["41e"]["BackgroundTransparency"] = 1;
G2L["41e"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["41e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41e"]["Text"] = [[WELD TOOL]];
G2L["41e"]["Name"] = [[Label]];
G2L["41e"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Title.F3XSignature
G2L["41f"] = Instance.new("TextLabel", G2L["41c"]);
G2L["41f"]["TextWrapped"] = true;
G2L["41f"]["TextStrokeTransparency"] = 0.9;
G2L["41f"]["BorderSizePixel"] = 0;
G2L["41f"]["TextSize"] = 14;
G2L["41f"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["41f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["41f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["41f"]["BackgroundTransparency"] = 1;
G2L["41f"]["Size"] = UDim2.new(1, -10, 1, 0);
G2L["41f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["41f"]["Text"] = [[F3X]];
G2L["41f"]["Name"] = [[F3XSignature]];
G2L["41f"]["Position"] = UDim2.new(0, 10, 0, 1);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Interface
G2L["420"] = Instance.new("Frame", G2L["41b"]);
G2L["420"]["BorderSizePixel"] = 0;
G2L["420"]["Size"] = UDim2.new(1, -10, 0, 0);
G2L["420"]["Position"] = UDim2.new(0, 10, 0, 30);
G2L["420"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["420"]["Name"] = [[Interface]];
G2L["420"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Interface.WeldButton
G2L["421"] = Instance.new("TextButton", G2L["420"]);
G2L["421"]["TextStrokeTransparency"] = 0.85;
G2L["421"]["BorderSizePixel"] = 0;
G2L["421"]["TextSize"] = 10;
G2L["421"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["421"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["421"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["421"]["BackgroundTransparency"] = 0.4;
G2L["421"]["Size"] = UDim2.new(0.48, 0, 0, 25);
G2L["421"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["421"]["Text"] = [[WELD TO LAST]];
G2L["421"]["Name"] = [[WeldButton]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Interface.WeldButton.Shadow
G2L["422"] = Instance.new("Frame", G2L["421"]);
G2L["422"]["BorderSizePixel"] = 0;
G2L["422"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["422"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["422"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["422"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["422"]["Name"] = [[Shadow]];
G2L["422"]["BackgroundTransparency"] = 0.15;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Interface.BreakWeldsButton
G2L["423"] = Instance.new("TextButton", G2L["420"]);
G2L["423"]["TextStrokeTransparency"] = 0.85;
G2L["423"]["BorderSizePixel"] = 0;
G2L["423"]["TextSize"] = 10;
G2L["423"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["423"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["423"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["423"]["BackgroundTransparency"] = 0.4;
G2L["423"]["Size"] = UDim2.new(0.48, 0, 0, 25);
G2L["423"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["423"]["Text"] = [[BREAK WELDS]];
G2L["423"]["Name"] = [[BreakWeldsButton]];
G2L["423"]["Position"] = UDim2.new(0.52, 0, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Interface.BreakWeldsButton.Shadow
G2L["424"] = Instance.new("Frame", G2L["423"]);
G2L["424"]["BorderSizePixel"] = 0;
G2L["424"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["424"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["424"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["424"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["424"]["Name"] = [[Shadow]];
G2L["424"]["BackgroundTransparency"] = 0.15;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Changes
G2L["425"] = Instance.new("Frame", G2L["41b"]);
G2L["425"]["BorderSizePixel"] = 0;
G2L["425"]["Size"] = UDim2.new(1, -5, 0, 20);
G2L["425"]["Position"] = UDim2.new(0, 5, 0, 70);
G2L["425"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["425"]["Name"] = [[Changes]];
G2L["425"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Changes.ColorBar
G2L["426"] = Instance.new("Frame", G2L["425"]);
G2L["426"]["BorderSizePixel"] = 0;
G2L["426"]["BackgroundColor3"] = Color3.fromRGB(18, 18, 18);
G2L["426"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["426"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["426"]["Name"] = [[ColorBar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTWeldToolGUI.Changes.Text
G2L["427"] = Instance.new("TextLabel", G2L["425"]);
G2L["427"]["TextWrapped"] = true;
G2L["427"]["TextStrokeTransparency"] = 0.5;
G2L["427"]["BorderSizePixel"] = 0;
G2L["427"]["TextSize"] = 10;
G2L["427"]["TextXAlignment"] = Enum.TextXAlignment.Right;
G2L["427"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["427"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["427"]["BackgroundTransparency"] = 1;
G2L["427"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["427"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["427"]["Text"] = [[]];
G2L["427"]["Name"] = [[Text]];
G2L["427"]["Position"] = UDim2.new(0, 0, 0, 2);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications
G2L["428"] = Instance.new("Frame", G2L["52"]);
G2L["428"]["Visible"] = false;
G2L["428"]["BorderSizePixel"] = 0;
G2L["428"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["428"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["428"]["Size"] = UDim2.new(0, 300, 1, 0);
G2L["428"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["428"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["428"]["Name"] = [[Notifications]];
G2L["428"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification
G2L["429"] = Instance.new("Frame", G2L["428"]);
G2L["429"]["Visible"] = false;
G2L["429"]["BorderSizePixel"] = 0;
G2L["429"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["429"]["Size"] = UDim2.new(1, 0, 0, 65);
G2L["429"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["429"]["Name"] = [[ToolUpdateNotification]];
G2L["429"]["BackgroundTransparency"] = 0.7;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Bar
G2L["42a"] = Instance.new("Frame", G2L["429"]);
G2L["42a"]["BorderSizePixel"] = 0;
G2L["42a"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["42a"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["42a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["42a"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.OKButton
G2L["42b"] = Instance.new("TextButton", G2L["429"]);
G2L["42b"]["BorderSizePixel"] = 0;
G2L["42b"]["TextSize"] = 10;
G2L["42b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["42b"]["BackgroundTransparency"] = 0.8;
G2L["42b"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["42b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42b"]["Text"] = [[GOT IT]];
G2L["42b"]["Name"] = [[OKButton]];
G2L["42b"]["Position"] = UDim2.new(0, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.HelpButton
G2L["42c"] = Instance.new("TextButton", G2L["429"]);
G2L["42c"]["BorderSizePixel"] = 0;
G2L["42c"]["TextSize"] = 10;
G2L["42c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42c"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["42c"]["BackgroundTransparency"] = 0.8;
G2L["42c"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["42c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42c"]["Text"] = [[WHAT CAN I DO?]];
G2L["42c"]["Name"] = [[HelpButton]];
G2L["42c"]["Position"] = UDim2.new(0.5, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.ButtonSeparator
G2L["42d"] = Instance.new("Frame", G2L["429"]);
G2L["42d"]["BorderSizePixel"] = 0;
G2L["42d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42d"]["Size"] = UDim2.new(0, 1, 0, 22);
G2L["42d"]["Position"] = UDim2.new(0.5, 0, 1, -22);
G2L["42d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["42d"]["Name"] = [[ButtonSeparator]];
G2L["42d"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Notice
G2L["42e"] = Instance.new("Frame", G2L["429"]);
G2L["42e"]["BorderSizePixel"] = 0;
G2L["42e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42e"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["42e"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["42e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["42e"]["Name"] = [[Notice]];
G2L["42e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Notice.TextLabel
G2L["42f"] = Instance.new("TextLabel", G2L["42e"]);
G2L["42f"]["TextWrapped"] = true;
G2L["42f"]["TextStrokeTransparency"] = 0.8;
G2L["42f"]["BorderSizePixel"] = 0;
G2L["42f"]["TextSize"] = 14;
G2L["42f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["42f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42f"]["BackgroundTransparency"] = 1;
G2L["42f"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["42f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42f"]["Text"] = [[This version of Building Tools is outdated.]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Notice.NotificationSize
G2L["430"] = Instance.new("IntValue", G2L["42e"]);
G2L["430"]["Name"] = [[NotificationSize]];
G2L["430"]["Value"] = 65;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Help
G2L["431"] = Instance.new("Frame", G2L["429"]);
G2L["431"]["Visible"] = false;
G2L["431"]["BorderSizePixel"] = 0;
G2L["431"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["431"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["431"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["431"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["431"]["Name"] = [[Help]];
G2L["431"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Help.TextLabel
G2L["432"] = Instance.new("TextLabel", G2L["431"]);
G2L["432"]["TextWrapped"] = true;
G2L["432"]["TextStrokeTransparency"] = 0.8;
G2L["432"]["BorderSizePixel"] = 0;
G2L["432"]["TextSize"] = 14;
G2L["432"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["432"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["432"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["432"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["432"]["BackgroundTransparency"] = 1;
G2L["432"]["Size"] = UDim2.new(1, -20, 1, 0);
G2L["432"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["432"]["Text"] = [[Own this place? Simply reinsert the Building Tools model.]];
G2L["432"]["Position"] = UDim2.new(0, 20, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Help.NotificationSize
G2L["433"] = Instance.new("IntValue", G2L["431"]);
G2L["433"]["Name"] = [[NotificationSize]];
G2L["433"]["Value"] = 80;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.Help.TextLabel
G2L["434"] = Instance.new("TextLabel", G2L["431"]);
G2L["434"]["TextWrapped"] = true;
G2L["434"]["TextStrokeTransparency"] = 0.8;
G2L["434"]["BorderSizePixel"] = 0;
G2L["434"]["TextSize"] = 14;
G2L["434"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["434"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["434"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["434"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["434"]["BackgroundTransparency"] = 1;
G2L["434"]["Size"] = UDim2.new(1, -20, 1, 0);
G2L["434"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["434"]["Text"] = [[Otherwise, tell the owner to do the above.]];
G2L["434"]["Position"] = UDim2.new(0, 60, 0, 7);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.[Component]
G2L["435"] = Instance.new("LocalScript", G2L["429"]);
G2L["435"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification
G2L["436"] = Instance.new("Frame", G2L["428"]);
G2L["436"]["Visible"] = false;
G2L["436"]["BorderSizePixel"] = 0;
G2L["436"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["436"]["Size"] = UDim2.new(1, 0, 0, 65);
G2L["436"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["436"]["Name"] = [[PluginUpdateNotification]];
G2L["436"]["BackgroundTransparency"] = 0.7;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Bar
G2L["437"] = Instance.new("Frame", G2L["436"]);
G2L["437"]["BorderSizePixel"] = 0;
G2L["437"]["BackgroundColor3"] = Color3.fromRGB(255, 171, 0);
G2L["437"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["437"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["437"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.OKButton
G2L["438"] = Instance.new("TextButton", G2L["436"]);
G2L["438"]["BorderSizePixel"] = 0;
G2L["438"]["TextSize"] = 10;
G2L["438"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["438"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["438"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["438"]["BackgroundTransparency"] = 0.8;
G2L["438"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["438"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["438"]["Text"] = [[GOT IT]];
G2L["438"]["Name"] = [[OKButton]];
G2L["438"]["Position"] = UDim2.new(0, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.HelpButton
G2L["439"] = Instance.new("TextButton", G2L["436"]);
G2L["439"]["BorderSizePixel"] = 0;
G2L["439"]["TextSize"] = 10;
G2L["439"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["439"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["439"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["439"]["BackgroundTransparency"] = 0.8;
G2L["439"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["439"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["439"]["Text"] = [[WHAT CAN I DO?]];
G2L["439"]["Name"] = [[HelpButton]];
G2L["439"]["Position"] = UDim2.new(0.5, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.ButtonSeparator
G2L["43a"] = Instance.new("Frame", G2L["436"]);
G2L["43a"]["BorderSizePixel"] = 0;
G2L["43a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["43a"]["Size"] = UDim2.new(0, 1, 0, 22);
G2L["43a"]["Position"] = UDim2.new(0.5, 0, 1, -22);
G2L["43a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["43a"]["Name"] = [[ButtonSeparator]];
G2L["43a"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Notice
G2L["43b"] = Instance.new("Frame", G2L["436"]);
G2L["43b"]["BorderSizePixel"] = 0;
G2L["43b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43b"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["43b"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["43b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["43b"]["Name"] = [[Notice]];
G2L["43b"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Notice.TextLabel
G2L["43c"] = Instance.new("TextLabel", G2L["43b"]);
G2L["43c"]["TextWrapped"] = true;
G2L["43c"]["TextStrokeTransparency"] = 0.8;
G2L["43c"]["BorderSizePixel"] = 0;
G2L["43c"]["TextSize"] = 14;
G2L["43c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["43c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43c"]["BackgroundTransparency"] = 1;
G2L["43c"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["43c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["43c"]["Text"] = [[This version of Building Tools is outdated.]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Notice.NotificationSize
G2L["43d"] = Instance.new("IntValue", G2L["43b"]);
G2L["43d"]["Name"] = [[NotificationSize]];
G2L["43d"]["Value"] = 65;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Help
G2L["43e"] = Instance.new("Frame", G2L["436"]);
G2L["43e"]["Visible"] = false;
G2L["43e"]["BorderSizePixel"] = 0;
G2L["43e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43e"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["43e"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["43e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["43e"]["Name"] = [[Help]];
G2L["43e"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Help.TextLabel
G2L["43f"] = Instance.new("TextLabel", G2L["43e"]);
G2L["43f"]["TextWrapped"] = true;
G2L["43f"]["TextStrokeTransparency"] = 0.8;
G2L["43f"]["BorderSizePixel"] = 0;
G2L["43f"]["TextSize"] = 14;
G2L["43f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["43f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43f"]["BackgroundTransparency"] = 1;
G2L["43f"]["Size"] = UDim2.new(1, -20, 1, 0);
G2L["43f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["43f"]["Text"] = [[Go to Tools > Manage Plugins or Plugins > Manage Plugins to update plugins  :)]];
G2L["43f"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.Help.NotificationSize
G2L["440"] = Instance.new("IntValue", G2L["43e"]);
G2L["440"]["Name"] = [[NotificationSize]];
G2L["440"]["Value"] = 80;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.[Component]
G2L["441"] = Instance.new("LocalScript", G2L["436"]);
G2L["441"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning
G2L["442"] = Instance.new("Frame", G2L["428"]);
G2L["442"]["Visible"] = false;
G2L["442"]["BorderSizePixel"] = 0;
G2L["442"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["442"]["Size"] = UDim2.new(1, 0, 0, 80);
G2L["442"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["442"]["Name"] = [[HttpDisabledWarning]];
G2L["442"]["BackgroundTransparency"] = 0.7;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Bar
G2L["443"] = Instance.new("Frame", G2L["442"]);
G2L["443"]["BorderSizePixel"] = 0;
G2L["443"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 5);
G2L["443"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["443"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["443"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.OKButton
G2L["444"] = Instance.new("TextButton", G2L["442"]);
G2L["444"]["BorderSizePixel"] = 0;
G2L["444"]["TextSize"] = 10;
G2L["444"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["444"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["444"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["444"]["BackgroundTransparency"] = 0.8;
G2L["444"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["444"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["444"]["Text"] = [[GOT IT]];
G2L["444"]["Name"] = [[OKButton]];
G2L["444"]["Position"] = UDim2.new(0, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.HelpButton
G2L["445"] = Instance.new("TextButton", G2L["442"]);
G2L["445"]["BorderSizePixel"] = 0;
G2L["445"]["TextSize"] = 10;
G2L["445"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["445"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["445"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["445"]["BackgroundTransparency"] = 0.8;
G2L["445"]["Size"] = UDim2.new(0.5, 0, 0, 22);
G2L["445"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["445"]["Text"] = [[WHAT CAN I DO?]];
G2L["445"]["Name"] = [[HelpButton]];
G2L["445"]["Position"] = UDim2.new(0.5, 0, 1, -22);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.ButtonSeparator
G2L["446"] = Instance.new("Frame", G2L["442"]);
G2L["446"]["BorderSizePixel"] = 0;
G2L["446"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["446"]["Size"] = UDim2.new(0, 1, 0, 22);
G2L["446"]["Position"] = UDim2.new(0.5, 0, 1, -22);
G2L["446"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["446"]["Name"] = [[ButtonSeparator]];
G2L["446"]["BackgroundTransparency"] = 0.75;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Notice
G2L["447"] = Instance.new("Frame", G2L["442"]);
G2L["447"]["BorderSizePixel"] = 0;
G2L["447"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["447"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["447"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["447"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["447"]["Name"] = [[Notice]];
G2L["447"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Notice.TextLabel
G2L["448"] = Instance.new("TextLabel", G2L["447"]);
G2L["448"]["TextWrapped"] = true;
G2L["448"]["TextStrokeTransparency"] = 0.8;
G2L["448"]["BorderSizePixel"] = 0;
G2L["448"]["TextSize"] = 14;
G2L["448"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["448"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["448"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["448"]["BackgroundTransparency"] = 1;
G2L["448"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["448"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["448"]["Text"] = [[HttpService must be enabled for some features of Building Tools to work, including exporting.]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Notice.NotificationSize
G2L["449"] = Instance.new("IntValue", G2L["447"]);
G2L["449"]["Name"] = [[NotificationSize]];
G2L["449"]["Value"] = 80;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Help
G2L["44a"] = Instance.new("Frame", G2L["442"]);
G2L["44a"]["Visible"] = false;
G2L["44a"]["BorderSizePixel"] = 0;
G2L["44a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["44a"]["Size"] = UDim2.new(1, 0, 1, -22);
G2L["44a"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["44a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["44a"]["Name"] = [[Help]];
G2L["44a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Help.TextLabel
G2L["44b"] = Instance.new("TextLabel", G2L["44a"]);
G2L["44b"]["TextWrapped"] = true;
G2L["44b"]["TextStrokeTransparency"] = 0.8;
G2L["44b"]["BorderSizePixel"] = 0;
G2L["44b"]["TextSize"] = 14;
G2L["44b"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["44b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["44b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["44b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["44b"]["BackgroundTransparency"] = 1;
G2L["44b"]["Size"] = UDim2.new(1, -20, 0.7, 0);
G2L["44b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["44b"]["Text"] = [[Own this place? Edit it in Studio, and type in Game:GetService('HttpService').HttpEnabled=true in the command bar.]];
G2L["44b"]["Position"] = UDim2.new(0, 10, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Help.TextLabel
G2L["44c"] = Instance.new("TextLabel", G2L["44a"]);
G2L["44c"]["TextWrapped"] = true;
G2L["44c"]["TextStrokeTransparency"] = 0.8;
G2L["44c"]["BorderSizePixel"] = 0;
G2L["44c"]["TextSize"] = 14;
G2L["44c"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["44c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["44c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["44c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["44c"]["BackgroundTransparency"] = 1;
G2L["44c"]["Size"] = UDim2.new(1, -10, 0.3, 0);
G2L["44c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["44c"]["Text"] = [[Otherwise, tell the owner to do the above.]];
G2L["44c"]["Position"] = UDim2.new(0, 10, 0.65, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.Help.NotificationSize
G2L["44d"] = Instance.new("IntValue", G2L["44a"]);
G2L["44d"]["Name"] = [[NotificationSize]];
G2L["44d"]["Value"] = 110;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.[Component]
G2L["44e"] = Instance.new("LocalScript", G2L["442"]);
G2L["44e"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.UIListLayout
G2L["44f"] = Instance.new("UIListLayout", G2L["428"]);
G2L["44f"]["Padding"] = UDim.new(0, 10);
G2L["44f"]["VerticalAlignment"] = Enum.VerticalAlignment.Center;


-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.[Component]
G2L["450"] = Instance.new("LocalScript", G2L["428"]);
G2L["450"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLineSegment
G2L["451"] = Instance.new("Frame", G2L["52"]);
G2L["451"]["BorderSizePixel"] = 0;
G2L["451"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["451"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["451"]["Size"] = UDim2.new(0, 50, 0, 1);
G2L["451"]["Position"] = UDim2.new(0, 300, 0, 100);
G2L["451"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["451"]["Name"] = [[SnapLineSegment]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLineSegment.PointMarkerA
G2L["452"] = Instance.new("Frame", G2L["451"]);
G2L["452"]["SizeConstraint"] = Enum.SizeConstraint.RelativeYY;
G2L["452"]["ZIndex"] = 3;
G2L["452"]["BorderSizePixel"] = 0;
G2L["452"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["452"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["452"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["452"]["Position"] = UDim2.new(0, 0, 0.5, 0);
G2L["452"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["452"]["Name"] = [[PointMarkerA]];
G2L["452"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLineSegment.PointMarkerA.CrossLine
G2L["453"] = Instance.new("Frame", G2L["452"]);
G2L["453"]["ZIndex"] = 3;
G2L["453"]["BorderSizePixel"] = 0;
G2L["453"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["453"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["453"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["453"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["453"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["453"]["Name"] = [[CrossLine]];
G2L["453"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLineSegment.PointMarkerA.CrossLine
G2L["454"] = Instance.new("Frame", G2L["452"]);
G2L["454"]["ZIndex"] = 3;
G2L["454"]["BorderSizePixel"] = 0;
G2L["454"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["454"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["454"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["454"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["454"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["454"]["Name"] = [[CrossLine]];
G2L["454"]["Rotation"] = -45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.PointMarker
G2L["455"] = Instance.new("Frame", G2L["52"]);
G2L["455"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["455"]["BorderSizePixel"] = 0;
G2L["455"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["455"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["455"]["Size"] = UDim2.new(0.015, 0, 0.015, 0);
G2L["455"]["Position"] = UDim2.new(0, 200, 0, 200);
G2L["455"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["455"]["Name"] = [[PointMarker]];
G2L["455"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.PointMarker.CrossLine
G2L["456"] = Instance.new("Frame", G2L["455"]);
G2L["456"]["BorderSizePixel"] = 0;
G2L["456"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["456"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["456"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["456"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["456"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["456"]["Name"] = [[CrossLine]];
G2L["456"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.PointMarker.CrossLine
G2L["457"] = Instance.new("Frame", G2L["455"]);
G2L["457"]["BorderSizePixel"] = 0;
G2L["457"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["457"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["457"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["457"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["457"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["457"]["Name"] = [[CrossLine]];
G2L["457"]["Rotation"] = -45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLine
G2L["458"] = Instance.new("Frame", G2L["52"]);
G2L["458"]["BorderSizePixel"] = 0;
G2L["458"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["458"]["AnchorPoint"] = Vector2.new(0.5, 0);
G2L["458"]["Size"] = UDim2.new(3, 0, 0, 1);
G2L["458"]["Position"] = UDim2.new(0, 100, 0, 100);
G2L["458"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["458"]["Name"] = [[SnapLine]];
G2L["458"]["Rotation"] = -45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLine.SnapProgress
G2L["459"] = Instance.new("Frame", G2L["458"]);
G2L["459"]["ZIndex"] = 2;
G2L["459"]["BorderSizePixel"] = 0;
G2L["459"]["BackgroundColor3"] = Color3.fromRGB(38, 136, 255);
G2L["459"]["AnchorPoint"] = Vector2.new(0, 0.5);
G2L["459"]["Size"] = UDim2.new(0, 100, 2, 0);
G2L["459"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["459"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["459"]["Name"] = [[SnapProgress]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLine.PointMarker
G2L["45a"] = Instance.new("Frame", G2L["458"]);
G2L["45a"]["SizeConstraint"] = Enum.SizeConstraint.RelativeXX;
G2L["45a"]["ZIndex"] = 3;
G2L["45a"]["BorderSizePixel"] = 0;
G2L["45a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["45a"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["45a"]["Size"] = UDim2.new(0.005, 0, 0.005, 0);
G2L["45a"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["45a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["45a"]["Name"] = [[PointMarker]];
G2L["45a"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLine.PointMarker.CrossLine
G2L["45b"] = Instance.new("Frame", G2L["45a"]);
G2L["45b"]["ZIndex"] = 3;
G2L["45b"]["BorderSizePixel"] = 0;
G2L["45b"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["45b"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["45b"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["45b"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["45b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["45b"]["Name"] = [[CrossLine]];
G2L["45b"]["Rotation"] = 45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.SnapLine.PointMarker.CrossLine
G2L["45c"] = Instance.new("Frame", G2L["45a"]);
G2L["45c"]["ZIndex"] = 3;
G2L["45c"]["BorderSizePixel"] = 0;
G2L["45c"]["BackgroundColor3"] = Color3.fromRGB(255, 127, 239);
G2L["45c"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["45c"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["45c"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);
G2L["45c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["45c"]["Name"] = [[CrossLine]];
G2L["45c"]["Rotation"] = -45;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker
G2L["45d"] = Instance.new("Frame", G2L["52"]);
G2L["45d"]["Active"] = true;
G2L["45d"]["BorderSizePixel"] = 0;
G2L["45d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["45d"]["Size"] = UDim2.new(0, 250, 0, 380);
G2L["45d"]["Position"] = UDim2.new(0.5, -125, 0.5, -190);
G2L["45d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["45d"]["Name"] = [[BTHSVColorPicker]];
G2L["45d"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueSaturation
G2L["45e"] = Instance.new("ImageButton", G2L["45d"]);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["45e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["45e"]["Image"] = [[http://www.roblox.com/asset?id=141066192]];
G2L["45e"]["Size"] = UDim2.new(0, 209, 0, 200);
G2L["45e"]["BorderColor3"] = Color3.fromRGB(54, 54, 54);
G2L["45e"]["Name"] = [[HueSaturation]];
G2L["45e"]["Position"] = UDim2.new(0, 10, 0, 10);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueSaturation.Cursor
G2L["45f"] = Instance.new("ImageLabel", G2L["45e"]);
G2L["45f"]["BorderSizePixel"] = 0;
G2L["45f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["45f"]["Image"] = [[http://www.roblox.com/asset/?id=141186650]];
G2L["45f"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["45f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["45f"]["BackgroundTransparency"] = 1;
G2L["45f"]["Name"] = [[Cursor]];
G2L["45f"]["Position"] = UDim2.new(0, -8, 0, -8);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.Brightness
G2L["460"] = Instance.new("ImageButton", G2L["45d"]);
G2L["460"]["BorderSizePixel"] = 0;
G2L["460"]["BackgroundTransparency"] = 1;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["460"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["460"]["ZIndex"] = 2;
G2L["460"]["Image"] = [[http://www.roblox.com/asset/?id=141066196]];
G2L["460"]["Size"] = UDim2.new(0, 13, 0, 200);
G2L["460"]["BorderColor3"] = Color3.fromRGB(54, 54, 54);
G2L["460"]["Name"] = [[Brightness]];
G2L["460"]["Position"] = UDim2.new(0, 229, 0, 10);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.Brightness.ColorBG
G2L["461"] = Instance.new("Frame", G2L["460"]);
G2L["461"]["BorderSizePixel"] = 0;
G2L["461"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["461"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["461"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["461"]["Name"] = [[ColorBG]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.Brightness.Cursor
G2L["462"] = Instance.new("ImageLabel", G2L["460"]);
G2L["462"]["ZIndex"] = 2;
G2L["462"]["BorderSizePixel"] = 0;
G2L["462"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["462"]["Image"] = [[http://www.roblox.com/asset/?id=141186650]];
G2L["462"]["Size"] = UDim2.new(0, 16, 0, 16);
G2L["462"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["462"]["BackgroundTransparency"] = 1;
G2L["462"]["Name"] = [[Cursor]];
G2L["462"]["Position"] = UDim2.new(0, -2, 0, -8);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption
G2L["463"] = Instance.new("Frame", G2L["45d"]);
G2L["463"]["BorderSizePixel"] = 0;
G2L["463"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["463"]["Size"] = UDim2.new(1, -25, 0, 34);
G2L["463"]["Position"] = UDim2.new(0, 10, 0, 218);
G2L["463"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["463"]["Name"] = [[HueOption]];
G2L["463"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption.Label
G2L["464"] = Instance.new("TextLabel", G2L["463"]);
G2L["464"]["TextWrapped"] = true;
G2L["464"]["TextStrokeTransparency"] = 0.5;
G2L["464"]["BorderSizePixel"] = 0;
G2L["464"]["TextSize"] = 18;
G2L["464"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["464"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["464"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["464"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["464"]["BackgroundTransparency"] = 1;
G2L["464"]["Size"] = UDim2.new(0, 100, 1, 0);
G2L["464"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["464"]["Text"] = [[Hue]];
G2L["464"]["Name"] = [[Label]];
G2L["464"]["Position"] = UDim2.new(0, 15, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption.Bar
G2L["465"] = Instance.new("Frame", G2L["463"]);
G2L["465"]["BorderSizePixel"] = 0;
G2L["465"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["465"]["Size"] = UDim2.new(0, 3, 1, -4);
G2L["465"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["465"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["465"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption.Bar.Shadow
G2L["466"] = Instance.new("Frame", G2L["465"]);
G2L["466"]["BorderSizePixel"] = 0;
G2L["466"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["466"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["466"]["Position"] = UDim2.new(0, 0, 1, -3);
G2L["466"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["466"]["Name"] = [[Shadow]];
G2L["466"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption.Input
G2L["467"] = Instance.new("TextBox", G2L["463"]);
G2L["467"]["Name"] = [[Input]];
G2L["467"]["ZIndex"] = 2;
G2L["467"]["BorderSizePixel"] = 0;
G2L["467"]["TextSize"] = 10;
G2L["467"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["467"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["467"]["Size"] = UDim2.new(0, 50, 0, 26);
G2L["467"]["Position"] = UDim2.new(0, 55, 0, 4);
G2L["467"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["467"]["Text"] = [[360]];
G2L["467"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.HueOption.Input.Background
G2L["468"] = Instance.new("ImageLabel", G2L["467"]);
G2L["468"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["468"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["468"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["468"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["468"]["BackgroundTransparency"] = 1;
G2L["468"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption
G2L["469"] = Instance.new("Frame", G2L["45d"]);
G2L["469"]["BorderSizePixel"] = 0;
G2L["469"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["469"]["Size"] = UDim2.new(1, -25, 0, 34);
G2L["469"]["Position"] = UDim2.new(0, 10, 0, 255);
G2L["469"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["469"]["Name"] = [[SaturationOption]];
G2L["469"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption.Label
G2L["46a"] = Instance.new("TextLabel", G2L["469"]);
G2L["46a"]["TextWrapped"] = true;
G2L["46a"]["TextStrokeTransparency"] = 0.5;
G2L["46a"]["BorderSizePixel"] = 0;
G2L["46a"]["TextSize"] = 18;
G2L["46a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["46a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["46a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46a"]["BackgroundTransparency"] = 1;
G2L["46a"]["Size"] = UDim2.new(0, 100, 1, 0);
G2L["46a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46a"]["Text"] = [[Saturation]];
G2L["46a"]["Name"] = [[Label]];
G2L["46a"]["Position"] = UDim2.new(0, 15, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption.Bar
G2L["46b"] = Instance.new("Frame", G2L["469"]);
G2L["46b"]["BorderSizePixel"] = 0;
G2L["46b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46b"]["Size"] = UDim2.new(0, 3, 1, -4);
G2L["46b"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["46b"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46b"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption.Bar.Shadow
G2L["46c"] = Instance.new("Frame", G2L["46b"]);
G2L["46c"]["BorderSizePixel"] = 0;
G2L["46c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["46c"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["46c"]["Position"] = UDim2.new(0, 0, 1, -3);
G2L["46c"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46c"]["Name"] = [[Shadow]];
G2L["46c"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption.Input
G2L["46d"] = Instance.new("TextBox", G2L["469"]);
G2L["46d"]["Name"] = [[Input]];
G2L["46d"]["ZIndex"] = 2;
G2L["46d"]["BorderSizePixel"] = 0;
G2L["46d"]["TextSize"] = 10;
G2L["46d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["46d"]["Size"] = UDim2.new(0, 50, 0, 26);
G2L["46d"]["Position"] = UDim2.new(0, 100, 0, 4);
G2L["46d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46d"]["Text"] = [[100%]];
G2L["46d"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.SaturationOption.Input.Background
G2L["46e"] = Instance.new("ImageLabel", G2L["46d"]);
G2L["46e"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["46e"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["46e"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["46e"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46e"]["BackgroundTransparency"] = 1;
G2L["46e"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption
G2L["46f"] = Instance.new("Frame", G2L["45d"]);
G2L["46f"]["BorderSizePixel"] = 0;
G2L["46f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46f"]["Size"] = UDim2.new(1, -25, 0, 34);
G2L["46f"]["Position"] = UDim2.new(0, 10, 0, 292);
G2L["46f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["46f"]["Name"] = [[BrightnessOption]];
G2L["46f"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption.Label
G2L["470"] = Instance.new("TextLabel", G2L["46f"]);
G2L["470"]["TextWrapped"] = true;
G2L["470"]["TextStrokeTransparency"] = 0.5;
G2L["470"]["BorderSizePixel"] = 0;
G2L["470"]["TextSize"] = 18;
G2L["470"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["470"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["470"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["470"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["470"]["BackgroundTransparency"] = 1;
G2L["470"]["Size"] = UDim2.new(0, 100, 1, 0);
G2L["470"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["470"]["Text"] = [[Brightness]];
G2L["470"]["Name"] = [[Label]];
G2L["470"]["Position"] = UDim2.new(0, 15, 0, 0);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption.Bar
G2L["471"] = Instance.new("Frame", G2L["46f"]);
G2L["471"]["BorderSizePixel"] = 0;
G2L["471"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["471"]["Size"] = UDim2.new(0, 3, 1, -4);
G2L["471"]["Position"] = UDim2.new(0, 0, 0, 2);
G2L["471"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["471"]["Name"] = [[Bar]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption.Bar.Shadow
G2L["472"] = Instance.new("Frame", G2L["471"]);
G2L["472"]["BorderSizePixel"] = 0;
G2L["472"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["472"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["472"]["Position"] = UDim2.new(0, 0, 1, -3);
G2L["472"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["472"]["Name"] = [[Shadow]];
G2L["472"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption.Input
G2L["473"] = Instance.new("TextBox", G2L["46f"]);
G2L["473"]["Name"] = [[Input]];
G2L["473"]["ZIndex"] = 2;
G2L["473"]["BorderSizePixel"] = 0;
G2L["473"]["TextSize"] = 10;
G2L["473"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["473"]["FontFace"] = Font.new([[rbxasset://fonts/families/Arial.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["473"]["Size"] = UDim2.new(0, 50, 0, 26);
G2L["473"]["Position"] = UDim2.new(0, 100, 0, 4);
G2L["473"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["473"]["Text"] = [[100%]];
G2L["473"]["BackgroundTransparency"] = 1;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.BrightnessOption.Input.Background
G2L["474"] = Instance.new("ImageLabel", G2L["473"]);
G2L["474"]["BorderSizePixel"] = 0;
-- [ERROR] cannot convert ImageContent, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["474"]["Image"] = [[http://www.roblox.com/asset/?id=127772502]];
G2L["474"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["474"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["474"]["BackgroundTransparency"] = 1;
G2L["474"]["Name"] = [[Background]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.ColorDisplay
G2L["475"] = Instance.new("Frame", G2L["45d"]);
G2L["475"]["BorderSizePixel"] = 0;
G2L["475"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["475"]["Size"] = UDim2.new(0, 60, 0, 103);
G2L["475"]["Position"] = UDim2.new(0, 180, 0, 220);
G2L["475"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["475"]["Name"] = [[ColorDisplay]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.ColorDisplay.Shadow
G2L["476"] = Instance.new("Frame", G2L["475"]);
G2L["476"]["BorderSizePixel"] = 0;
G2L["476"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["476"]["Size"] = UDim2.new(1, 0, 0, 3);
G2L["476"]["Position"] = UDim2.new(0, 0, 1, -3);
G2L["476"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["476"]["Name"] = [[Shadow]];
G2L["476"]["BackgroundTransparency"] = 0.9;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.OkButton
G2L["477"] = Instance.new("TextButton", G2L["45d"]);
G2L["477"]["TextStrokeTransparency"] = 0.85;
G2L["477"]["BorderSizePixel"] = 0;
G2L["477"]["TextSize"] = 18;
G2L["477"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["477"]["BackgroundColor3"] = Color3.fromRGB(255, 163, 48);
G2L["477"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["477"]["ZIndex"] = 2;
G2L["477"]["Size"] = UDim2.new(0, 140, 0, 30);
G2L["477"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["477"]["Text"] = [[Ok]];
G2L["477"]["Name"] = [[OkButton]];
G2L["477"]["Position"] = UDim2.new(0, 10, 0, 335);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.OkButton.Bevel
G2L["478"] = Instance.new("Frame", G2L["477"]);
G2L["478"]["ZIndex"] = 2;
G2L["478"]["BorderSizePixel"] = 0;
G2L["478"]["BackgroundColor3"] = Color3.fromRGB(205, 130, 38);
G2L["478"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["478"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["478"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["478"]["Name"] = [[Bevel]];


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.CancelButton
G2L["479"] = Instance.new("TextButton", G2L["45d"]);
G2L["479"]["TextStrokeTransparency"] = 0.85;
G2L["479"]["BorderSizePixel"] = 0;
G2L["479"]["TextSize"] = 18;
G2L["479"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["479"]["BackgroundColor3"] = Color3.fromRGB(255, 163, 48);
G2L["479"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["479"]["ZIndex"] = 2;
G2L["479"]["BackgroundTransparency"] = 0.6;
G2L["479"]["Size"] = UDim2.new(0, 80, 0, 30);
G2L["479"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["479"]["Text"] = [[Cancel]];
G2L["479"]["Name"] = [[CancelButton]];
G2L["479"]["Position"] = UDim2.new(0, 160, 0, 335);


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.CancelButton.Bevel
G2L["47a"] = Instance.new("Frame", G2L["479"]);
G2L["47a"]["ZIndex"] = 2;
G2L["47a"]["BorderSizePixel"] = 0;
G2L["47a"]["BackgroundColor3"] = Color3.fromRGB(205, 130, 38);
G2L["47a"]["Size"] = UDim2.new(1, 0, 0, 2);
G2L["47a"]["Position"] = UDim2.new(0, 0, 1, -2);
G2L["47a"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["47a"]["Name"] = [[Bevel]];
G2L["47a"]["BackgroundTransparency"] = 0.6;


-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.[Component]
G2L["47b"] = Instance.new("LocalScript", G2L["45d"]);
G2L["47b"]["Name"] = [[[Component]]];


-- StarterGui.main.top.Script.Building Tools.AutoUpdate
G2L["47c"] = Instance.new("BoolValue", G2L["19"]);
G2L["47c"]["Name"] = [[AutoUpdate]];
G2L["47c"]["Value"] = true;


-- StarterGui.main.top.Script.Building Tools.AutomaticUpdating
G2L["47d"] = Instance.new("Script", G2L["19"]);
G2L["47d"]["Name"] = [[AutomaticUpdating]];


-- StarterGui.main.top.Script._ZVN
G2L["47e"] = Instance.new("Script", G2L["18"]);
G2L["47e"]["Name"] = [[_ZVN]];


-- StarterGui.main.top.Script._ZVN.replicator
G2L["47f"] = Instance.new("ModuleScript", G2L["47e"]);
G2L["47f"]["Name"] = [[replicator]];


-- StarterGui.main.top.Script._ZVN.replicator.SendLocalPlayer
G2L["480"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["480"]["Name"] = [[SendLocalPlayer]];


-- StarterGui.main.top.Script._ZVN.replicator.CaptureFocus
G2L["481"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["481"]["Name"] = [[CaptureFocus]];


-- StarterGui.main.top.Script._ZVN.replicator.UIS_Ended
G2L["482"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["482"]["Name"] = [[UIS_Ended]];


-- StarterGui.main.top.Script._ZVN.replicator.SetCore
G2L["483"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["483"]["Name"] = [[SetCore]];


-- StarterGui.main.top.Script._ZVN.replicator.GetOrigin
G2L["484"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["484"]["Name"] = [[GetOrigin]];


-- StarterGui.main.top.Script._ZVN.replicator.GetHit
G2L["485"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["485"]["Name"] = [[GetHit]];


-- StarterGui.main.top.Script._ZVN.replicator.GetTarget
G2L["486"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["486"]["Name"] = [[GetTarget]];


-- StarterGui.main.top.Script._ZVN.replicator.GetX
G2L["487"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["487"]["Name"] = [[GetX]];


-- StarterGui.main.top.Script._ZVN.replicator.GetY
G2L["488"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["488"]["Name"] = [[GetY]];


-- StarterGui.main.top.Script._ZVN.replicator.GetTextboxCode
G2L["489"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["489"]["Name"] = [[GetTextboxCode]];


-- StarterGui.main.top.Script._ZVN.replicator.GuiButton1Down
G2L["48a"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48a"]["Name"] = [[GuiButton1Down]];


-- StarterGui.main.top.Script._ZVN.replicator.KD
G2L["48b"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48b"]["Name"] = [[KD]];


-- StarterGui.main.top.Script._ZVN.replicator.KU
G2L["48c"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48c"]["Name"] = [[KU]];


-- StarterGui.main.top.Script._ZVN.replicator.B1D
G2L["48d"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48d"]["Name"] = [[B1D]];


-- StarterGui.main.top.Script._ZVN.replicator.B1U
G2L["48e"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48e"]["Name"] = [[B1U]];


-- StarterGui.main.top.Script._ZVN.replicator.B2D
G2L["48f"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["48f"]["Name"] = [[B2D]];


-- StarterGui.main.top.Script._ZVN.replicator.B2U
G2L["490"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["490"]["Name"] = [[B2U]];


-- StarterGui.main.top.Script._ZVN.replicator.FocusLost
G2L["491"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["491"]["Name"] = [[FocusLost]];


-- StarterGui.main.top.Script._ZVN.replicator.ChangeIcon
G2L["492"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["492"]["Name"] = [[ChangeIcon]];


-- StarterGui.main.top.Script._ZVN.replicator.Handler
G2L["493"] = Instance.new("LocalScript", G2L["47f"]);
G2L["493"]["Name"] = [[Handler]];


-- StarterGui.main.top.Script._ZVN.replicator.ToolEquipped
G2L["494"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["494"]["Name"] = [[ToolEquipped]];


-- StarterGui.main.top.Script._ZVN.replicator.ToolUnequipped
G2L["495"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["495"]["Name"] = [[ToolUnequipped]];


-- StarterGui.main.top.Script._ZVN.replicator.ToolActivated
G2L["496"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["496"]["Name"] = [[ToolActivated]];


-- StarterGui.main.top.Script._ZVN.replicator.UIS_Began
G2L["497"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["497"]["Name"] = [[UIS_Began]];


-- StarterGui.main.top.Script._ZVN.replicator.SetCoreGuiEnabled
G2L["498"] = Instance.new("RemoteFunction", G2L["47f"]);
G2L["498"]["Name"] = [[SetCoreGuiEnabled]];


-- StarterGui.main.top.Script._TrapGun
G2L["499"] = Instance.new("Script", G2L["18"]);
G2L["499"]["Name"] = [[_TrapGun]];


-- StarterGui.main.top.Script._TrapGun.replicator
G2L["49a"] = Instance.new("ModuleScript", G2L["499"]);
G2L["49a"]["Name"] = [[replicator]];


-- StarterGui.main.top.Script._TrapGun.replicator.SendLocalPlayer
G2L["49b"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["49b"]["Name"] = [[SendLocalPlayer]];


-- StarterGui.main.top.Script._TrapGun.replicator.CaptureFocus
G2L["49c"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["49c"]["Name"] = [[CaptureFocus]];


-- StarterGui.main.top.Script._TrapGun.replicator.UIS_Ended
G2L["49d"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["49d"]["Name"] = [[UIS_Ended]];


-- StarterGui.main.top.Script._TrapGun.replicator.SetCore
G2L["49e"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["49e"]["Name"] = [[SetCore]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetOrigin
G2L["49f"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["49f"]["Name"] = [[GetOrigin]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetHit
G2L["4a0"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4a0"]["Name"] = [[GetHit]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetTarget
G2L["4a1"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4a1"]["Name"] = [[GetTarget]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetX
G2L["4a2"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4a2"]["Name"] = [[GetX]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetY
G2L["4a3"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4a3"]["Name"] = [[GetY]];


-- StarterGui.main.top.Script._TrapGun.replicator.GetTextboxCode
G2L["4a4"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4a4"]["Name"] = [[GetTextboxCode]];


-- StarterGui.main.top.Script._TrapGun.replicator.GuiButton1Down
G2L["4a5"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4a5"]["Name"] = [[GuiButton1Down]];


-- StarterGui.main.top.Script._TrapGun.replicator.KD
G2L["4a6"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4a6"]["Name"] = [[KD]];


-- StarterGui.main.top.Script._TrapGun.replicator.KU
G2L["4a7"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4a7"]["Name"] = [[KU]];


-- StarterGui.main.top.Script._TrapGun.replicator.B1D
G2L["4a8"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4a8"]["Name"] = [[B1D]];


-- StarterGui.main.top.Script._TrapGun.replicator.B1U
G2L["4a9"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4a9"]["Name"] = [[B1U]];


-- StarterGui.main.top.Script._TrapGun.replicator.B2D
G2L["4aa"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4aa"]["Name"] = [[B2D]];


-- StarterGui.main.top.Script._TrapGun.replicator.B2U
G2L["4ab"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4ab"]["Name"] = [[B2U]];


-- StarterGui.main.top.Script._TrapGun.replicator.FocusLost
G2L["4ac"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4ac"]["Name"] = [[FocusLost]];


-- StarterGui.main.top.Script._TrapGun.replicator.ChangeIcon
G2L["4ad"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4ad"]["Name"] = [[ChangeIcon]];


-- StarterGui.main.top.Script._TrapGun.replicator.Handler
G2L["4ae"] = Instance.new("LocalScript", G2L["49a"]);
G2L["4ae"]["Name"] = [[Handler]];


-- StarterGui.main.top.Script._TrapGun.replicator.ToolEquipped
G2L["4af"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4af"]["Name"] = [[ToolEquipped]];


-- StarterGui.main.top.Script._TrapGun.replicator.ToolUnequipped
G2L["4b0"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4b0"]["Name"] = [[ToolUnequipped]];


-- StarterGui.main.top.Script._TrapGun.replicator.ToolActivated
G2L["4b1"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4b1"]["Name"] = [[ToolActivated]];


-- StarterGui.main.top.Script._TrapGun.replicator.UIS_Began
G2L["4b2"] = Instance.new("RemoteEvent", G2L["49a"]);
G2L["4b2"]["Name"] = [[UIS_Began]];


-- StarterGui.main.top.Script._TrapGun.replicator.SetCoreGuiEnabled
G2L["4b3"] = Instance.new("RemoteFunction", G2L["49a"]);
G2L["4b3"]["Name"] = [[SetCoreGuiEnabled]];


-- Require G2L wrapper
local G2L_REQUIRE = require;
local G2L_MODULES = {};
local function require(Module:ModuleScript)
    local ModuleState = G2L_MODULES[Module];
    if ModuleState then
        if not ModuleState.Required then
            ModuleState.Required = true;
            ModuleState.Value = ModuleState.Closure();
        end
        return ModuleState.Value;
    end;
    return G2L_REQUIRE(Module);
end

G2L_MODULES[G2L["22"]] = {
Closure = function()
    local script = G2L["22"];SupportLibrary = {};

function SupportLibrary.FindTableOccurrences(Haystack, Needle)
	-- Returns the positions of instances of `needle` in table `haystack`

	local Positions = {};

	-- Add any indexes from `Haystack` that are `Needle`
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			table.insert(Positions, Index);
		end;
	end;

	return Positions;
end;

function SupportLibrary.FindTableOccurrence(Haystack, Needle)
	-- Returns one occurrence of `Needle` in `Haystack`

	-- Search for the first instance of `Needle` found and return it
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			return Index;
		end;
	end;

	-- If no occurrences exist, return `nil`
	return nil;

end;

function SupportLibrary.IsInTable(Haystack, Needle)
	-- Returns whether the given `Needle` can be found within table `Haystack`

	-- Go through every value in `Haystack` and return whether `Needle` is found
	for _, Value in pairs(Haystack) do
		if Value == Needle then
			return true;
		end;
	end;

	-- If no instances were found, return false
	return false;
end;

function SupportLibrary.DoTablesMatch(A, B)
	-- Returns whether the values of tables A and B are the same

	-- Check B table differences
	for Index in pairs(A) do
		if A[Index] ~= B[Index] then
			return false;
		end;
	end;

	-- Check A table differences
	for Index in pairs(B) do
		if B[Index] ~= A[Index] then
			return false;
		end;
	end;

	-- Return true if no differences
	return true;
end;

function SupportLibrary.Round(Number, Places)
	-- Returns `Number` rounded to the given number of decimal places (from lua-users)

	-- Ensure that `Number` is a number
	if type(Number) ~= 'number' then
		return;
	end;

	-- Round the number
	local Multiplier = 10 ^ (Places or 0);
	local RoundedNumber = math.floor(Number * Multiplier + 0.5) / Multiplier;

	-- Return the rounded number
	return RoundedNumber;
end;

function SupportLibrary.CloneTable(Table)
	-- Returns a copy of `Table`

	local ClonedTable = {};

	-- Copy all values into `ClonedTable`
	for Key, Value in pairs(Table) do
		ClonedTable[Key] = Value;
	end;

	-- Return the clone
	return ClonedTable;
end;

function SupportLibrary.GetAllDescendants(Parent)
	-- Recursively gets all the descendants of `Parent` and returns them

	local Descendants = {};

	for _, Child in pairs(Parent:GetChildren()) do

		-- Add the direct descendants of `Parent`
		table.insert(Descendants, Child);

		-- Add the descendants of each child
		for _, Subchild in pairs(SupportLibrary.GetAllDescendants(Child)) do
			table.insert(Descendants, Subchild);
		end;

	end;

	return Descendants;
end;

function SupportLibrary.GetDescendantCount(Parent)
	-- Recursively gets a count of all the descendants of `Parent` and returns them

	local Count = 0;

	for _, Child in pairs(Parent:GetChildren()) do

		-- Count the direct descendants of `Parent`
		Count = Count + 1;

		-- Count and add the descendants of each child
		Count = Count + SupportLibrary.GetDescendantCount(Child);

	end;

	return Count;
end;

function SupportLibrary.CloneParts(Parts)
	-- Returns a table of cloned `Parts`

	local Clones = {};

	-- Copy the parts into `Clones`
	for Index, Part in pairs(Parts) do
		Clones[Index] = Part:Clone();
	end;

	return Clones;
end;

function SupportLibrary.SplitString(String, Delimiter)
	-- Returns a table of string `String` split by pattern `Delimiter`

	local StringParts = {};
	local Pattern = ('([^%s]+)'):format(Delimiter);

	-- Capture each separated part
	String:gsub(Pattern, function (Part)
		table.insert(StringParts, Part);
	end);

	return StringParts;
end;

function SupportLibrary.GetChildOfClass(Parent, ClassName, Inherit)
	-- Returns the first child of `Parent` that is of class `ClassName`
	-- or nil if it couldn't find any

	-- Look for a child of `Parent` of class `ClassName` and return it
	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				return Child;
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				return Child;
			end;
		end;
	end;

	return nil;
end;

function SupportLibrary.GetChildrenOfClass(Parent, ClassName, Inherit)
	-- Returns a table containing the children of `Parent` that are
	-- of class `ClassName`

	local Matches = {};

	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				table.insert(Matches, Child);
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				table.insert(Matches, Child);
			end;
		end;
	end;

	return Matches;
end;

function SupportLibrary.HSVToRGB(Hue, Saturation, Value)
	-- Returns the RGB equivalent of the given HSV-defined color
	-- (adapted from some code found around the web)

	-- If it's achromatic, just return the value
	if Saturation == 0 then
		return Value;
	end;

	-- Get the hue sector
	local HueSector = math.floor(Hue / 60);
	local HueSectorOffset = (Hue / 60) - HueSector;

	local P = Value * (1 - Saturation);
	local Q = Value * (1 - Saturation * HueSectorOffset);
	local T = Value * (1 - Saturation * (1 - HueSectorOffset));

	if HueSector == 0 then
		return Value, T, P;
	elseif HueSector == 1 then
		return Q, Value, P;
	elseif HueSector == 2 then
		return P, Value, T;
	elseif HueSector == 3 then
		return P, Q, Value;
	elseif HueSector == 4 then
		return T, P, Value;
	elseif HueSector == 5 then
		return Value, P, Q;
	end;
end;

function SupportLibrary.RGBToHSV(Red, Green, Blue)
	-- Returns the HSV equivalent of the given RGB-defined color
	-- (adapted from some code found around the web)

	local Hue, Saturation, Value;

	local MinValue = math.min(Red, Green, Blue);
	local MaxValue = math.max(Red, Green, Blue);

	Value = MaxValue;

	local ValueDelta = MaxValue - MinValue;

	-- If the color is not black
	if MaxValue ~= 0 then
		Saturation = ValueDelta / MaxValue;

	-- If the color is purely black
	else
		Saturation = 0;
		Hue = -1;
		return Hue, Saturation, Value;
	end;

	if Red == MaxValue then
		Hue = (Green - Blue) / ValueDelta;
	elseif Green == MaxValue then
		Hue = 2 + (Blue - Red) / ValueDelta;
	else
		Hue = 4 + (Red - Green) / ValueDelta;
	end;

	Hue = Hue * 60;
	if Hue < 0 then
		Hue = Hue + 360;
	end;

	return Hue, Saturation, Value;
end;

function SupportLibrary.IdentifyCommonItem(Items)
	-- Returns the common item in table `Items`, or `nil` if
	-- they vary

	local CommonItem = nil;

	for ItemIndex, Item in pairs(Items) do

		-- Set the initial item to compare against
		if ItemIndex == 1 then
			CommonItem = Item;

		-- Check if this item is the same as the rest
		else
			-- If it isn't the same, there is no common item, so just stop right here
			if Item ~= CommonItem then
				return nil;
			end;
		end;

	end;

	-- Return the common item
	return CommonItem;
end;

function SupportLibrary.IdentifyCommonProperty(Items, Property)
	-- Returns the common `Property` value in the instances given in `Items`

	local PropertyVariations = {};

	-- Capture all the variations of the property value
	for _, Item in pairs(Items) do
		table.insert(PropertyVariations, Item[Property]);
	end;

	-- Return the common property value
	return SupportLibrary.IdentifyCommonItem(PropertyVariations);

end;

function SupportLibrary.CreateSignal()
	-- Returns a ROBLOX-like signal for connections (RbxUtility's is buggy)

	local Signal = {
		Connections	= {};

		-- Provide a function to connect an event handler
		Connect = function (Signal, Handler)

			-- Register the handler
			table.insert(Signal.Connections, Handler);

			-- Return a controller for this connection
			local ConnectionController = {

				-- Include a reference to the connection's handler
				Handler = Handler;

				-- Provide a way to disconnect this connection
				Disconnect = function (Connection)
					local ConnectionSearch = SupportLibrary.FindTableOccurrences(Signal.Connections, Connection.Handler);
					if #ConnectionSearch > 0 then
						local ConnectionIndex = ConnectionSearch[1];
						table.remove(Signal.Connections, ConnectionIndex);
					end;
				end;

			};

			-- Add compatibility aliases
			ConnectionController.disconnect = ConnectionController.Disconnect;

			-- Return the connection's controller
			return ConnectionController;

		end;

		-- Provide a function to trigger any connections' handlers
		Fire = function (Signal, ...)
			for _, Connection in pairs(Signal.Connections) do
				Connection(...);
			end;
		end;
	};

	-- Add compatibility aliases
	Signal.connect	= Signal.Connect;
	Signal.fire		= Signal.Fire;

	return Signal;
end;

function SupportLibrary.GetPartCorners(Part)
	-- Returns a table of the given part's corners' CFrames

	-- Make references to functions called a lot for efficiency
	local Insert = table.insert;
	local ToWorldSpace = CFrame.new().toWorldSpace;
	local NewCFrame = CFrame.new;

	-- Get info about the part
	local PartCFrame = Part.CFrame;
	local SizeX, SizeY, SizeZ = Part.Size.x / 2, Part.Size.y / 2, Part.Size.z / 2;

	-- Get each corner
	local Corners = {};
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, -SizeZ)));

	return Corners;
end;

function SupportLibrary.CreatePart(PartType)
	-- Creates and returns new part based on `PartType` with sensible defaults

	local NewPart;

	if PartType == 'Normal' then
		NewPart = Instance.new('Part');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Truss' then
		NewPart = Instance.new('TrussPart');

	elseif PartType == 'Wedge' then
		NewPart = Instance.new('WedgePart');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Corner' then
		NewPart = Instance.new('CornerWedgePart');

	elseif PartType == 'Cylinder' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Cylinder';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;
		NewPart.Size = Vector3.new(2, 2, 2);

	elseif PartType == 'Ball' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Ball';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;

	elseif PartType == 'Seat' then
		NewPart = Instance.new('Seat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Vehicle Seat' then
		NewPart = Instance.new('VehicleSeat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Spawn' then
		NewPart = Instance.new('SpawnLocation');
		NewPart.Size = Vector3.new(4, 1, 2);
	end;
	
	-- Make sure the part is anchored
	NewPart.Anchored = true;

	return NewPart;
end;

function SupportLibrary.ImportServices()
	-- Adds references to common services into the calling environment

	-- Get the calling environment
	local CallingEnvironment = getfenv(2);

	-- Add the services
	CallingEnvironment.Workspace = Game:GetService 'Workspace';
	CallingEnvironment.Players = Game:GetService 'Players';
	CallingEnvironment.MarketplaceService = Game:GetService 'MarketplaceService';
	CallingEnvironment.ContentProvider = Game:GetService 'ContentProvider';
	CallingEnvironment.SoundService = Game:GetService 'SoundService';
	CallingEnvironment.UserInputService = Game:GetService 'UserInputService';
	CallingEnvironment.SelectionService = Game:GetService 'Selection';
	CallingEnvironment.CoreGui = Game:GetService 'CoreGui';
	CallingEnvironment.HttpService = Game:GetService 'HttpService';
	CallingEnvironment.ChangeHistoryService = Game:GetService 'ChangeHistoryService';
	CallingEnvironment.ReplicatedStorage = Game:GetService 'ReplicatedStorage';
	CallingEnvironment.GroupService = Game:GetService 'GroupService';
	CallingEnvironment.ServerScriptService = Game:GetService 'ServerScriptService';
	CallingEnvironment.ServerStorage = Game:GetService 'ServerStorage';
	CallingEnvironment.StarterGui = Game:GetService 'StarterGui';
	CallingEnvironment.RunService = Game:GetService 'RunService';
end;

function SupportLibrary.GetListMembers(List, MemberName)
	-- Gets the given member for each object in the given list table

	local Members = {};

	-- Collect the member values for each item in the list
	for _, Item in pairs(List) do
		table.insert(Members, Item[MemberName]);
	end;

	-- Return the members
	return Members;

end;

function SupportLibrary.AddUserInputListener(InputState, InputType, CatchAll, Callback)
	-- Connects to the given user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Game:GetService('UserInputService')['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Make sure any key input did not occur while typing into a UI
		if InputType == Enum.UserInputType.Keyboard and Game:GetService('UserInputService'):GetFocusedTextBox() then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AddGuiInputListener(Gui, InputState, InputType, CatchAll, Callback)
	-- Connects to the given GUI user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Gui['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AreKeysPressed(...)
	-- Returns whether the given keys are pressed

	local RequestedKeysPressed = 0;

	-- Get currently pressed keys
	local PressedKeys = SupportLibrary.GetListMembers(Game:GetService('UserInputService'):GetKeysPressed(), 'KeyCode');

	-- Go through each requested key
	for _, Key in pairs({ ... }) do

		-- Count requested keys that are pressed
		if SupportLibrary.IsInTable(PressedKeys, Key) then
			RequestedKeysPressed = RequestedKeysPressed + 1;
		end;

	end;

	-- Return whether all the requested keys are pressed or not
	return RequestedKeysPressed == #{...};

end;

function SupportLibrary.ConcatTable(DestinationTable, SourceTable)
	-- Inserts all values of SourceTable into DestinationTable

	-- Add each value from `SourceTable` into `DestinationTable`
	for _, Value in ipairs(SourceTable) do
		table.insert(DestinationTable, Value);
	end;

	-- Return the destination table
	return DestinationTable;
end;

function SupportLibrary.ClearTable(Table)
	-- Clears out every value in `Table`

	-- Clear each index
	for Index in pairs(Table) do
		Table[Index] = nil;
	end;

	-- Return the given table
	return Table;
end;

function SupportLibrary.Values(Table)
	-- Returns all the values in the given table

	local Values = {};

	-- Go through each key and get each value
	for _, Value in pairs(Table) do
		table.insert(Values, Value);
	end;

	-- Return the values
	return Values;
end;

function SupportLibrary.Keys(Table)
	-- Returns all the keys in the given table

	local Keys = {};

	-- Go through each key and get each value
	for Key in pairs(Table) do
		table.insert(Keys, Key);
	end;

	-- Return the values
	return Keys;
end;

function SupportLibrary.Call(Function, ...)
	-- Returns a callback to `Function` with the given arguments
	local Args = { ... };
	return function (...)
		return Function(unpack(
			SupportLibrary.ConcatTable(SupportLibrary.CloneTable(Args), { ... })
		));
	end;
end;

function SupportLibrary.Trim(String)
	-- Returns a trimmed version of `String` (adapted from code from lua-users)
	return (String:gsub("^%s*(.-)%s*$", "%1"));
end

function SupportLibrary.ChainCall(...)
	-- Returns function that passes arguments through given functions and returns the final result

	-- Get the given chain of functions
	local Chain = { ... };

	-- Return the chaining function
	return function (...)

		-- Get arguments
		local Arguments = { ... };

		-- Go through each function and store the returned data to reuse in the next function's arguments 
		for _, Function in ipairs(Chain) do
			Arguments = { Function(unpack(Arguments)) };
		end;

		-- Return the final returned data
		return unpack(Arguments);

	end;

end;

function SupportLibrary.CountKeys(Table)
	-- Returns the number of keys in `Table`

	local Count = 0;

	-- Count each key
	for _ in pairs(Table) do
		Count = Count + 1;
	end;

	-- Return the count
	return Count;

end;

function SupportLibrary.Slice(Table, Start, End)
	-- Returns values from `Start` to `End` in `Table`

	local Slice = {};

	-- Go through the given indices
	for Index = Start, End do
		table.insert(Slice, Table[Index]);
	end;

	-- Return the slice
	return Slice;

end;

function SupportLibrary.FlipTable(Table)
	-- Returns a table with keys and values in `Table` swapped

	local FlippedTable = {};

	-- Flip each key and value
	for Key, Value in pairs(Table) do
		FlippedTable[Value] = Key;
	end;

	-- Return the flipped table
	return FlippedTable;

end;

function SupportLibrary.ScheduleRecurringTask(TaskFunction, Interval)
	-- Repeats `Task` every `Interval` seconds until stopped

	-- Create a task object
	local Task = {

		-- A switch determining if it's running or not
		Running = true;

		-- A function to stop this task
		Stop = function (Task)
			Task.Running = false;
		end;

		-- References to the task function and set interval
		TaskFunction = TaskFunction;
		Interval = Interval;

	};

	coroutine.wrap(function (Task)

		-- Repeat the task
		while wait(Task.Interval) and Task.Running do
			Task.TaskFunction();
		end;

	end)(Task);

	-- Return the task object
	return Task;

end;

function SupportLibrary.Clamp(Number, Minimum, Maximum)
	-- Returns the given number, clamped according to the provided min/max

	-- Clamp the number
	if Minimum and Number < Minimum then
		Number = Minimum;
	elseif Maximum and Number > Maximum then
		Number = Maximum;
	end;

	-- Return the clamped number
	return Number;

end;

function SupportLibrary.ReverseTable(Table)
	-- Returns a new table with values in the opposite order

	local ReversedTable = {};

	-- Copy each value at the opposite key
	for Index, Value in ipairs(Table) do
		ReversedTable[#Table - Index + 1] = Value;
	end;

	-- Return the reversed table
	return ReversedTable;

end;

return SupportLibrary;
end;
};
G2L_MODULES[G2L["23"]] = {
Closure = function()
    local script = G2L["23"];-- Services
MarketplaceService = Game:GetService 'MarketplaceService';
HttpService = Game:GetService 'HttpService';
Workspace = Game:GetService 'Workspace';

-- References
Tool = script.Parent;
Support = require(Tool:WaitForChild 'SupportLibrary');
RegionModule = require(Tool:WaitForChild 'Region by AxisAngle');

-- Initialize the security module
Security = {};

-- The distance above the area-defining part that counts as part of the area
Security.AreaHeight = 500;

-- Whether to allow building outside of private areas
Security.AllowPublicBuilding = true;

-- Allowed locations in the hierarchy (descendants of which are authorized)
Security.AllowedLocations = { Workspace };

-- Track the enabling of areas
Security.Areas = Workspace:FindFirstChild('[Private Building Areas]');
Workspace.ChildAdded:connect(function (Child)
	if not Security.Areas and Child.Name == '[Private Building Areas]' then
		Security.Areas = Child;
	end;
end);
Workspace.ChildRemoved:connect(function (Child)
	if Security.Areas and Child.Name == '[Private Building Areas]' then
		Security.Areas = nil;
	end;
end);

function Security.IsAreaAuthorizedForPlayer(Area, Player)
	-- Returns whether `Player` has permission to manipulate parts in this area

	-- Ensure area has permissions
	local Permissions = Area:FindFirstChild '[Permissions]';
	if not Permissions then
		return;
	else
		Permissions = require(Permissions);
	end;

	-- Ensure permissions are set up
	if not Permissions then
		return;
	end;

	-- Search for authorizing permission
	for _, Permission in pairs(Permissions) do

		-- Check group permissions
		if Permission.Type == 'Group' then

			-- Check player's group membership
			local PlayerInGroup = Player:IsInGroup(Permission.GroupId);

			-- If no specific rank is required, authorize
			if PlayerInGroup and not Permission.Ranks then
				return true;

			-- If specific rank is required, check player rank
			elseif PlayerInGroup and Permission.Ranks then
				local Symbol, RankNumber = tostring(Permission.Ranks):match('([<>]?=?)([0-9]+)');
				local PlayerRank = Player:GetRankInGroup(Permission.GroupId);
				RankNumber = tonumber(RankNumber);

				-- Check the player rank
				if not Symbol and (PlayerRank == RankNumber) then
					return true;
				elseif Symbol == '=' and (PlayerRank == RankNumber) then
					return true;
				elseif Symbol == '>' and (PlayerRank > RankNumber) then
					return true;
				elseif Symbol == '<' and (PlayerRank < RankNumber) then
					return true;
				elseif Symbol == '>=' and (PlayerRank >= RankNumber) then
					return true;
				elseif Symbol == '<=' and (PlayerRank <= RankNumber) then
					return true;
				end;
			end;

		-- Check player permissions
		elseif Permission.Type == 'Player' then
			if (Player.userId == Permission.PlayerId) or (Player.Name == Permission.PlayerName) then
				return true;
			end;

		-- Check owner permissions
		elseif Permission.Type == 'Owner' then
			if (Player.userId == Permission.PlayerId) or (Player.Name == Permission.PlayerName) then
				return true;
			end;

		-- Check auto-permissions
		elseif Permission.Type == 'Anybody' then
			return true;

		-- Check friend permissions
		elseif Permission.Type == 'Friends' then
			if Player:IsFriendsWith(Permission.PlayerId) then
				return true;
			end;

		-- Check asset permissions
		elseif Permission.Type == 'Asset' then
			if MarketplaceService:PlayerOwnsAsset(Player, Permission.AssetId) then
				return true;
			end;

		-- Check team permissions
		elseif Permission.Type == 'Team' then
			if Permission.Team and Player.Team == Permission.Team then
				return true;
			elseif Permission.TeamColor and Player.Team and Player.Team.TeamColor == Permission.TeamColor then
				return true;
			elseif Permission.TeamName and Player.Team and Player.Team.Name == Permission.TeamName then
				return true;
			end;
		
		-- Check BC permissions
		elseif Permission.Type == 'NoBC' then
			if Player.MembershipType == Enum.MembershipType.None then
				return true;
			end;
		elseif Permission.Type == 'AnyBC' then
			if Player.MembershipType ~= Enum.MembershipType.None then
				return true;
			end;
		elseif Permission.Type == 'BC' then
			if Player.MembershipType == Enum.MembershipType.BuildersClub then
				return true;
			end;
		elseif Permission.Type == 'TBC' then
			if Player.MembershipType == Enum.MembershipType.TurboBuildersClub then
				return true;
			end;
		elseif Permission.Type == 'OBC' then
			if Player.MembershipType == Enum.MembershipType.OutrageousBuildersClub then
				return true;
			end;

		-- Check custom permissions
		elseif Permission.Type == 'Callback' then
			return Permission.Callback(Player);
		end;

	end;

	-- If the player passes none of these conditions, deny access
	return false;
end;

function Security.IsItemAllowed(Item)
	-- Returns whether instance `Item` can be accessed

	-- Ensure `Item` is a part or a model
	-- Check if `Item` descendants from any allowed location
	for _, AllowedLocation in pairs(Security.AllowedLocations) do
		if Item:IsDescendantOf(AllowedLocation) then
			return true;
		end;
	end;

	-- Deny if `Item` is not a descendant of any allowed location
	return false;

end;

function Security.AreAreasEnabled()
	-- Returns whether areas are enabled

	-- Base whether areas are enabled depending on area container presence and tool mode
	if Security.Areas and Tool.ClassName == 'Tool' then
		return true;
	else
		return false;
	end;
end;

function Security.ArePartsViolatingAreas(Parts, Player, ExemptPartial, AreaPermissions)
	-- Returns whether the given parts are inside any unauthorized areas

	-- Make sure area security is being enforced
	if not Security.AreAreasEnabled() then
		return false;
	end;

	-- Make sure there is a permissions cache
	AreaPermissions = AreaPermissions or {};

	-- Check which areas the parts are in
	local Areas, AreaMap = Security.GetSelectionAreas(Parts, not ExemptPartial and not Security.AllowPublicBuilding);

	-- Check authorization for each relevant area
	for _, Area in pairs(Areas) do

		-- Determine authorization if not in given permissions cache
		if AreaPermissions[Area] == nil then
			AreaPermissions[Area] = Security.IsAreaAuthorizedForPlayer(Area, Player);
		end;

		-- If unauthorized and partial violations aren't exempt, declare violation
		if not ExemptPartial and AreaPermissions[Area] == false then
			return true;
		end;

		-- If authorized, and partial violations are exempt, call off any violation
		if ExemptPartial and AreaPermissions[Area] then
			return false;
		end;

	end;

	-- If not in a private area, determine violation based on public building policy
	if #Areas == 0 then
		return not Security.AllowPublicBuilding;

	-- If authorization for a partial violation-exempt check on an area failed, indicate a violation
	elseif ExemptPartial then
		return true;

	-- If in authorized areas, determine violation based on public building policy compliance
	elseif AreaMap and not Security.AllowPublicBuilding then

		-- Check area residence of each part's corner
		local PartCornerCompliance = {};
		for AreaRegion, Parts in pairs(AreaMap) do
			for _, Part in pairs(Parts) do
				PartCornerCompliance[Part] = PartCornerCompliance[Part] or 0;

				-- Track the number of corners that `Part` has in this region
				for _, Corner in pairs(Support.GetPartCorners(Part)) do
					if AreaRegion:CastPoint(Corner.p) then
						PartCornerCompliance[Part] = PartCornerCompliance[Part] + 1;
					end;
				end;

			end;
		end;

		-- Ensure all corners of the part are contained within areas
		for _, CornersContained in pairs(PartCornerCompliance) do
			if CornersContained ~= 8 then
				return true;
			end;
		end;

	end;

	-- If no violations occur, indicate no violations
	return false;
end;

function Security.GetSelectionAreas(Selection, ReturnMap)
	-- Returns a list of areas that the selection of parts is in

	-- Make sure areas are enabled
	if not Security.AreAreasEnabled() then
		return {};
	end;

	-- Start a map if requested
	local Map = ReturnMap and {} or nil;

	-- Check each area to find out if any of the parts are within
	local Areas = {};
	for _, Area in pairs(Security.Areas:GetChildren()) do

		-- Get all parts from the selection within this area
		local Region = RegionModule.new(
			Area.CFrame * CFrame.new(0, Security.AreaHeight / 2 - Area.Size.Y / 2, 0),
			Vector3.new(Area.Size.X, Security.AreaHeight + Area.Size.Y, Area.Size.Z)
		);
		local ContainedParts = Region:CastParts(Selection);

		-- If parts are in this area, remember the area
		if #ContainedParts > 0 then
			table.insert(Areas, Area);

			-- Map out the parts for each area region
			if Map then
				Map[Region] = ContainedParts;
			end;
		end;

	end;

	-- Return the areas where any of the given parts exist
	return Areas, Map;
end;

function Security.GetPermissions(Areas, Player)
	-- Returns a cache of the current player's authorization to the given areas

	-- Make sure security is enabled
	if not Security.AreAreasEnabled() then
		return;
	end;

	-- Build the cache of permissions for each area
	local Cache = {};
	for _, Area in pairs(Areas) do
		Cache[Area] = Security.IsAreaAuthorizedForPlayer(Area, Player);
	end;

	-- Return the permissions cache
	return Cache;
end;

return Security;
end;
};
G2L_MODULES[G2L["24"]] = {
Closure = function()
    local script = G2L["24"];--[[
By AxisAngle, (Trey Reynolds)
Documentation
http://www.roblox.com/item.aspx?id=227509468

Region constructors:
	Region Region.new(CFrame RegionCFrame, Vector3 RegionSize)
		>Returns a new Region object

	Region Region.FromPart(Instance Part)
		>Returns a new Region objects


Region methods:
	table Region:Cast([Instance or table Ignore])
		>Returns all parts in the Region, ignoring the Ignore

	bool Region:CastPart(Instance Part)
		>Returns true if Part is within Region, false otherwise

	table Region:CastParts(table Parts)
		>Returns a table of all parts within the region

	bool Region:CastPoint(Vector3 Point)
		>Returns true if Point intersects Region, false otherwise

	bool Region:CastSphere(Vector3 SphereCenter, number SphereRadius)
		>Returns true if Sphere intersects Region, false otherwise

	bool Region:CastBox(CFrame BoxCFrame, Vector3 BoxSize)
		>Returns true if Box intersects Region, false otherwise



Region properties: (Regions are mutable)
	CFrame	CFrame
	Vector3	Size
	Region3	Region3



Region functions:
	Region3 Region.Region3BoundingBox(CFrame BoxCFrame, Vector3 BoxSize)
		>Returns the enclosing boundingbox of Box

	table Region.FindAllPartsInRegion3(Region3 Region3, [Instance or table Ignore])
		>Returns all parts within a Region3 of any size

	bool Region.BoxPointCollision(CFrame BoxCFrame, Vector3 BoxSize, Vector3 Point)
		>Returns true if the Point is intersecting the Box, false otherwise

	bool Region.BoxSphereCollision(CFrame BoxCFrame, Vector3 BoxSize, Vector3 SphereCenter, number SphereRadius)
		>Returns true if the Sphere is intersecting the Box, false otherwise

	bool Region.BoxCollision(CFrame Box0CFrame, Vector3 Box0Size, CFrame Box1CFrame, Vector3 Box1Size, [bool AssumeTrue])
		>Returns true if the boxes are intersecting, false otherwise
		If AssumeTrue is left blank, it does the full check to see if Box0 is intersecting Box1
		If AssumeTrue is true, it skips the heavy check and assumes that any part that could possibly be in the Region is
		If AssumeTrue is false, it skips the heavy check and assumes that any part that could possible be outside the Region is
	
	bool Region.CastPoint(Vector3 Point, [Instance or table Ignore])
		>Returns true if the point intersects a part, false otherwise
]]

local Region={}



local BoxPointCollision do
	local VecDiv=CFrame.new().pointToObjectSpace--Right Division, yo.
	function BoxPointCollision(CFrame,Size,Point)
		local Relative	=VecDiv(CFrame, Point)
		local sx,sy,sz	=Size.x/2,Size.y/2,Size.z/2
		local rx,ry,rz	=Relative.x,Relative.y,Relative.z
		return			rx*rx<sx*sx and ry*ry<sy*sy and rz*rz<sz*sz
	end
end



local BoxSphereCollision do
	local VecDiv=CFrame.new().pointToObjectSpace--Right Division, yo.
	function BoxSphereCollision(CFrame,Size,Center,Radius)
		local Relative	=VecDiv(CFrame,Center)
		local sx,sy,sz	=Size.x/2,Size.y/2,Size.z/2
		local rx,ry,rz	=Relative.x,Relative.y,Relative.z
		local dx		=rx>sx and rx-sx--Faster than if statement
						or rx<-sx and rx+sx
						or 0
		local dy		=ry>sy and ry-sy
						or ry<-sy and ry+sy
						or 0
		local dz		=rz>sz and rz-sz
						or rz<-sz and rz+sz
						or 0
		return dx*dx+dy*dy+dz*dz<Radius*Radius
	end
end



--There's a reason why this hasn't been done before by ROBLOX users (as far as I know)
--It's really mathy, really long, and really confusing.
--0.000033 seconds is the worst, 0.000018 looks like the average case.
--Also I ran out of local variables so I had to redo everything so that I could reuse the names lol.
--So don't even try to read it.
local BoxCollision do
	local components=CFrame.new().components
	function BoxCollision(CFrame0,Size0,CFrame1,Size1,AssumeTrue)
		local	m00,m01,m02,
				m03,m04,m05,
				m06,m07,m08,
				m09,m10,m11	=components(CFrame0)
		local	m12,m13,m14,
				m15,m16,m17,
				m18,m19,m20,
				m21,m22,m23	=components(CFrame1)
		local	m24,m25,m26	=Size0.x/2,Size0.y/2,Size0.z/2
		local	m27,m28,m29	=Size1.x/2,Size1.y/2,Size1.z/2
		local	m30,m31,m32	=m12-m00,m13-m01,m14-m02
		local	m00			=m03*m30+m06*m31+m09*m32
		local	m01			=m04*m30+m07*m31+m10*m32
		local	m02			=m05*m30+m08*m31+m11*m32
		local	m12			=m15*m30+m18*m31+m21*m32
		local	m13			=m16*m30+m19*m31+m22*m32
		local	m14			=m17*m30+m20*m31+m23*m32
		local	m30			=m12>m27 and m12-m27
							or m12<-m27 and m12+m27
							or 0
		local	m31			=m13>m28 and m13-m28
							or m13<-m28 and m13+m28
							or 0
		local	m32			=m14>m29 and m14-m29
							or m14<-m29 and m14+m29
							or 0
		local	m33			=m00>m24 and m00-m24
							or m00<-m24 and m00+m24
							or 0
		local	m34			=m01>m25 and m01-m25
							or m01<-m25 and m01+m25
							or 0
		local	m35			=m02>m26 and m02-m26
							or m02<-m26 and m02+m26
							or 0
		local	m36			=m30*m30+m31*m31+m32*m32
		local	m30			=m33*m33+m34*m34+m35*m35
		local	m31			=m24<m25 and (m24<m26 and m24 or m26)
							or (m25<m26 and m25 or m26)
		local	m32			=m27<m28 and (m27<m29 and m27 or m29)
							or (m28<m29 and m28 or m29)
		if m36<m31*m31 or m30<m32*m32 then
			return true
		elseif m36>m24*m24+m25*m25+m26*m26 or m30>m27*m27+m28*m28+m29*m29 then
			return false
		elseif AssumeTrue==nil then
			--LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOL
			--(This is how you tell if something was made by Axis Angle)
			local m30=m03*m15+m06*m18+m09*m21
			local m31=m03*m16+m06*m19+m09*m22
			local m32=m03*m17+m06*m20+m09*m23
			local m03=m04*m15+m07*m18+m10*m21
			local m06=m04*m16+m07*m19+m10*m22
			local m09=m04*m17+m07*m20+m10*m23
			local m04=m05*m15+m08*m18+m11*m21
			local m07=m05*m16+m08*m19+m11*m22
			local m10=m05*m17+m08*m20+m11*m23
			local m05=m29*m29
			local m08=m27*m27
			local m11=m28*m28
			local m15=m24*m30
			local m16=m25*m03
			local m17=m26*m04
			local m18=m24*m31
			local m19=m25*m06
			local m20=m26*m07
			local m21=m24*m32
			local m22=m25*m09
			local m23=m26*m10
			local m33=m15+m16+m17-m12;if m33*m33<m08 then local m34=m18+m19+m20-m13;if m34*m34<m11 then local m35=m21+m22+m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=-m15+m16+m17-m12;if m33*m33<m08 then local m34=-m18+m19+m20-m13;if m34*m34<m11 then local m35=-m21+m22+m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=m15-m16+m17-m12;if m33*m33<m08 then local m34=m18-m19+m20-m13;if m34*m34<m11 then local m35=m21-m22+m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=-m15-m16+m17-m12;if m33*m33<m08 then local m34=-m18-m19+m20-m13;if m34*m34<m11 then local m35=-m21-m22+m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=m15+m16-m17-m12;if m33*m33<m08 then local m34=m18+m19-m20-m13;if m34*m34<m11 then local m35=m21+m22-m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=-m15+m16-m17-m12;if m33*m33<m08 then local m34=-m18+m19-m20-m13;if m34*m34<m11 then local m35=-m21+m22-m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=m15-m16-m17-m12;if m33*m33<m08 then local m34=m18-m19-m20-m13;if m34*m34<m11 then local m35=m21-m22-m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m33=-m15-m16-m17-m12;if m33*m33<m08 then local m34=-m18-m19-m20-m13;if m34*m34<m11 then local m35=-m21-m22-m23-m14;if m35*m35<m05 then return true;end;end;end;
			local m12=m24*m24
			local m13=m25*m25
			local m14=m26*m26
			local m15=m27*m04
			local m16=m28*m07
			local m17=m27*m30
			local m18=m28*m31
			local m19=m27*m03
			local m20=m28*m06
			local m21=m29*m10
			local m22=m29*m32
			local m23=m29*m09
			local m35=(m02-m26+m15+m16)/m10;if m35*m35<m05 then local m33=m00+m17+m18-m35*m32;if m33*m33<m12 then local m34=m01+m19+m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26+m15+m16)/m10;if m35*m35<m05 then local m33=m00+m17+m18-m35*m32;if m33*m33<m12 then local m34=m01+m19+m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26-m15+m16)/m10;if m35*m35<m05 then local m33=m00-m17+m18-m35*m32;if m33*m33<m12 then local m34=m01-m19+m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26-m15+m16)/m10;if m35*m35<m05 then local m33=m00-m17+m18-m35*m32;if m33*m33<m12 then local m34=m01-m19+m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26+m15-m16)/m10;if m35*m35<m05 then local m33=m00+m17-m18-m35*m32;if m33*m33<m12 then local m34=m01+m19-m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26+m15-m16)/m10;if m35*m35<m05 then local m33=m00+m17-m18-m35*m32;if m33*m33<m12 then local m34=m01+m19-m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26-m15-m16)/m10;if m35*m35<m05 then local m33=m00-m17-m18-m35*m32;if m33*m33<m12 then local m34=m01-m19-m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26-m15-m16)/m10;if m35*m35<m05 then local m33=m00-m17-m18-m35*m32;if m33*m33<m12 then local m34=m01-m19-m20-m35*m09;if m34*m34<m13 then return true;end;end;end;
			local m35=(m00-m24+m17+m18)/m32;if m35*m35<m05 then local m33=m01+m19+m20-m35*m09;if m33*m33<m13 then local m34=m02+m15+m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m17+m18)/m32;if m35*m35<m05 then local m33=m01+m19+m20-m35*m09;if m33*m33<m13 then local m34=m02+m15+m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m17+m18)/m32;if m35*m35<m05 then local m33=m01-m19+m20-m35*m09;if m33*m33<m13 then local m34=m02-m15+m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m17+m18)/m32;if m35*m35<m05 then local m33=m01-m19+m20-m35*m09;if m33*m33<m13 then local m34=m02-m15+m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24+m17-m18)/m32;if m35*m35<m05 then local m33=m01+m19-m20-m35*m09;if m33*m33<m13 then local m34=m02+m15-m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m17-m18)/m32;if m35*m35<m05 then local m33=m01+m19-m20-m35*m09;if m33*m33<m13 then local m34=m02+m15-m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m17-m18)/m32;if m35*m35<m05 then local m33=m01-m19-m20-m35*m09;if m33*m33<m13 then local m34=m02-m15-m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m17-m18)/m32;if m35*m35<m05 then local m33=m01-m19-m20-m35*m09;if m33*m33<m13 then local m34=m02-m15-m16-m35*m10;if m34*m34<m14 then return true;end;end;end;
			local m35=(m01-m25+m19+m20)/m09;if m35*m35<m05 then local m33=m02+m15+m16-m35*m10;if m33*m33<m14 then local m34=m00+m17+m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m19+m20)/m09;if m35*m35<m05 then local m33=m02+m15+m16-m35*m10;if m33*m33<m14 then local m34=m00+m17+m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m19+m20)/m09;if m35*m35<m05 then local m33=m02-m15+m16-m35*m10;if m33*m33<m14 then local m34=m00-m17+m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m19+m20)/m09;if m35*m35<m05 then local m33=m02-m15+m16-m35*m10;if m33*m33<m14 then local m34=m00-m17+m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25+m19-m20)/m09;if m35*m35<m05 then local m33=m02+m15-m16-m35*m10;if m33*m33<m14 then local m34=m00+m17-m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m19-m20)/m09;if m35*m35<m05 then local m33=m02+m15-m16-m35*m10;if m33*m33<m14 then local m34=m00+m17-m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m19-m20)/m09;if m35*m35<m05 then local m33=m02-m15-m16-m35*m10;if m33*m33<m14 then local m34=m00-m17-m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m19-m20)/m09;if m35*m35<m05 then local m33=m02-m15-m16-m35*m10;if m33*m33<m14 then local m34=m00-m17-m18-m35*m32;if m34*m34<m12 then return true;end;end;end;
			local m35=(m02-m26+m16+m21)/m04;if m35*m35<m08 then local m33=m00+m18+m22-m35*m30;if m33*m33<m12 then local m34=m01+m20+m23-m35*m03;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26+m16+m21)/m04;if m35*m35<m08 then local m33=m00+m18+m22-m35*m30;if m33*m33<m12 then local m34=m01+m20+m23-m35*m03;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26-m16+m21)/m04;if m35*m35<m08 then local m33=m00-m18+m22-m35*m30;if m33*m33<m12 then local m34=m01-m20+m23-m35*m03;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26-m16+m21)/m04;if m35*m35<m08 then local m33=m00-m18+m22-m35*m30;if m33*m33<m12 then local m34=m01-m20+m23-m35*m03;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26+m16-m21)/m04;if m35*m35<m08 then local m33=m00+m18-m22-m35*m30;if m33*m33<m12 then local Axi=m01+m20-m23-m35*m03;if Axi*Axi<m13 then return true;end;end;end;
			local m35=(m02+m26+m16-m21)/m04;if m35*m35<m08 then local m33=m00+m18-m22-m35*m30;if m33*m33<m12 then local sAn=m01+m20-m23-m35*m03;if sAn*sAn<m13 then return true;end;end;end;
			local m35=(m02-m26-m16-m21)/m04;if m35*m35<m08 then local m33=m00-m18-m22-m35*m30;if m33*m33<m12 then local gle=m01-m20-m23-m35*m03;if gle*gle<m13 then return true;end;end;end;
			local m35=(m02+m26-m16-m21)/m04;if m35*m35<m08 then local m33=m00-m18-m22-m35*m30;if m33*m33<m12 then local m34=m01-m20-m23-m35*m03;if m34*m34<m13 then return true;end;end;end;
			local m35=(m00-m24+m18+m22)/m30;if m35*m35<m08 then local m33=m01+m20+m23-m35*m03;if m33*m33<m13 then local m34=m02+m16+m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m18+m22)/m30;if m35*m35<m08 then local m33=m01+m20+m23-m35*m03;if m33*m33<m13 then local m34=m02+m16+m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m18+m22)/m30;if m35*m35<m08 then local m33=m01-m20+m23-m35*m03;if m33*m33<m13 then local m34=m02-m16+m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m18+m22)/m30;if m35*m35<m08 then local m33=m01-m20+m23-m35*m03;if m33*m33<m13 then local m34=m02-m16+m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24+m18-m22)/m30;if m35*m35<m08 then local m33=m01+m20-m23-m35*m03;if m33*m33<m13 then local m34=m02+m16-m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m18-m22)/m30;if m35*m35<m08 then local m33=m01+m20-m23-m35*m03;if m33*m33<m13 then local m34=m02+m16-m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m18-m22)/m30;if m35*m35<m08 then local m33=m01-m20-m23-m35*m03;if m33*m33<m13 then local m34=m02-m16-m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m18-m22)/m30;if m35*m35<m08 then local m33=m01-m20-m23-m35*m03;if m33*m33<m13 then local m34=m02-m16-m21-m35*m04;if m34*m34<m14 then return true;end;end;end;
			local m35=(m01-m25+m20+m23)/m03;if m35*m35<m08 then local m33=m02+m16+m21-m35*m04;if m33*m33<m14 then local m34=m00+m18+m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m20+m23)/m03;if m35*m35<m08 then local m33=m02+m16+m21-m35*m04;if m33*m33<m14 then local m34=m00+m18+m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m20+m23)/m03;if m35*m35<m08 then local m33=m02-m16+m21-m35*m04;if m33*m33<m14 then local m34=m00-m18+m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m20+m23)/m03;if m35*m35<m08 then local m33=m02-m16+m21-m35*m04;if m33*m33<m14 then local m34=m00-m18+m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25+m20-m23)/m03;if m35*m35<m08 then local m33=m02+m16-m21-m35*m04;if m33*m33<m14 then local m34=m00+m18-m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m20-m23)/m03;if m35*m35<m08 then local m33=m02+m16-m21-m35*m04;if m33*m33<m14 then local m34=m00+m18-m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m20-m23)/m03;if m35*m35<m08 then local m33=m02-m16-m21-m35*m04;if m33*m33<m14 then local m34=m00-m18-m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m20-m23)/m03;if m35*m35<m08 then local m33=m02-m16-m21-m35*m04;if m33*m33<m14 then local m34=m00-m18-m22-m35*m30;if m34*m34<m12 then return true;end;end;end;
			local m35=(m02-m26+m21+m15)/m07;if m35*m35<m11 then local m33=m00+m22+m17-m35*m31;if m33*m33<m12 then local m34=m01+m23+m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26+m21+m15)/m07;if m35*m35<m11 then local m33=m00+m22+m17-m35*m31;if m33*m33<m12 then local m34=m01+m23+m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26-m21+m15)/m07;if m35*m35<m11 then local m33=m00-m22+m17-m35*m31;if m33*m33<m12 then local m34=m01-m23+m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26-m21+m15)/m07;if m35*m35<m11 then local m33=m00-m22+m17-m35*m31;if m33*m33<m12 then local m34=m01-m23+m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26+m21-m15)/m07;if m35*m35<m11 then local m33=m00+m22-m17-m35*m31;if m33*m33<m12 then local m34=m01+m23-m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26+m21-m15)/m07;if m35*m35<m11 then local m33=m00+m22-m17-m35*m31;if m33*m33<m12 then local m34=m01+m23-m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02-m26-m21-m15)/m07;if m35*m35<m11 then local m33=m00-m22-m17-m35*m31;if m33*m33<m12 then local m34=m01-m23-m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m02+m26-m21-m15)/m07;if m35*m35<m11 then local m33=m00-m22-m17-m35*m31;if m33*m33<m12 then local m34=m01-m23-m19-m35*m06;if m34*m34<m13 then return true;end;end;end;
			local m35=(m00-m24+m22+m17)/m31;if m35*m35<m11 then local m33=m01+m23+m19-m35*m06;if m33*m33<m13 then local m34=m02+m21+m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m22+m17)/m31;if m35*m35<m11 then local m33=m01+m23+m19-m35*m06;if m33*m33<m13 then local m34=m02+m21+m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m22+m17)/m31;if m35*m35<m11 then local m33=m01-m23+m19-m35*m06;if m33*m33<m13 then local m34=m02-m21+m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m22+m17)/m31;if m35*m35<m11 then local m33=m01-m23+m19-m35*m06;if m33*m33<m13 then local m34=m02-m21+m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24+m22-m17)/m31;if m35*m35<m11 then local m33=m01+m23-m19-m35*m06;if m33*m33<m13 then local m34=m02+m21-m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24+m22-m17)/m31;if m35*m35<m11 then local m33=m01+m23-m19-m35*m06;if m33*m33<m13 then local m34=m02+m21-m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00-m24-m22-m17)/m31;if m35*m35<m11 then local m33=m01-m23-m19-m35*m06;if m33*m33<m13 then local m34=m02-m21-m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m00+m24-m22-m17)/m31;if m35*m35<m11 then local m33=m01-m23-m19-m35*m06;if m33*m33<m13 then local m34=m02-m21-m15-m35*m07;if m34*m34<m14 then return true;end;end;end;
			local m35=(m01-m25+m23+m19)/m06;if m35*m35<m11 then local m33=m02+m21+m15-m35*m07;if m33*m33<m14 then local m34=m00+m22+m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m23+m19)/m06;if m35*m35<m11 then local m33=m02+m21+m15-m35*m07;if m33*m33<m14 then local m34=m00+m22+m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m23+m19)/m06;if m35*m35<m11 then local m33=m02-m21+m15-m35*m07;if m33*m33<m14 then local m34=m00-m22+m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m23+m19)/m06;if m35*m35<m11 then local m33=m02-m21+m15-m35*m07;if m33*m33<m14 then local m34=m00-m22+m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25+m23-m19)/m06;if m35*m35<m11 then local m33=m02+m21-m15-m35*m07;if m33*m33<m14 then local m34=m00+m22-m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25+m23-m19)/m06;if m35*m35<m11 then local m33=m02+m21-m15-m35*m07;if m33*m33<m14 then local m34=m00+m22-m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01-m25-m23-m19)/m06;if m35*m35<m11 then local m33=m02-m21-m15-m35*m07;if m33*m33<m14 then local m34=m00-m22-m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			local m35=(m01+m25-m23-m19)/m06;if m35*m35<m11 then local m33=m02-m21-m15-m35*m07;if m33*m33<m14 then local m34=m00-m22-m17-m35*m31;if m34*m34<m12 then return true;end;end;end;
			return false
		else
			return AssumeTrue
		end
	end
end


local setmetatable	=setmetatable
local components	=CFrame.new().components
local Workspace		=Workspace
local BoxCast		=Workspace.FindPartsInRegion3WithIgnoreList
local unpack		=unpack
local type			=type
local IsA			=game.IsA
local r3			=Region3.new
local v3			=Vector3.new



local function Region3BoundingBox(CFrame,Size)
 	local	x,y,z,
			xx,yx,zx,
			xy,yy,zy,
			xz,yz,zz=components(CFrame)
	local	sx,sy,sz=Size.x/2,Size.y/2,Size.z/2
	local	px		=sx*(xx<0 and -xx or xx)
					+sy*(yx<0 and -yx or yx)
					+sz*(zx<0 and -zx or zx)
	local	py		=sx*(xy<0 and -xy or xy)
					+sy*(yy<0 and -yy or yy)
					+sz*(zy<0 and -zy or zy)
	local	pz		=sx*(xz<0 and -xz or xz)
					+sy*(yz<0 and -yz or yz)
					+sz*(zz<0 and -zz or zz)
	return			r3(v3(x-px,y-py,z-pz),v3(x+px,y+py,z+pz))
end



local function FindAllPartsInRegion3(Region3,Ignore)
	local Ignore=type(Ignore)=="table" and Ignore or {Ignore}
	local Last=#Ignore
	repeat
		local Parts=BoxCast(Workspace,Region3,Ignore,100)
		local Start=#Ignore
		for i=1,#Parts do
			Ignore[Start+i]=Parts[i]
		end
	until #Parts<100;
	return {unpack(Ignore,Last+1,#Ignore)}
end



local function CastPoint(Region,Point)
	return BoxPointCollision(Region.CFrame,Region.Size,Point)
end



local function CastSphere(Region,Center,Radius)
	return BoxSphereCollision(Region.CFrame,Region.Size,Center,Radius)
end



local function CastBox(Region,CFrame,Size)
	return BoxCollision(Region.CFrame,Region.Size,CFrame,Size)
end



local function CastPart(Region,Part)
	local result = BoxCollision(Region.CFrame,Region.Size,Part.CFrame,Part.Size);
	return result;
end



local function CastParts(Region,Parts)
	local Inside={}
	for i=1,#Parts do
		if CastPart(Region,Parts[i]) then
			Inside[#Inside+1]=Parts[i]
		end
	end
	return Inside
end



local function Cast(Region,Ignore)
	local Inside={}
	local Parts=FindAllPartsInRegion3(Region.Region3,Ignore)
	for i=1,#Parts do
		if CastPart(Region,Parts[i]) then
			Inside[#Inside+1]=Parts[i]
		end
	end
	return Inside
end



local function NewRegion(CFrame,Size)
	local Object	={
		CFrame		=CFrame;
		Size		=Size;
		Region3		=Region3BoundingBox(CFrame,Size);
		Cast		=Cast;
		CastPart	=CastPart;
		CastParts	=CastParts;
		CastPoint	=CastPoint;
		CastSphere	=CastSphere;
		CastBox		=CastBox;
					}
	return			setmetatable({},{
		__index=Object;
		__newindex=function(_,Index,Value)
			Object[Index]=Value
			Object.Region3=Region3BoundingBox(Object.CFrame,Object.Size)
		end;
					})
end



Region.Region3BoundingBox	=Region3BoundingBox
Region.FindAllPartsInRegion3=FindAllPartsInRegion3
Region.BoxPointCollision	=BoxPointCollision
Region.BoxSphereCollision	=BoxSphereCollision
Region.BoxCollision			=BoxCollision
Region.new					=NewRegion
function Region.FromPart(Part)
	return NewRegion(Part.CFrame,Part.Size)
end

return Region
end;
};
G2L_MODULES[G2L["26"]] = {
Closure = function()
    local script = G2L["26"];SupportLibrary = {};

function SupportLibrary.FindTableOccurrences(Haystack, Needle)
	-- Returns the positions of instances of `needle` in table `haystack`

	local Positions = {};

	-- Add any indexes from `Haystack` that are `Needle`
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			table.insert(Positions, Index);
		end;
	end;

	return Positions;
end;

function SupportLibrary.FindTableOccurrence(Haystack, Needle)
	-- Returns one occurrence of `Needle` in `Haystack`

	-- Search for the first instance of `Needle` found and return it
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			return Index;
		end;
	end;

	-- If no occurrences exist, return `nil`
	return nil;

end;

function SupportLibrary.IsInTable(Haystack, Needle)
	-- Returns whether the given `Needle` can be found within table `Haystack`

	-- Go through every value in `Haystack` and return whether `Needle` is found
	for _, Value in pairs(Haystack) do
		if Value == Needle then
			return true;
		end;
	end;

	-- If no instances were found, return false
	return false;
end;

function SupportLibrary.DoTablesMatch(A, B)
	-- Returns whether the values of tables A and B are the same

	-- Check B table differences
	for Index in pairs(A) do
		if A[Index] ~= B[Index] then
			return false;
		end;
	end;

	-- Check A table differences
	for Index in pairs(B) do
		if B[Index] ~= A[Index] then
			return false;
		end;
	end;

	-- Return true if no differences
	return true;
end;

function SupportLibrary.Round(Number, Places)
	-- Returns `Number` rounded to the given number of decimal places (from lua-users)

	-- Ensure that `Number` is a number
	if type(Number) ~= 'number' then
		return;
	end;

	-- Round the number
	local Multiplier = 10 ^ (Places or 0);
	local RoundedNumber = math.floor(Number * Multiplier + 0.5) / Multiplier;

	-- Return the rounded number
	return RoundedNumber;
end;

function SupportLibrary.CloneTable(Table)
	-- Returns a copy of `Table`

	local ClonedTable = {};

	-- Copy all values into `ClonedTable`
	for Key, Value in pairs(Table) do
		ClonedTable[Key] = Value;
	end;

	-- Return the clone
	return ClonedTable;
end;

function SupportLibrary.GetAllDescendants(Parent)
	-- Recursively gets all the descendants of `Parent` and returns them

	local Descendants = {};

	for _, Child in pairs(Parent:GetChildren()) do

		-- Add the direct descendants of `Parent`
		table.insert(Descendants, Child);

		-- Add the descendants of each child
		for _, Subchild in pairs(SupportLibrary.GetAllDescendants(Child)) do
			table.insert(Descendants, Subchild);
		end;

	end;

	return Descendants;
end;

function SupportLibrary.GetDescendantCount(Parent)
	-- Recursively gets a count of all the descendants of `Parent` and returns them

	local Count = 0;

	for _, Child in pairs(Parent:GetChildren()) do

		-- Count the direct descendants of `Parent`
		Count = Count + 1;

		-- Count and add the descendants of each child
		Count = Count + SupportLibrary.GetDescendantCount(Child);

	end;

	return Count;
end;

function SupportLibrary.CloneParts(Parts)
	-- Returns a table of cloned `Parts`

	local Clones = {};

	-- Copy the parts into `Clones`
	for Index, Part in pairs(Parts) do
		Clones[Index] = Part:Clone();
	end;

	return Clones;
end;

function SupportLibrary.SplitString(String, Delimiter)
	-- Returns a table of string `String` split by pattern `Delimiter`

	local StringParts = {};
	local Pattern = ('([^%s]+)'):format(Delimiter);

	-- Capture each separated part
	String:gsub(Pattern, function (Part)
		table.insert(StringParts, Part);
	end);

	return StringParts;
end;

function SupportLibrary.GetChildOfClass(Parent, ClassName, Inherit)
	-- Returns the first child of `Parent` that is of class `ClassName`
	-- or nil if it couldn't find any

	-- Look for a child of `Parent` of class `ClassName` and return it
	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				return Child;
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				return Child;
			end;
		end;
	end;

	return nil;
end;

function SupportLibrary.GetChildrenOfClass(Parent, ClassName, Inherit)
	-- Returns a table containing the children of `Parent` that are
	-- of class `ClassName`

	local Matches = {};

	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				table.insert(Matches, Child);
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				table.insert(Matches, Child);
			end;
		end;
	end;

	return Matches;
end;

function SupportLibrary.HSVToRGB(Hue, Saturation, Value)
	-- Returns the RGB equivalent of the given HSV-defined color
	-- (adapted from some code found around the web)

	-- If it's achromatic, just return the value
	if Saturation == 0 then
		return Value;
	end;

	-- Get the hue sector
	local HueSector = math.floor(Hue / 60);
	local HueSectorOffset = (Hue / 60) - HueSector;

	local P = Value * (1 - Saturation);
	local Q = Value * (1 - Saturation * HueSectorOffset);
	local T = Value * (1 - Saturation * (1 - HueSectorOffset));

	if HueSector == 0 then
		return Value, T, P;
	elseif HueSector == 1 then
		return Q, Value, P;
	elseif HueSector == 2 then
		return P, Value, T;
	elseif HueSector == 3 then
		return P, Q, Value;
	elseif HueSector == 4 then
		return T, P, Value;
	elseif HueSector == 5 then
		return Value, P, Q;
	end;
end;

function SupportLibrary.RGBToHSV(Red, Green, Blue)
	-- Returns the HSV equivalent of the given RGB-defined color
	-- (adapted from some code found around the web)

	local Hue, Saturation, Value;

	local MinValue = math.min(Red, Green, Blue);
	local MaxValue = math.max(Red, Green, Blue);

	Value = MaxValue;

	local ValueDelta = MaxValue - MinValue;

	-- If the color is not black
	if MaxValue ~= 0 then
		Saturation = ValueDelta / MaxValue;

	-- If the color is purely black
	else
		Saturation = 0;
		Hue = -1;
		return Hue, Saturation, Value;
	end;

	if Red == MaxValue then
		Hue = (Green - Blue) / ValueDelta;
	elseif Green == MaxValue then
		Hue = 2 + (Blue - Red) / ValueDelta;
	else
		Hue = 4 + (Red - Green) / ValueDelta;
	end;

	Hue = Hue * 60;
	if Hue < 0 then
		Hue = Hue + 360;
	end;

	return Hue, Saturation, Value;
end;

function SupportLibrary.IdentifyCommonItem(Items)
	-- Returns the common item in table `Items`, or `nil` if
	-- they vary

	local CommonItem = nil;

	for ItemIndex, Item in pairs(Items) do

		-- Set the initial item to compare against
		if ItemIndex == 1 then
			CommonItem = Item;

		-- Check if this item is the same as the rest
		else
			-- If it isn't the same, there is no common item, so just stop right here
			if Item ~= CommonItem then
				return nil;
			end;
		end;

	end;

	-- Return the common item
	return CommonItem;
end;

function SupportLibrary.IdentifyCommonProperty(Items, Property)
	-- Returns the common `Property` value in the instances given in `Items`

	local PropertyVariations = {};

	-- Capture all the variations of the property value
	for _, Item in pairs(Items) do
		table.insert(PropertyVariations, Item[Property]);
	end;

	-- Return the common property value
	return SupportLibrary.IdentifyCommonItem(PropertyVariations);

end;

function SupportLibrary.CreateSignal()
	-- Returns a ROBLOX-like signal for connections (RbxUtility's is buggy)

	local Signal = {
		Connections	= {};

		-- Provide a function to connect an event handler
		Connect = function (Signal, Handler)

			-- Register the handler
			table.insert(Signal.Connections, Handler);

			-- Return a controller for this connection
			local ConnectionController = {

				-- Include a reference to the connection's handler
				Handler = Handler;

				-- Provide a way to disconnect this connection
				Disconnect = function (Connection)
					local ConnectionSearch = SupportLibrary.FindTableOccurrences(Signal.Connections, Connection.Handler);
					if #ConnectionSearch > 0 then
						local ConnectionIndex = ConnectionSearch[1];
						table.remove(Signal.Connections, ConnectionIndex);
					end;
				end;

			};

			-- Add compatibility aliases
			ConnectionController.disconnect = ConnectionController.Disconnect;

			-- Return the connection's controller
			return ConnectionController;

		end;

		-- Provide a function to trigger any connections' handlers
		Fire = function (Signal, ...)
			for _, Connection in pairs(Signal.Connections) do
				Connection(...);
			end;
		end;
	};

	-- Add compatibility aliases
	Signal.connect	= Signal.Connect;
	Signal.fire		= Signal.Fire;

	return Signal;
end;

function SupportLibrary.GetPartCorners(Part)
	-- Returns a table of the given part's corners' CFrames

	-- Make references to functions called a lot for efficiency
	local Insert = table.insert;
	local ToWorldSpace = CFrame.new().toWorldSpace;
	local NewCFrame = CFrame.new;

	-- Get info about the part
	local PartCFrame = Part.CFrame;
	local SizeX, SizeY, SizeZ = Part.Size.x / 2, Part.Size.y / 2, Part.Size.z / 2;

	-- Get each corner
	local Corners = {};
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, -SizeZ)));

	return Corners;
end;

function SupportLibrary.CreatePart(PartType)
	-- Creates and returns new part based on `PartType` with sensible defaults

	local NewPart;

	if PartType == 'Normal' then
		NewPart = Instance.new('Part');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Truss' then
		NewPart = Instance.new('TrussPart');

	elseif PartType == 'Wedge' then
		NewPart = Instance.new('WedgePart');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Corner' then
		NewPart = Instance.new('CornerWedgePart');

	elseif PartType == 'Cylinder' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Cylinder';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;
		NewPart.Size = Vector3.new(2, 2, 2);

	elseif PartType == 'Ball' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Ball';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;

	elseif PartType == 'Seat' then
		NewPart = Instance.new('Seat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Vehicle Seat' then
		NewPart = Instance.new('VehicleSeat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Spawn' then
		NewPart = Instance.new('SpawnLocation');
		NewPart.Size = Vector3.new(4, 1, 2);
	end;
	
	-- Make sure the part is anchored
	NewPart.Anchored = true;

	return NewPart;
end;

function SupportLibrary.ImportServices()
	-- Adds references to common services into the calling environment

	-- Get the calling environment
	local CallingEnvironment = getfenv(2);

	-- Add the services
	CallingEnvironment.Workspace = Game:GetService 'Workspace';
	CallingEnvironment.Players = Game:GetService 'Players';
	CallingEnvironment.MarketplaceService = Game:GetService 'MarketplaceService';
	CallingEnvironment.ContentProvider = Game:GetService 'ContentProvider';
	CallingEnvironment.SoundService = Game:GetService 'SoundService';
	CallingEnvironment.UserInputService = Game:GetService 'UserInputService';
	CallingEnvironment.SelectionService = Game:GetService 'Selection';
	CallingEnvironment.CoreGui = Game:GetService 'CoreGui';
	CallingEnvironment.HttpService = Game:GetService 'HttpService';
	CallingEnvironment.ChangeHistoryService = Game:GetService 'ChangeHistoryService';
	CallingEnvironment.ReplicatedStorage = Game:GetService 'ReplicatedStorage';
	CallingEnvironment.GroupService = Game:GetService 'GroupService';
	CallingEnvironment.ServerScriptService = Game:GetService 'ServerScriptService';
	CallingEnvironment.ServerStorage = Game:GetService 'ServerStorage';
	CallingEnvironment.StarterGui = Game:GetService 'StarterGui';
	CallingEnvironment.RunService = Game:GetService 'RunService';
end;

function SupportLibrary.GetListMembers(List, MemberName)
	-- Gets the given member for each object in the given list table

	local Members = {};

	-- Collect the member values for each item in the list
	for _, Item in pairs(List) do
		table.insert(Members, Item[MemberName]);
	end;

	-- Return the members
	return Members;

end;

function SupportLibrary.AddUserInputListener(InputState, InputType, CatchAll, Callback)
	-- Connects to the given user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Game:GetService('UserInputService')['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Make sure any key input did not occur while typing into a UI
		if InputType == Enum.UserInputType.Keyboard and Game:GetService('UserInputService'):GetFocusedTextBox() then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AddGuiInputListener(Gui, InputState, InputType, CatchAll, Callback)
	-- Connects to the given GUI user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Gui['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AreKeysPressed(...)
	-- Returns whether the given keys are pressed

	local RequestedKeysPressed = 0;

	-- Get currently pressed keys
	local PressedKeys = SupportLibrary.GetListMembers(Game:GetService('UserInputService'):GetKeysPressed(), 'KeyCode');

	-- Go through each requested key
	for _, Key in pairs({ ... }) do

		-- Count requested keys that are pressed
		if SupportLibrary.IsInTable(PressedKeys, Key) then
			RequestedKeysPressed = RequestedKeysPressed + 1;
		end;

	end;

	-- Return whether all the requested keys are pressed or not
	return RequestedKeysPressed == #{...};

end;

function SupportLibrary.ConcatTable(DestinationTable, SourceTable)
	-- Inserts all values of SourceTable into DestinationTable

	-- Add each value from `SourceTable` into `DestinationTable`
	for _, Value in ipairs(SourceTable) do
		table.insert(DestinationTable, Value);
	end;

	-- Return the destination table
	return DestinationTable;
end;

function SupportLibrary.ClearTable(Table)
	-- Clears out every value in `Table`

	-- Clear each index
	for Index in pairs(Table) do
		Table[Index] = nil;
	end;

	-- Return the given table
	return Table;
end;

function SupportLibrary.Values(Table)
	-- Returns all the values in the given table

	local Values = {};

	-- Go through each key and get each value
	for _, Value in pairs(Table) do
		table.insert(Values, Value);
	end;

	-- Return the values
	return Values;
end;

function SupportLibrary.Keys(Table)
	-- Returns all the keys in the given table

	local Keys = {};

	-- Go through each key and get each value
	for Key in pairs(Table) do
		table.insert(Keys, Key);
	end;

	-- Return the values
	return Keys;
end;

function SupportLibrary.Call(Function, ...)
	-- Returns a callback to `Function` with the given arguments
	local Args = { ... };
	return function (...)
		return Function(unpack(
			SupportLibrary.ConcatTable(SupportLibrary.CloneTable(Args), { ... })
		));
	end;
end;

function SupportLibrary.Trim(String)
	-- Returns a trimmed version of `String` (adapted from code from lua-users)
	return (String:gsub("^%s*(.-)%s*$", "%1"));
end

function SupportLibrary.ChainCall(...)
	-- Returns function that passes arguments through given functions and returns the final result

	-- Get the given chain of functions
	local Chain = { ... };

	-- Return the chaining function
	return function (...)

		-- Get arguments
		local Arguments = { ... };

		-- Go through each function and store the returned data to reuse in the next function's arguments 
		for _, Function in ipairs(Chain) do
			Arguments = { Function(unpack(Arguments)) };
		end;

		-- Return the final returned data
		return unpack(Arguments);

	end;

end;

function SupportLibrary.CountKeys(Table)
	-- Returns the number of keys in `Table`

	local Count = 0;

	-- Count each key
	for _ in pairs(Table) do
		Count = Count + 1;
	end;

	-- Return the count
	return Count;

end;

function SupportLibrary.Slice(Table, Start, End)
	-- Returns values from `Start` to `End` in `Table`

	local Slice = {};

	-- Go through the given indices
	for Index = Start, End do
		table.insert(Slice, Table[Index]);
	end;

	-- Return the slice
	return Slice;

end;

function SupportLibrary.FlipTable(Table)
	-- Returns a table with keys and values in `Table` swapped

	local FlippedTable = {};

	-- Flip each key and value
	for Key, Value in pairs(Table) do
		FlippedTable[Value] = Key;
	end;

	-- Return the flipped table
	return FlippedTable;

end;

function SupportLibrary.ScheduleRecurringTask(TaskFunction, Interval)
	-- Repeats `Task` every `Interval` seconds until stopped

	-- Create a task object
	local Task = {

		-- A switch determining if it's running or not
		Running = true;

		-- A function to stop this task
		Stop = function (Task)
			Task.Running = false;
		end;

		-- References to the task function and set interval
		TaskFunction = TaskFunction;
		Interval = Interval;

	};

	coroutine.wrap(function (Task)

		-- Repeat the task
		while wait(Task.Interval) and Task.Running do
			Task.TaskFunction();
		end;

	end)(Task);

	-- Return the task object
	return Task;

end;

function SupportLibrary.Clamp(Number, Minimum, Maximum)
	-- Returns the given number, clamped according to the provided min/max

	-- Clamp the number
	if Minimum and Number < Minimum then
		Number = Minimum;
	elseif Maximum and Number > Maximum then
		Number = Maximum;
	end;

	-- Return the clamped number
	return Number;

end;

function SupportLibrary.ReverseTable(Table)
	-- Returns a new table with values in the opposite order

	local ReversedTable = {};

	-- Copy each value at the opposite key
	for Index, Value in ipairs(Table) do
		ReversedTable[#Table - Index + 1] = Value;
	end;

	-- Return the reversed table
	return ReversedTable;

end;

return SupportLibrary;
end;
};
G2L_MODULES[G2L["27"]] = {
Closure = function()
    local script = G2L["27"];return {
	Name = 'SupportLibrary',
	Creator = 'F3X',
	Version = {
		Major = 1,
		Minor = 0,
		Patch = 0
	}
}
end;
};
G2L_MODULES[G2L["28"]] = {
Closure = function()
    local script = G2L["28"];local Support = require(script.SupportLibrary);
local RbxUtility = LoadLibrary 'RbxUtility';

local Cheer = {};

function Cheer.WaitFor(View)
	-- Waits until the given view fully loads

	-- Get the component's total descendant count
	local TotalCount = (View:WaitForChild 'CheerDescendantCount').Value;

	-- Check if the loaded descendant count matches the total
	if Support.GetDescendantCount(View) >= TotalCount then
		return View;
	end;

	-- Wait for the loaded descendant count to reach its total
	while Support.GetDescendantCount(View) ~= TotalCount do
		wait(0.1);
	end;

	-- Return the component
	return View;

end;

function Cheer.LoadComponent(View)

	-- Execute ModuleScript-based components
	local ComponentModule = View:FindFirstChild '[Component]';
	if ComponentModule and ComponentModule.ClassName == 'ModuleScript' then
		require(ComponentModule);
	end;

	-- Get components list
	local Components = Cheer.GetCheerData().Components;

	-- Wait for component to register
	while not Components[View] do
		Cheer.GetCheerData().ComponentRegistered:wait();
	end;

	-- Wait for component to be ready
	local Component = Components[View];
	while not Component.Ready do
		wait(0.1);
	end;

	-- Return the view's component
	return Components[View];

end;

function Cheer.FromTemplate(View, Parent)

	-- Clone and parent the component view
	local Component = View:Clone();
	Component.Parent = Parent;

	-- Load and return the component
	return Cheer.LoadComponent(Component);

end;

function Cheer.GetCheerData()
	-- Returns or initializes the game's Cheer data container

	-- Initialize Cheer data if nonexistent
	if not _G.CheerData then

		-- Create global data container
		_G.CheerData = {
			Components = {},
			ComponentRegistered = RbxUtility.CreateSignal()
		};

		-- Enable new components' OnRemove event
		Cheer.GetCheerData().ComponentRegistered:connect(function (Name, View)
			local OnRemove = Cheer(View).OnRemove;

			-- Fire `OnRemove` upon deletion
			View.AncestryChanged:connect(function (Item, Parent)
				if Parent == nil then
					OnRemove:fire();
				end;
			end);
		end);

	end;

	-- Return Cheer data
	return _G.CheerData;

end;

function Cheer.CreateComponent(Name, RootView, ManualReadiness)

	-- Ensure root view is provided
	if typeof(RootView) ~= 'Instance' then
		return;
	end;

	-- Create signal indicating component removal
	local OnRemove = RbxUtility.CreateSignal();

	-- Create component
	local Component = { View = RootView, Name = Name, OnRemove = OnRemove, Ready = not ManualReadiness };

	-- Register component
	Cheer.GetCheerData().Components[RootView] = Component;
	Cheer.GetCheerData().ComponentRegistered:fire(Name, RootView);

	-- Return the component
	return Component;

end;

function Cheer.Bind(Source, ...)

	local Args = { ... };
	local Filters, Destination = {};

	-- Parse arguments
	if #Args == 2 then
		Filters, Destination = ...;
	elseif #Args == 1 then
		Destination = ...;
	end;

	-- Create filter chain
	local Filter = Support.ChainCall(unpack(Filters));

	-- Create destinations list
	local Destinations = (typeof(Destination) == 'table') and Destination or { Destination };

	local function CallDestination(...)

		-- Call each destination
		for _, Destination in ipairs(Destinations) do

			-- If `Destination` is a function, call it
			if typeof(Destination) == 'function' then
				Destination(Filter(...));

			-- If `Destination` is a link, update its structure
			elseif (typeof(Destination) == 'userdata') and pcall(function () return #Destination; end) then
				Destination('Update', Filter(...));

			-- If `Destination` is a TextBox, update it if not focused
			elseif (typeof(Destination) == 'Instance') and Destination:IsA 'TextBox' and not Destination:IsFocused() then
				Destination.Text = Filter(...);

			-- If `Destination` is a TextLabel, update it
			elseif (typeof(Destination) == 'Instance') and Destination:IsA 'TextLabel' then
				Destination.Text = Filter(...);

			-- If `Destination` is a value instance, update it
			elseif (typeof(Destination) == 'Instance') and Destination.ClassName:match('Value$') then
				Destination.Value = Filter(...);
			end;

		end;

	end;

	-- Create a controller for the binding
	local Binding = {};

	function Binding.Trigger()
		-- Manually triggers a source data call to the destination

		-- If `Source` is a link
		if typeof(Source == 'userdata') and pcall(function () return #Source; end) then
			CallDestination(#Source);

		-- If `Source` is a text box
		elseif (typeof(Source) == 'Instance') and Source:IsA 'TextBox' then
			CallDestination(Source.Text);

		-- If `Source` is a button
		elseif (typeof(Source) == 'Instance') and Source:IsA 'GuiButton' then
			CallDestination();

		-- If `Source` is a value instance
		elseif (typeof(Source) == 'Instance') and Source.ClassName:match('Value$') then
			CallDestination(Source.Value);
		end;

		-- Return the binding
		return Binding;

	end;

	-- If `Source` is a link
	if typeof(Source) == 'userdata' and pcall(function () return #Source; end) then

		-- Subscribe to changes in the linked data
		local Subscription = Source('Subscribe', function (Change)
			CallDestination(#Source);
		end);

		-- Provide unbind method
		Binding.Unbind = function ()
			Subscription:Unsubscribe();
		end;

	-- If `Source` is an event
	elseif (typeof(Source) == 'RBXScriptSignal') or (typeof(Source) == 'table' and Source.wait and Source.connect) then

		-- Watch for the event firing
		local Connection = Source:connect(function (...)
			CallDestination(...);
		end);

		-- Provide unbind method
		Binding.Unbind = function ()
			Connection:disconnect();
		end;

	-- If `Source` is a TextBox
	elseif (typeof(Source) == 'Instance') and Source:IsA 'TextBox' then

		-- Watch for text box submitting
		local Connection = Source.FocusLost:connect(function (EnterPressed)
			if EnterPressed then
				CallDestination(Source.Text);
			end;
		end);

		-- Provide unbind method
		Binding.Unbind = function ()
			Connection:disconnect();
		end;

	-- If `Source` is a GUI button
	elseif (typeof(Source) == 'Instance') and Source:IsA 'GuiButton' then

		-- Watch for button clicking
		local Connection = Source.MouseButton1Click:connect(function ()
			CallDestination();
		end);

		-- Provide unbind method
		Binding.Unbind = function ()
			Connection:disconnect();
		end;

	-- If `Source` is a Value instance
	elseif (typeof(Source) == 'Instance') and Source.ClassName:match('Value$') then

		-- Watch for value changing
		local Connection = Source.Changed:connect(function (Value)
			CallDestination(Value);
		end);

		-- Provide unbind method
		Binding.Unbind = function ()
			Connection:disconnect();
		end;

	end;

	-- Attempt to get the calling script
	local Script = getfenv(2).script;

	-- Disable the binding if the script is removed
	if type(Script) == 'userdata' then
		Script.AncestryChanged:connect(function (_, Parent)
			if Parent == nil then
				Binding.Unbind();
			end;
		end);
	end;

	-- Return the binding controller
	return Binding;

end;

function Cheer.Link(Structure)
	-- Returns a link to the given structure

	-- Create the link
	local Link = newproxy(true);
	local LinkMetatable = getmetatable(Link);

	-- Keep track of change subscriptions
	local LinkSubscriptions = {};
	local LinkDifferenceStream = RbxUtility.CreateSignal();

	function LinkMetatable.__index(Link, Index)
		-- Create sublinks for each requested subpath
		return Cheer.CreateSublink(Link, Index);
	end;

	function LinkMetatable.__len(Link)
		-- Return data when called with #
		return Structure; 
	end;

	local function Update(UpdatedStructure)
		-- Processes differences in structure updates and triggers subscribers

		-- Get the differences
		local Differences = Cheer.GetStructureDiff(Structure, UpdatedStructure);

		-- Set the updated structure as current
		Structure = UpdatedStructure;

		-- Trigger subscribers
		for _, Difference in ipairs(Differences) do
			LinkDifferenceStream:fire(Difference);
		end;

	end;

	local function Patch(Difference)
		-- Processes difference into structure and triggers subscribers

		-- Separate target from path
		local Path = Support.Slice(Difference.Path, 1, #Difference.Path - 1);
		local Target = Difference.Path[#Difference.Path];

		-- Patch at target point
		local Point = Link('Get', Path);
		Point[Target] = Difference.Value;

		-- Trigger subscribers
		LinkDifferenceStream:fire(Difference);

	end;

	function LinkMetatable.__call(Link, Type, ...)

		-- Return subdata from sublinks
		if Type == 'Get' then
			local Path = ...;

			-- Return `nil` if anchor structure is `nil`
			if not Structure then
				return nil;
			end;

			-- Start at the anchor structure
			local Position = Structure;

			-- Travel recursively through the structure by the given path
			for _, Index in ipairs(Path) do
				Position = Position[Index];
			end;

			-- Return the final position in the structure subdata
			return Position;

		-- Store subscription callbacks to subpaths
		elseif Type == 'Subscribe' then
			local Callback, Path = ...;
			local Path = Path or -Link;

			-- Connect and react to relevant events in difference stream
			local Connection = LinkDifferenceStream:connect(function (Difference)
				if Cheer.DoesPathMatch(Difference.Path, Path, true) then
					Callback(Difference);
				end;
			end);

			-- Create the subscription registration
			local Subscription = {
				Path = Path,
				Connection = Connection
			};

			function Subscription.Unsubscribe()
				-- Provide function to remove subscription

				-- Disable difference stream connection
				Connection:disconnect();

				-- Unregister subscription
				LinkSubscriptions[Subscription] = nil;

			end;

			-- Attempt to get the calling script
			local Script = getfenv(2).script;

			-- Disconnect the subscription if the script is removed
			if type(Script) == 'userdata' then
				Script.AncestryChanged:connect(function (_, Parent)
					if Parent == nil then
						Subscription:Unsubscribe();
					end;
				end);
			end;

			-- Add and return the subscription
			LinkSubscriptions[Subscription] = true;
			return Subscription;

		-- Return path requests
		elseif Type == 'GetPath' then
			return ...;

		-- Process update requests
		elseif Type == 'Update' then
			Update(...);

		-- Process patching requests
		elseif Type == 'Patch' then
			Patch(...);

		-- Process member iteration requests
		elseif Type == 'All' then
			local Member = ... or Link;

			-- Set initial order
			local Order = Support.Keys(#Member);
			local OrderIndex = Support.FlipTable(Order);
			local OrderModifier = nil;

			return function (Modifier, Key)
				-- Iterate or accept modifiers

				-- Apply new order modifiers
				if Modifier and Modifier.Type == 'Sort' and Modifier ~= OrderModifier then

					-- Sort values by `Modifier.Field`, based on value type
					table.sort(Order, function (A, B)

						-- Get values at keys `A` and `B`
						local A, B = #Member[A][Modifier.Field], #Member[B][Modifier.Field];

						-- Compare string values
						if type(A) == 'string' and type(B) == 'string' then
							return A:lower() < B:lower();

						-- Compare number values
						elseif type(A) == 'number' and type(B) == 'number' then
							return A < B;
						end;

					end);

					-- Reverse table order if sort is decreasing
					if Modifier.Direction == 'Decreasing' then
						Order = Support.ReverseTable(Order);
					end;

					-- Update order index
					OrderIndex = Support.FlipTable(Order);

					-- Indicate modifier has been applied
					OrderModifier = Modifier;

				end;

				-- Get or initiate current key
				local Key = not Key and Order[1] or (OrderIndex[Key] and Order[OrderIndex[Key] + 1]);

				-- Return value
				return Key, Key and (#Member[Key] and Member[Key]), Key and OrderIndex[Key];

			end;

		end;
	end;

	function LinkMetatable.__unm(Link)
		-- Returns the link's raw path
		return {};
	end;
	
	-- Return the link object
	return Link;

end;

function Cheer.CreateSublink(AnchorLink, Index)
	-- Returns a sublink for the given anchor link's index

	-- Create the sublink
	local Link = newproxy(true);
	local LinkMetatable = getmetatable(Link);

	function LinkMetatable.__index(Link, Index)
		-- Create sublinks for each requested subpath
		return Cheer.CreateSublink(Link, Index);
	end;

	function LinkMetatable.__call(Link, Type, ...)

		-- Requests data from the anchor link
		if Type == 'Get' or Type == 'GetPath' then

			local Path = ... or {};

			-- Register this sublink pass into the path
			table.insert(Path, 1, Index);

			-- Pass the built path so far to the anchor link
			return AnchorLink(Type, Path);

		-- Requests a subscription from the anchor structure
		elseif Type == 'Subscribe' then
			local Callback, Path = ...;
			return AnchorLink('Subscribe', Callback, Path or -Link)

		-- Requests a member iterator from the anchor link
		elseif Type == 'All' then
			local Member = ... or Link;
			return AnchorLink('All', Member);
		end;

	end;

	function LinkMetatable.__unm(Link)
		-- Returns the link's raw path
		return Link('GetPath');
	end;

	function LinkMetatable.__len(Link)
		-- Returns subdata from anchor structure when called with #
		return Link('Get');
	end;

	-- Return the sublink object
	return Link;

end;

function Cheer.GetStructureDiff(A, B, Path)
	-- Returns differences in structure B from A, with optional `Path` table for location-tracking

	local Differences = {};

	-- Keep track of reviewed indices in structure A
	local ReviewedIndices = {};

	-- For non-tables, compare differences directly
	if type(A) ~= 'table' or type(B) ~= 'table' then
		if A ~= B then
			table.insert(Differences, {
				Type = 'Difference',
				Path = {},
				Value = B
			});
		end;
		return Differences;
	end;

	-- Go through all indices in A
	for Index in pairs(A) do

		-- Mark the index as reviewed
		ReviewedIndices[Index] = true;

		-- Compare table differences
		if type(A[Index]) == 'table' and type(B[Index]) == 'table' then

			-- Keep track of the search path
			local Path = Path and Support.CloneTable(Path) or {};
			table.insert(Path, Index);

			-- Take note of any differences
			Support.ConcatTable(Differences, Cheer.GetStructureDiff(A[Index], B[Index], Path));

		-- Compare other differences and take note of their path
		elseif A[Index] ~= B[Index] then
			table.insert(Differences, {
				Type = 'Difference',
				Path = Support.ConcatTable(Path and Support.CloneTable(Path) or {}, { Index }),
				Value = B[Index]
			});

		end;

	end;

	-- Go through all unreviewed indices in B
	for Index in pairs(B) do
		if not ReviewedIndices[Index] then

			-- Take note of differences and their path
			table.insert(Differences, {
				Type = 'Addition',
				Path = Support.ConcatTable(Path and Support.CloneTable(Path) or {}, { Index }),
				Value = B[Index];
			});

		end;
	end;

	-- Return the differences
	return Differences;

end;

function Cheer.DoesPathMatch(Path, Test, Propagate)
	-- Returns whether the test path matches `Path`, optionally propagating up

	-- Go through the test path's indices and ensure they're in `Path` (otherwise fail)
	for Index, PathIndex in ipairs(Test) do
		if Path[Index] ~= Test[Index] then
			return false;
		end;
	end;

	-- If paths aren't of same length but match so far, pass if propagating
	if #Test ~= #Path then
		return Propagate and true or false;
	end;

	-- If it's an exact match, pass
	return true;

end;

function Cheer.Clamp(Minimum, Maximum)
	-- Returns a Cheer filter clamping the passed numbers with the given parameters

	return function (...)

		local Args = { ... };
		local FilteredArgs = {};

		for Index, Arg in ipairs(Args) do

			-- Clamp each argument
			if Arg and Minimum and Arg < Minimum then
				Arg = Minimum;
			elseif Arg and Maximum and Arg > Maximum then
				Arg = Maximum;
			end;

			-- Index the filtered argument
			FilteredArgs[Index] = Arg;

		end;

		-- Return the filtered arguments
		return unpack(FilteredArgs);

	end;

end;

function Cheer.Divide(Divisor)
	-- Returns a Cheer filter dividing the passed numbers by the given `Divisor`

	return function (...)

		local Args = { ... };
		local FilteredArgs = {};

		for Index, Arg in ipairs(Args) do

			-- Divide each argument
			Arg = Arg / Divisor;

			-- Index the filtered argument
			FilteredArgs[Index] = Arg;

		end;

		-- Return the filtered arguments
		return unpack(FilteredArgs);

	end;

end;

function Cheer.Multiply(Multiplier)
	-- Returns a Cheer filter multiplying the passed numbers by the given `Multiplier`

	return function (...)

		local Args = { ... };
		local FilteredArgs = {};

		for Index, Arg in ipairs(Args) do

			-- Multiply each argument
			Arg = Arg * Multiplier;

			-- Index the filtered argument
			FilteredArgs[Index] = Arg;

		end;

		-- Return the filtered arguments
		return unpack(FilteredArgs);

	end;

end;

function Cheer.Append(String)
	-- Returns a Cheer filter appending `String` to the passed strings

	return function (...)

		local Args = { ... };
		local FilteredArgs = {};

		for Index, Arg in ipairs(Args) do

			-- Append to each string
			Arg = Arg .. String;

			-- Index the filtered argument
			FilteredArgs[Index] = Arg;

		end;

		-- Return the filtered arguments
		return unpack(FilteredArgs);

	end;

end;

function Cheer.Round(Places)
	-- Returns a Cheer filter which rounds passed numbers to the given number of decimal places

	return function (...)

		local Args = { ... };
		local FilteredArgs = {};

		for Index, Arg in ipairs(Args) do

			-- Round each number
			Arg = Support.Round(Arg, Places);

			-- Index the filtered argument
			FilteredArgs[Index] = Arg;

		end;

		-- Return the filtered arguments
		return unpack(FilteredArgs);

	end;

end;

function Cheer.Return(...)
	-- Returns a Cheer filter which returns the given arguments

	-- Store passed args
	local Args = { ... };

	-- Return passed args when called
	return function ()
		return unpack(Args);
	end;

end;

function Cheer.ToBoolean(...)
	-- Cheer filter returning boolean equivalents of passed arguments

	local Args = { ... };

	-- Process each argument
	for Index, Arg in ipairs(Args) do

		-- Convert the argument
		Args[Index] = not (not Args);

	end;

	-- Return the filtered arguments
	return unpack(Args);

end;

function Cheer.Matches(...)
	-- Returns a Cheer filter which returns whether the passed arguments match the given arguments

	-- Store passed args
	local TargetArgs = { ... };

	-- Return match result when called
	return function (...)
		local Args = { ... };

		-- Check each argument against the target arguments
		for ArgIndex, TargetArg in ipairs(TargetArgs) do
			if Args[ArgIndex] ~= TargetArg then

				-- Return a mismatch result at first mismatch
				return false;

			end;
		end;

		-- Return a matching result if no mismatches
		return true;
	end;

end;

function Cheer.Set(Object, Member)
	-- Returns a Cheer destination which sets member `Member` of `Object` to passed value

	return function (Value)
		Object[Member] = Value;
	end;

end;

-- Provide iteration sorting modifiers
Cheer.Sorted = setmetatable({}, {

	-- Allow increasing sort modifiers
	__add = function (Self, SortingField)
		return { Type = 'Sort', Field = SortingField, Direction = 'Increasing' };
	end;

	-- Allow decreasing sort modifiers
	__sub = function (Self, SortingField)
		return { Type = 'Sort', Field = SortingField, Direction = 'Decreasing' };
	end;

});

setmetatable(Cheer, {

	-- Enable syntactic sugar for loading components
	__call = function (Cheer, ...)

		local ArgCount = #{...};

		-- Direct loading
		if ArgCount == 1 then
			return Cheer.LoadComponent(...);

		-- Template instance loading
		elseif ArgCount == 2 then
			return Cheer.FromTemplate(...);
		end;

	end;

});

return Cheer;
end;
};
G2L_MODULES[G2L["29"]] = {
Closure = function()
    local script = G2L["29"];SupportLibrary = {};

function SupportLibrary.FindTableOccurrences(Haystack, Needle)
	-- Returns the positions of instances of `needle` in table `haystack`

	local Positions = {};

	-- Add any indexes from `Haystack` that are `Needle`
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			table.insert(Positions, Index);
		end;
	end;

	return Positions;
end;

function SupportLibrary.FindTableOccurrence(Haystack, Needle)
	-- Returns one occurrence of `Needle` in `Haystack`

	-- Search for the first instance of `Needle` found and return it
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			return Index;
		end;
	end;

	-- If no occurrences exist, return `nil`
	return nil;

end;

function SupportLibrary.IsInTable(Haystack, Needle)
	-- Returns whether the given `Needle` can be found within table `Haystack`

	-- Go through every value in `Haystack` and return whether `Needle` is found
	for _, Value in pairs(Haystack) do
		if Value == Needle then
			return true;
		end;
	end;

	-- If no instances were found, return false
	return false;
end;

function SupportLibrary.DoTablesMatch(A, B)
	-- Returns whether the values of tables A and B are the same

	-- Check B table differences
	for Index in pairs(A) do
		if A[Index] ~= B[Index] then
			return false;
		end;
	end;

	-- Check A table differences
	for Index in pairs(B) do
		if B[Index] ~= A[Index] then
			return false;
		end;
	end;

	-- Return true if no differences
	return true;
end;

function SupportLibrary.Round(Number, Places)
	-- Returns `Number` rounded to the given number of decimal places (from lua-users)

	-- Ensure that `Number` is a number
	if type(Number) ~= 'number' then
		return;
	end;

	-- Round the number
	local Multiplier = 10 ^ (Places or 0);
	local RoundedNumber = math.floor(Number * Multiplier + 0.5) / Multiplier;

	-- Return the rounded number
	return RoundedNumber;
end;

function SupportLibrary.CloneTable(Table)
	-- Returns a copy of `Table`

	local ClonedTable = {};

	-- Copy all values into `ClonedTable`
	for Key, Value in pairs(Table) do
		ClonedTable[Key] = Value;
	end;

	-- Return the clone
	return ClonedTable;
end;

function SupportLibrary.GetAllDescendants(Parent)
	-- Recursively gets all the descendants of `Parent` and returns them

	local Descendants = {};

	for _, Child in pairs(Parent:GetChildren()) do

		-- Add the direct descendants of `Parent`
		table.insert(Descendants, Child);

		-- Add the descendants of each child
		for _, Subchild in pairs(SupportLibrary.GetAllDescendants(Child)) do
			table.insert(Descendants, Subchild);
		end;

	end;

	return Descendants;
end;

function SupportLibrary.GetDescendantCount(Parent)
	-- Recursively gets a count of all the descendants of `Parent` and returns them

	local Count = 0;

	for _, Child in pairs(Parent:GetChildren()) do

		-- Count the direct descendants of `Parent`
		Count = Count + 1;

		-- Count and add the descendants of each child
		Count = Count + SupportLibrary.GetDescendantCount(Child);

	end;

	return Count;
end;

function SupportLibrary.CloneParts(Parts)
	-- Returns a table of cloned `Parts`

	local Clones = {};

	-- Copy the parts into `Clones`
	for Index, Part in pairs(Parts) do
		Clones[Index] = Part:Clone();
	end;

	return Clones;
end;

function SupportLibrary.SplitString(String, Delimiter)
	-- Returns a table of string `String` split by pattern `Delimiter`

	local StringParts = {};
	local Pattern = ('([^%s]+)'):format(Delimiter);

	-- Capture each separated part
	String:gsub(Pattern, function (Part)
		table.insert(StringParts, Part);
	end);

	return StringParts;
end;

function SupportLibrary.GetChildOfClass(Parent, ClassName, Inherit)
	-- Returns the first child of `Parent` that is of class `ClassName`
	-- or nil if it couldn't find any

	-- Look for a child of `Parent` of class `ClassName` and return it
	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				return Child;
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				return Child;
			end;
		end;
	end;

	return nil;
end;

function SupportLibrary.GetChildrenOfClass(Parent, ClassName, Inherit)
	-- Returns a table containing the children of `Parent` that are
	-- of class `ClassName`

	local Matches = {};

	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				table.insert(Matches, Child);
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				table.insert(Matches, Child);
			end;
		end;
	end;

	return Matches;
end;

function SupportLibrary.HSVToRGB(Hue, Saturation, Value)
	-- Returns the RGB equivalent of the given HSV-defined color
	-- (adapted from some code found around the web)

	-- If it's achromatic, just return the value
	if Saturation == 0 then
		return Value;
	end;

	-- Get the hue sector
	local HueSector = math.floor(Hue / 60);
	local HueSectorOffset = (Hue / 60) - HueSector;

	local P = Value * (1 - Saturation);
	local Q = Value * (1 - Saturation * HueSectorOffset);
	local T = Value * (1 - Saturation * (1 - HueSectorOffset));

	if HueSector == 0 then
		return Value, T, P;
	elseif HueSector == 1 then
		return Q, Value, P;
	elseif HueSector == 2 then
		return P, Value, T;
	elseif HueSector == 3 then
		return P, Q, Value;
	elseif HueSector == 4 then
		return T, P, Value;
	elseif HueSector == 5 then
		return Value, P, Q;
	end;
end;

function SupportLibrary.RGBToHSV(Red, Green, Blue)
	-- Returns the HSV equivalent of the given RGB-defined color
	-- (adapted from some code found around the web)

	local Hue, Saturation, Value;

	local MinValue = math.min(Red, Green, Blue);
	local MaxValue = math.max(Red, Green, Blue);

	Value = MaxValue;

	local ValueDelta = MaxValue - MinValue;

	-- If the color is not black
	if MaxValue ~= 0 then
		Saturation = ValueDelta / MaxValue;

	-- If the color is purely black
	else
		Saturation = 0;
		Hue = -1;
		return Hue, Saturation, Value;
	end;

	if Red == MaxValue then
		Hue = (Green - Blue) / ValueDelta;
	elseif Green == MaxValue then
		Hue = 2 + (Blue - Red) / ValueDelta;
	else
		Hue = 4 + (Red - Green) / ValueDelta;
	end;

	Hue = Hue * 60;
	if Hue < 0 then
		Hue = Hue + 360;
	end;

	return Hue, Saturation, Value;
end;

function SupportLibrary.IdentifyCommonItem(Items)
	-- Returns the common item in table `Items`, or `nil` if
	-- they vary

	local CommonItem = nil;

	for ItemIndex, Item in pairs(Items) do

		-- Set the initial item to compare against
		if ItemIndex == 1 then
			CommonItem = Item;

		-- Check if this item is the same as the rest
		else
			-- If it isn't the same, there is no common item, so just stop right here
			if Item ~= CommonItem then
				return nil;
			end;
		end;

	end;

	-- Return the common item
	return CommonItem;
end;

function SupportLibrary.IdentifyCommonProperty(Items, Property)
	-- Returns the common `Property` value in the instances given in `Items`

	local PropertyVariations = {};

	-- Capture all the variations of the property value
	for _, Item in pairs(Items) do
		table.insert(PropertyVariations, Item[Property]);
	end;

	-- Return the common property value
	return SupportLibrary.IdentifyCommonItem(PropertyVariations);

end;

function SupportLibrary.CreateSignal()
	-- Returns a ROBLOX-like signal for connections (RbxUtility's is buggy)

	local Signal = {
		Connections	= {};

		-- Provide a function to connect an event handler
		Connect = function (Signal, Handler)

			-- Register the handler
			table.insert(Signal.Connections, Handler);

			-- Return a controller for this connection
			local ConnectionController = {

				-- Include a reference to the connection's handler
				Handler = Handler;

				-- Provide a way to disconnect this connection
				Disconnect = function (Connection)
					local ConnectionSearch = SupportLibrary.FindTableOccurrences(Signal.Connections, Connection.Handler);
					if #ConnectionSearch > 0 then
						local ConnectionIndex = ConnectionSearch[1];
						table.remove(Signal.Connections, ConnectionIndex);
					end;
				end;

			};

			-- Add compatibility aliases
			ConnectionController.disconnect = ConnectionController.Disconnect;

			-- Return the connection's controller
			return ConnectionController;

		end;

		-- Provide a function to trigger any connections' handlers
		Fire = function (Signal, ...)
			for _, Connection in pairs(Signal.Connections) do
				Connection(...);
			end;
		end;
	};

	-- Add compatibility aliases
	Signal.connect	= Signal.Connect;
	Signal.fire		= Signal.Fire;

	return Signal;
end;

function SupportLibrary.GetPartCorners(Part)
	-- Returns a table of the given part's corners' CFrames

	-- Make references to functions called a lot for efficiency
	local Insert = table.insert;
	local ToWorldSpace = CFrame.new().toWorldSpace;
	local NewCFrame = CFrame.new;

	-- Get info about the part
	local PartCFrame = Part.CFrame;
	local SizeX, SizeY, SizeZ = Part.Size.x / 2, Part.Size.y / 2, Part.Size.z / 2;

	-- Get each corner
	local Corners = {};
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, -SizeZ)));

	return Corners;
end;

function SupportLibrary.CreatePart(PartType)
	-- Creates and returns new part based on `PartType` with sensible defaults

	local NewPart;

	if PartType == 'Normal' then
		NewPart = Instance.new('Part');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Truss' then
		NewPart = Instance.new('TrussPart');

	elseif PartType == 'Wedge' then
		NewPart = Instance.new('WedgePart');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Corner' then
		NewPart = Instance.new('CornerWedgePart');

	elseif PartType == 'Cylinder' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Cylinder';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;
		NewPart.Size = Vector3.new(2, 2, 2);

	elseif PartType == 'Ball' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Ball';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;

	elseif PartType == 'Seat' then
		NewPart = Instance.new('Seat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Vehicle Seat' then
		NewPart = Instance.new('VehicleSeat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Spawn' then
		NewPart = Instance.new('SpawnLocation');
		NewPart.Size = Vector3.new(4, 1, 2);
	end;
	
	-- Make sure the part is anchored
	NewPart.Anchored = true;

	return NewPart;
end;

function SupportLibrary.ImportServices()
	-- Adds references to common services into the calling environment

	-- Get the calling environment
	local CallingEnvironment = getfenv(2);

	-- Add the services
	CallingEnvironment.Workspace = Game:GetService 'Workspace';
	CallingEnvironment.Players = Game:GetService 'Players';
	CallingEnvironment.MarketplaceService = Game:GetService 'MarketplaceService';
	CallingEnvironment.ContentProvider = Game:GetService 'ContentProvider';
	CallingEnvironment.SoundService = Game:GetService 'SoundService';
	CallingEnvironment.UserInputService = Game:GetService 'UserInputService';
	CallingEnvironment.SelectionService = Game:GetService 'Selection';
	CallingEnvironment.CoreGui = Game:GetService 'CoreGui';
	CallingEnvironment.HttpService = Game:GetService 'HttpService';
	CallingEnvironment.ChangeHistoryService = Game:GetService 'ChangeHistoryService';
	CallingEnvironment.ReplicatedStorage = Game:GetService 'ReplicatedStorage';
	CallingEnvironment.GroupService = Game:GetService 'GroupService';
	CallingEnvironment.ServerScriptService = Game:GetService 'ServerScriptService';
	CallingEnvironment.ServerStorage = Game:GetService 'ServerStorage';
	CallingEnvironment.StarterGui = Game:GetService 'StarterGui';
	CallingEnvironment.RunService = Game:GetService 'RunService';
end;

function SupportLibrary.GetListMembers(List, MemberName)
	-- Gets the given member for each object in the given list table

	local Members = {};

	-- Collect the member values for each item in the list
	for _, Item in pairs(List) do
		table.insert(Members, Item[MemberName]);
	end;

	-- Return the members
	return Members;

end;

function SupportLibrary.AddUserInputListener(InputState, InputType, CatchAll, Callback)
	-- Connects to the given user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Game:GetService('UserInputService')['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Make sure any key input did not occur while typing into a UI
		if InputType == Enum.UserInputType.Keyboard and Game:GetService('UserInputService'):GetFocusedTextBox() then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AddGuiInputListener(Gui, InputState, InputType, CatchAll, Callback)
	-- Connects to the given GUI user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Gui['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AreKeysPressed(...)
	-- Returns whether the given keys are pressed

	local RequestedKeysPressed = 0;

	-- Get currently pressed keys
	local PressedKeys = SupportLibrary.GetListMembers(Game:GetService('UserInputService'):GetKeysPressed(), 'KeyCode');

	-- Go through each requested key
	for _, Key in pairs({ ... }) do

		-- Count requested keys that are pressed
		if SupportLibrary.IsInTable(PressedKeys, Key) then
			RequestedKeysPressed = RequestedKeysPressed + 1;
		end;

	end;

	-- Return whether all the requested keys are pressed or not
	return RequestedKeysPressed == #{...};

end;

function SupportLibrary.ConcatTable(DestinationTable, SourceTable)
	-- Inserts all values of SourceTable into DestinationTable

	-- Add each value from `SourceTable` into `DestinationTable`
	for _, Value in ipairs(SourceTable) do
		table.insert(DestinationTable, Value);
	end;

	-- Return the destination table
	return DestinationTable;
end;

function SupportLibrary.ClearTable(Table)
	-- Clears out every value in `Table`

	-- Clear each index
	for Index in pairs(Table) do
		Table[Index] = nil;
	end;

	-- Return the given table
	return Table;
end;

function SupportLibrary.Values(Table)
	-- Returns all the values in the given table

	local Values = {};

	-- Go through each key and get each value
	for _, Value in pairs(Table) do
		table.insert(Values, Value);
	end;

	-- Return the values
	return Values;
end;

function SupportLibrary.Keys(Table)
	-- Returns all the keys in the given table

	local Keys = {};

	-- Go through each key and get each value
	for Key in pairs(Table) do
		table.insert(Keys, Key);
	end;

	-- Return the values
	return Keys;
end;

function SupportLibrary.Call(Function, ...)
	-- Returns a callback to `Function` with the given arguments
	local Args = { ... };
	return function (...)
		return Function(unpack(
			SupportLibrary.ConcatTable(SupportLibrary.CloneTable(Args), { ... })
		));
	end;
end;

function SupportLibrary.Trim(String)
	-- Returns a trimmed version of `String` (adapted from code from lua-users)
	return (String:gsub("^%s*(.-)%s*$", "%1"));
end

function SupportLibrary.ChainCall(...)
	-- Returns function that passes arguments through given functions and returns the final result

	-- Get the given chain of functions
	local Chain = { ... };

	-- Return the chaining function
	return function (...)

		-- Get arguments
		local Arguments = { ... };

		-- Go through each function and store the returned data to reuse in the next function's arguments 
		for _, Function in ipairs(Chain) do
			Arguments = { Function(unpack(Arguments)) };
		end;

		-- Return the final returned data
		return unpack(Arguments);

	end;

end;

function SupportLibrary.CountKeys(Table)
	-- Returns the number of keys in `Table`

	local Count = 0;

	-- Count each key
	for _ in pairs(Table) do
		Count = Count + 1;
	end;

	-- Return the count
	return Count;

end;

function SupportLibrary.Slice(Table, Start, End)
	-- Returns values from `Start` to `End` in `Table`

	local Slice = {};

	-- Go through the given indices
	for Index = Start, End do
		table.insert(Slice, Table[Index]);
	end;

	-- Return the slice
	return Slice;

end;

function SupportLibrary.FlipTable(Table)
	-- Returns a table with keys and values in `Table` swapped

	local FlippedTable = {};

	-- Flip each key and value
	for Key, Value in pairs(Table) do
		FlippedTable[Value] = Key;
	end;

	-- Return the flipped table
	return FlippedTable;

end;

function SupportLibrary.ScheduleRecurringTask(TaskFunction, Interval)
	-- Repeats `Task` every `Interval` seconds until stopped

	-- Create a task object
	local Task = {

		-- A switch determining if it's running or not
		Running = true;

		-- A function to stop this task
		Stop = function (Task)
			Task.Running = false;
		end;

		-- References to the task function and set interval
		TaskFunction = TaskFunction;
		Interval = Interval;

	};

	coroutine.wrap(function (Task)

		-- Repeat the task
		while wait(Task.Interval) and Task.Running do
			Task.TaskFunction();
		end;

	end)(Task);

	-- Return the task object
	return Task;

end;

function SupportLibrary.Clamp(Number, Minimum, Maximum)
	-- Returns the given number, clamped according to the provided min/max

	-- Clamp the number
	if Minimum and Number < Minimum then
		Number = Minimum;
	elseif Maximum and Number > Maximum then
		Number = Maximum;
	end;

	-- Return the clamped number
	return Number;

end;

function SupportLibrary.ReverseTable(Table)
	-- Returns a new table with values in the opposite order

	local ReversedTable = {};

	-- Copy each value at the opposite key
	for Index, Value in ipairs(Table) do
		ReversedTable[#Table - Index + 1] = Value;
	end;

	-- Return the reversed table
	return ReversedTable;

end;

return SupportLibrary;
end;
};
G2L_MODULES[G2L["2a"]] = {
Closure = function()
    local script = G2L["2a"];return {
	Name = 'Cheer',
	Creator = 'F3X',
	Version = {
		Major = 0,
		Minor = 0,
		Patch = 1
	}
}
end;
};
G2L_MODULES[G2L["2b"]] = {
Closure = function()
    local script = G2L["2b"];local Support = require(script.SupportLibrary);

function Try(Function, ...)

	-- Capture function execution response
	local Data = { pcall(Function, ...) };

	-- Determine whether execution succeeded or failed
	local Success = Data[1];
	
	-- Gather arguments to return from data
	local Arguments = { unpack(Data, 2) };

	-- Return attempt for chaining
	return setmetatable({
		_IsAttempt = true,
		Then = Then,
		Catch = Catch,
		Retry = Retry,
		Success = Success,
		Arguments = Arguments,
		Stack = debug.traceback(),
		LastArguments = { ... },
		Hops = (not Success) and { Function } or nil,
		RetryCount = 0,
		Start = true

	-- Indicate type when converted to string (to aid in debugging)
	}, { __tostring = function () return 'Attempt' end })

end;

function Then(Attempt, Callback)

	-- Update attempt state
	Attempt.Start = false;

	-- Enter new attempt contexts if received
	local FirstArgument = Attempt.Arguments[1];
	if Attempt.Success and type(FirstArgument) == 'table' and FirstArgument._IsAttempt then
		Attempt = FirstArgument;
	end;

	-- Skip processing if attempt failed
	if not Attempt.Success then
		table.insert(Attempt.Hops, Callback);
		return Attempt;
	end;

	-- Capture callback execution response
	local Data = { pcall(Callback, unpack(Attempt.Arguments)) };
	local Success = Data[1];
	local Arguments = { unpack(Data, 2) };

	-- Replace attempt state
	Attempt.Success = Success;
	Attempt.LastArguments = Attempt.Arguments;
	Attempt.Arguments = Arguments;
	Attempt.Stack = debug.traceback();

	-- Track hops on failure
	if not Success then
		Attempt.Hops = { Callback };
	end

	-- Return attempt for chaining
	return Attempt;

end;

function Catch(Attempt, ...)

	-- Capture all arguments
	local Arguments = { ... };

	-- Get target errors and the callback
	local TargetErrors = { unpack(Arguments, 1, #Arguments - 1) };
	local Callback = unpack(Arguments, #Arguments);

	-- Enter new attempt contexts if received
	local FirstArgument = Attempt.Arguments[1];
	if type(FirstArgument) == 'table' and FirstArgument._IsAttempt then
		Attempt = FirstArgument;
	end;

	-- Proceed upon unhandled failure
	if not Attempt.Success and not Attempt.Handled then

		-- Track hops
		table.insert(Attempt.Hops, Arguments);

		-- Get error from failed attempt
		local Error = Attempt.Arguments[1];

		-- Filter errors if target errors were specified
		if (#TargetErrors > 0) then
			for _, TargetError in pairs(TargetErrors) do
				if type(Error) == 'string' and Error:match(TargetError) then
					Attempt.Handled = true;
					return Try(Callback, Error, Attempt.Stack, Attempt);
				end;
			end;

		-- Pass any error if no target errors were specified
		elseif #TargetErrors == 0 then
			Attempt.Handled = true;
			return Try(Callback, Error, Attempt.Stack, Attempt);
		end;

	end;

	-- Return attempt for chaining
	return Attempt;

end;

function Retry(Attempt)

	-- Ensure attempt failed
	if Attempt.Success then
		return;
	end;

	-- Get hops and arguments
	local Hops = Attempt.Hops;
	local Arguments = Attempt.LastArguments;

	-- Reset attempt state
	Attempt.Hops = nil;
	Attempt.Success = true;
	Attempt.Arguments = Arguments;
	Attempt.Handled = nil;
	Attempt.RetryCount = Attempt.RetryCount and (Attempt.RetryCount + 1) or 1;

	-- Restart attempts that failed from the start
	if Attempt.Start then
		local NewAttempt = Try(Hops[1], Arguments);

		-- Reset retry counter if reattempt succeeds
		if NewAttempt.Success then
			NewAttempt.RetryCount = 0;
		else
			NewAttempt.RetryCount = Attempt.RetryCount;
		end;

		-- Apply each hop
		for HopIndex, Hop in ipairs(Hops) do
			if HopIndex > 1 then

				-- Apply `then` hops
				if type(Hop) == 'function' then
					NewAttempt:Then(Hop);
					
				-- Apply `catch` hops
				elseif type(Hop) == 'table' then
					NewAttempt:Catch(unpack(Hop));
				end;

			end;
		end;
		
		-- Return the new attempt
		return NewAttempt;
	
	-- Continue attempts that failed after the start
	else
		for HopIndex, Hop in ipairs(Hops) do

			-- Apply `then` hoops
			if type(Hop) == 'function' then
				Attempt:Then(Hop);

			-- Apply `catch` hops
			elseif type(Hop) == 'table' then
				Attempt:Catch(unpack(Hop));
			end;
			
			-- Reset retry counter if reattempt succeeds
			if HopIndex == 1 and Attempt.Success then
				Attempt.RetryCount = 0;
			end;

		end;

		-- Return the attempt
		return Attempt;
	end;

end;

return Try;
end;
};
G2L_MODULES[G2L["2c"]] = {
Closure = function()
    local script = G2L["2c"];SupportLibrary = {};

function SupportLibrary.FindTableOccurrences(Haystack, Needle)
	-- Returns the positions of instances of `needle` in table `haystack`

	local Positions = {};

	-- Add any indexes from `Haystack` that are `Needle`
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			table.insert(Positions, Index);
		end;
	end;

	return Positions;
end;

function SupportLibrary.FindTableOccurrence(Haystack, Needle)
	-- Returns one occurrence of `Needle` in `Haystack`

	-- Search for the first instance of `Needle` found and return it
	for Index, Value in pairs(Haystack) do
		if Value == Needle then
			return Index;
		end;
	end;

	-- If no occurrences exist, return `nil`
	return nil;

end;

function SupportLibrary.IsInTable(Haystack, Needle)
	-- Returns whether the given `Needle` can be found within table `Haystack`

	-- Go through every value in `Haystack` and return whether `Needle` is found
	for _, Value in pairs(Haystack) do
		if Value == Needle then
			return true;
		end;
	end;

	-- If no instances were found, return false
	return false;
end;

function SupportLibrary.DoTablesMatch(A, B)
	-- Returns whether the values of tables A and B are the same

	-- Check B table differences
	for Index in pairs(A) do
		if A[Index] ~= B[Index] then
			return false;
		end;
	end;

	-- Check A table differences
	for Index in pairs(B) do
		if B[Index] ~= A[Index] then
			return false;
		end;
	end;

	-- Return true if no differences
	return true;
end;

function SupportLibrary.Round(Number, Places)
	-- Returns `Number` rounded to the given number of decimal places (from lua-users)

	-- Ensure that `Number` is a number
	if type(Number) ~= 'number' then
		return;
	end;

	-- Round the number
	local Multiplier = 10 ^ (Places or 0);
	local RoundedNumber = math.floor(Number * Multiplier + 0.5) / Multiplier;

	-- Return the rounded number
	return RoundedNumber;
end;

function SupportLibrary.CloneTable(Table)
	-- Returns a copy of `Table`

	local ClonedTable = {};

	-- Copy all values into `ClonedTable`
	for Key, Value in pairs(Table) do
		ClonedTable[Key] = Value;
	end;

	-- Return the clone
	return ClonedTable;
end;

function SupportLibrary.GetAllDescendants(Parent)
	-- Recursively gets all the descendants of `Parent` and returns them

	local Descendants = {};

	for _, Child in pairs(Parent:GetChildren()) do

		-- Add the direct descendants of `Parent`
		table.insert(Descendants, Child);

		-- Add the descendants of each child
		for _, Subchild in pairs(SupportLibrary.GetAllDescendants(Child)) do
			table.insert(Descendants, Subchild);
		end;

	end;

	return Descendants;
end;

function SupportLibrary.GetDescendantCount(Parent)
	-- Recursively gets a count of all the descendants of `Parent` and returns them

	local Count = 0;

	for _, Child in pairs(Parent:GetChildren()) do

		-- Count the direct descendants of `Parent`
		Count = Count + 1;

		-- Count and add the descendants of each child
		Count = Count + SupportLibrary.GetDescendantCount(Child);

	end;

	return Count;
end;

function SupportLibrary.CloneParts(Parts)
	-- Returns a table of cloned `Parts`

	local Clones = {};

	-- Copy the parts into `Clones`
	for Index, Part in pairs(Parts) do
		Clones[Index] = Part:Clone();
	end;

	return Clones;
end;

function SupportLibrary.SplitString(String, Delimiter)
	-- Returns a table of string `String` split by pattern `Delimiter`

	local StringParts = {};
	local Pattern = ('([^%s]+)'):format(Delimiter);

	-- Capture each separated part
	String:gsub(Pattern, function (Part)
		table.insert(StringParts, Part);
	end);

	return StringParts;
end;

function SupportLibrary.GetChildOfClass(Parent, ClassName, Inherit)
	-- Returns the first child of `Parent` that is of class `ClassName`
	-- or nil if it couldn't find any

	-- Look for a child of `Parent` of class `ClassName` and return it
	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				return Child;
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				return Child;
			end;
		end;
	end;

	return nil;
end;

function SupportLibrary.GetChildrenOfClass(Parent, ClassName, Inherit)
	-- Returns a table containing the children of `Parent` that are
	-- of class `ClassName`

	local Matches = {};

	if not Inherit then
		for _, Child in pairs(Parent:GetChildren()) do
			if Child.ClassName == ClassName then
				table.insert(Matches, Child);
			end;
		end;
	else
		for _, Child in pairs(Parent:GetChildren()) do
			if Child:IsA(ClassName) then
				table.insert(Matches, Child);
			end;
		end;
	end;

	return Matches;
end;

function SupportLibrary.HSVToRGB(Hue, Saturation, Value)
	-- Returns the RGB equivalent of the given HSV-defined color
	-- (adapted from some code found around the web)

	-- If it's achromatic, just return the value
	if Saturation == 0 then
		return Value;
	end;

	-- Get the hue sector
	local HueSector = math.floor(Hue / 60);
	local HueSectorOffset = (Hue / 60) - HueSector;

	local P = Value * (1 - Saturation);
	local Q = Value * (1 - Saturation * HueSectorOffset);
	local T = Value * (1 - Saturation * (1 - HueSectorOffset));

	if HueSector == 0 then
		return Value, T, P;
	elseif HueSector == 1 then
		return Q, Value, P;
	elseif HueSector == 2 then
		return P, Value, T;
	elseif HueSector == 3 then
		return P, Q, Value;
	elseif HueSector == 4 then
		return T, P, Value;
	elseif HueSector == 5 then
		return Value, P, Q;
	end;
end;

function SupportLibrary.RGBToHSV(Red, Green, Blue)
	-- Returns the HSV equivalent of the given RGB-defined color
	-- (adapted from some code found around the web)

	local Hue, Saturation, Value;

	local MinValue = math.min(Red, Green, Blue);
	local MaxValue = math.max(Red, Green, Blue);

	Value = MaxValue;

	local ValueDelta = MaxValue - MinValue;

	-- If the color is not black
	if MaxValue ~= 0 then
		Saturation = ValueDelta / MaxValue;

	-- If the color is purely black
	else
		Saturation = 0;
		Hue = -1;
		return Hue, Saturation, Value;
	end;

	if Red == MaxValue then
		Hue = (Green - Blue) / ValueDelta;
	elseif Green == MaxValue then
		Hue = 2 + (Blue - Red) / ValueDelta;
	else
		Hue = 4 + (Red - Green) / ValueDelta;
	end;

	Hue = Hue * 60;
	if Hue < 0 then
		Hue = Hue + 360;
	end;

	return Hue, Saturation, Value;
end;

function SupportLibrary.IdentifyCommonItem(Items)
	-- Returns the common item in table `Items`, or `nil` if
	-- they vary

	local CommonItem = nil;

	for ItemIndex, Item in pairs(Items) do

		-- Set the initial item to compare against
		if ItemIndex == 1 then
			CommonItem = Item;

		-- Check if this item is the same as the rest
		else
			-- If it isn't the same, there is no common item, so just stop right here
			if Item ~= CommonItem then
				return nil;
			end;
		end;

	end;

	-- Return the common item
	return CommonItem;
end;

function SupportLibrary.IdentifyCommonProperty(Items, Property)
	-- Returns the common `Property` value in the instances given in `Items`

	local PropertyVariations = {};

	-- Capture all the variations of the property value
	for _, Item in pairs(Items) do
		table.insert(PropertyVariations, Item[Property]);
	end;

	-- Return the common property value
	return SupportLibrary.IdentifyCommonItem(PropertyVariations);

end;

function SupportLibrary.CreateSignal()
	-- Returns a ROBLOX-like signal for connections (RbxUtility's is buggy)

	local Signal = {
		Connections	= {};

		-- Provide a function to connect an event handler
		Connect = function (Signal, Handler)

			-- Register the handler
			table.insert(Signal.Connections, Handler);

			-- Return a controller for this connection
			local ConnectionController = {

				-- Include a reference to the connection's handler
				Handler = Handler;

				-- Provide a way to disconnect this connection
				Disconnect = function (Connection)
					local ConnectionSearch = SupportLibrary.FindTableOccurrences(Signal.Connections, Connection.Handler);
					if #ConnectionSearch > 0 then
						local ConnectionIndex = ConnectionSearch[1];
						table.remove(Signal.Connections, ConnectionIndex);
					end;
				end;

			};

			-- Add compatibility aliases
			ConnectionController.disconnect = ConnectionController.Disconnect;

			-- Return the connection's controller
			return ConnectionController;

		end;

		-- Provide a function to trigger any connections' handlers
		Fire = function (Signal, ...)
			for _, Connection in pairs(Signal.Connections) do
				Connection(...);
			end;
		end;
	};

	-- Add compatibility aliases
	Signal.connect	= Signal.Connect;
	Signal.fire		= Signal.Fire;

	return Signal;
end;

function SupportLibrary.GetPartCorners(Part)
	-- Returns a table of the given part's corners' CFrames

	-- Make references to functions called a lot for efficiency
	local Insert = table.insert;
	local ToWorldSpace = CFrame.new().toWorldSpace;
	local NewCFrame = CFrame.new;

	-- Get info about the part
	local PartCFrame = Part.CFrame;
	local SizeX, SizeY, SizeZ = Part.Size.x / 2, Part.Size.y / 2, Part.Size.z / 2;

	-- Get each corner
	local Corners = {};
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(SizeX, -SizeY, -SizeZ)));
	Insert(Corners, ToWorldSpace(PartCFrame, NewCFrame(-SizeX, -SizeY, -SizeZ)));

	return Corners;
end;

function SupportLibrary.CreatePart(PartType)
	-- Creates and returns new part based on `PartType` with sensible defaults

	local NewPart;

	if PartType == 'Normal' then
		NewPart = Instance.new('Part');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Truss' then
		NewPart = Instance.new('TrussPart');

	elseif PartType == 'Wedge' then
		NewPart = Instance.new('WedgePart');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Corner' then
		NewPart = Instance.new('CornerWedgePart');

	elseif PartType == 'Cylinder' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Cylinder';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;
		NewPart.Size = Vector3.new(2, 2, 2);

	elseif PartType == 'Ball' then
		NewPart = Instance.new('Part');
		NewPart.Shape = 'Ball';
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;

	elseif PartType == 'Seat' then
		NewPart = Instance.new('Seat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Vehicle Seat' then
		NewPart = Instance.new('VehicleSeat');
		NewPart.Size = Vector3.new(4, 1, 2);

	elseif PartType == 'Spawn' then
		NewPart = Instance.new('SpawnLocation');
		NewPart.Size = Vector3.new(4, 1, 2);
	end;
	
	-- Make sure the part is anchored
	NewPart.Anchored = true;

	return NewPart;
end;

function SupportLibrary.ImportServices()
	-- Adds references to common services into the calling environment

	-- Get the calling environment
	local CallingEnvironment = getfenv(2);

	-- Add the services
	CallingEnvironment.Workspace = Game:GetService 'Workspace';
	CallingEnvironment.Players = Game:GetService 'Players';
	CallingEnvironment.MarketplaceService = Game:GetService 'MarketplaceService';
	CallingEnvironment.ContentProvider = Game:GetService 'ContentProvider';
	CallingEnvironment.SoundService = Game:GetService 'SoundService';
	CallingEnvironment.UserInputService = Game:GetService 'UserInputService';
	CallingEnvironment.SelectionService = Game:GetService 'Selection';
	CallingEnvironment.CoreGui = Game:GetService 'CoreGui';
	CallingEnvironment.HttpService = Game:GetService 'HttpService';
	CallingEnvironment.ChangeHistoryService = Game:GetService 'ChangeHistoryService';
	CallingEnvironment.ReplicatedStorage = Game:GetService 'ReplicatedStorage';
	CallingEnvironment.GroupService = Game:GetService 'GroupService';
	CallingEnvironment.ServerScriptService = Game:GetService 'ServerScriptService';
	CallingEnvironment.StarterGui = Game:GetService 'StarterGui';
	CallingEnvironment.RunService = Game:GetService 'RunService';
end;

function SupportLibrary.GetListMembers(List, MemberName)
	-- Gets the given member for each object in the given list table

	local Members = {};

	-- Collect the member values for each item in the list
	for _, Item in pairs(List) do
		table.insert(Members, Item[MemberName]);
	end;

	-- Return the members
	return Members;

end;

function SupportLibrary.AddUserInputListener(InputState, InputType, CatchAll, Callback)
	-- Connects to the given user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Game:GetService('UserInputService')['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Make sure any key input did not occur while typing into a UI
		if InputType == Enum.UserInputType.Keyboard and Game:GetService('UserInputService'):GetFocusedTextBox() then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AddGuiInputListener(Gui, InputState, InputType, CatchAll, Callback)
	-- Connects to the given GUI user input event and takes care of standard boilerplate code

	-- Turn the given `InputType` string into a proper enum
	local InputType = Enum.UserInputType[InputType];

	-- Create a UserInputService listener based on the given `InputState`
	return Gui['Input' .. InputState]:connect(function (Input, GameProcessedEvent)

		-- Make sure this input was not captured by the client (unless `CatchAll` is enabled)
		if GameProcessedEvent and not CatchAll then
			return;
		end;

		-- Make sure this is the right input type
		if Input.UserInputType ~= InputType then
			return;
		end;

		-- Call back upon passing all conditions
		Callback(Input);

	end);

end;

function SupportLibrary.AreKeysPressed(...)
	-- Returns whether the given keys are pressed

	local RequestedKeysPressed = 0;

	-- Get currently pressed keys
	local PressedKeys = SupportLibrary.GetListMembers(Game:GetService('UserInputService'):GetKeysPressed(), 'KeyCode');

	-- Go through each requested key
	for _, Key in pairs({ ... }) do

		-- Count requested keys that are pressed
		if SupportLibrary.IsInTable(PressedKeys, Key) then
			RequestedKeysPressed = RequestedKeysPressed + 1;
		end;

	end;

	-- Return whether all the requested keys are pressed or not
	return RequestedKeysPressed == #{...};

end;

function SupportLibrary.ConcatTable(DestinationTable, SourceTable)
	-- Inserts all values of SourceTable into DestinationTable

	-- Add each value from `SourceTable` into `DestinationTable`
	for _, Value in pairs(SourceTable) do
		table.insert(DestinationTable, Value);
	end;

	-- Return the destination table
	return DestinationTable;
end;

function SupportLibrary.ClearTable(Table)
	-- Clears out every value in `Table`

	-- Clear each index
	for Index in pairs(Table) do
		Table[Index] = nil;
	end;

	-- Return the given table
	return Table;
end;

function SupportLibrary.Values(Table)
	-- Returns all the values in the given table

	local Values = {};

	-- Go through each key and get each value
	for _, Value in pairs(Table) do
		table.insert(Values, Value);
	end;

	-- Return the values
	return Values;
end;

function SupportLibrary.Keys(Table)
	-- Returns all the keys in the given table

	local Keys = {};

	-- Go through each key and get each value
	for Key in pairs(Table) do
		table.insert(Keys, Key);
	end;

	-- Return the values
	return Keys;
end;

function SupportLibrary.Call(Function, ...)
	-- Returns a callback to `Function` with the given arguments
	local Args = { ... };
	return function (...)
		Function(unpack(
			SupportLibrary.ConcatTable(SupportLibrary.CloneTable(Args), { ... })
		));
	end;
end;

function SupportLibrary.Trim(String)
	-- Returns a trimmed version of `String` (adapted from code from lua-users)
	return (String:gsub("^%s*(.-)%s*$", "%1"));
end

function SupportLibrary.ChainCall(...)
	-- Returns function that passes arguments through given functions and returns the final result

	-- Get the given chain of functions
	local Chain = { ... };

	-- Return the chaining function
	return function (...)

		-- Get arguments
		local Arguments = { ... };

		-- Go through each function and store the returned data to reuse in the next function's arguments 
		for _, Function in ipairs(Chain) do
			Arguments = { Function(unpack(Arguments)) };
		end;

		-- Return the final returned data
		return unpack(Arguments);

	end;

end;

function SupportLibrary.CountKeys(Table)
	-- Returns the number of keys in `Table`

	local Count = 0;

	-- Count each key
	for _ in pairs(Table) do
		Count = Count + 1;
	end;

	-- Return the count
	return Count;

end;

function SupportLibrary.Slice(Table, Start, End)
	-- Returns values from `Start` to `End` in `Table`

	local Slice = {};

	-- Go through the given indices
	for Index = Start, End do
		table.insert(Slice, Table[Index]);
	end;

	-- Return the slice
	return Slice;

end;

function SupportLibrary.FlipTable(Table)
	-- Returns a table with keys and values in `Table` swapped

	local FlippedTable = {};

	-- Flip each key and value
	for Key, Value in pairs(Table) do
		FlippedTable[Value] = Key;
	end;

	-- Return the flipped table
	return FlippedTable;

end;

function SupportLibrary.ScheduleRecurringTask(TaskFunction, Interval)
	-- Repeats `Task` every `Interval` seconds until stopped

	-- Create a task object
	local Task = {

		-- A switch determining if it's running or not
		Running = true;

		-- A function to stop this task
		Stop = function (Task)
			Task.Running = false;
		end;

		-- References to the task function and set interval
		TaskFunction = TaskFunction;
		Interval = Interval;

	};

	coroutine.wrap(function (Task)

		-- Repeat the task
		while wait(Task.Interval) and Task.Running do
			Task.TaskFunction();
		end;

	end)(Task);

	-- Return the task object
	return Task;

end;

function SupportLibrary.Clamp(Number, Minimum, Maximum)
	-- Returns the given number, clamped according to the provided min/max

	-- Clamp the number
	if Minimum and Number < Minimum then
		Number = Minimum;
	elseif Maximum and Number > Maximum then
		Number = Maximum;
	end;

	-- Return the clamped number
	return Number;

end;

function SupportLibrary.ReverseTable(Table)
	-- Returns a new table with values in the opposite order

	local ReversedTable = {};

	-- Copy each value at the opposite key
	for Index, Value in ipairs(Table) do
		ReversedTable[#Table - Index + 1] = Value;
	end;

	-- Return the reversed table
	return ReversedTable;

end;

return SupportLibrary;
end;
};
G2L_MODULES[G2L["2d"]] = {
Closure = function()
    local script = G2L["2d"];return {
	Name = 'Try',
	Creator = 'F3X',
	Version = {
		Major = 1,
		Minor = 0,
		Patch = 0
	}
}
end;
};
G2L_MODULES[G2L["2e"]] = {
Closure = function()
    local script = G2L["2e"];Serialization = {};

-- Import services
Support = require(script.Parent.SupportLibrary);
Support.ImportServices();

local Types = {
	Part = 0,
	WedgePart = 1,
	CornerWedgePart = 2,
	VehicleSeat = 3,
	Seat = 4,
	TrussPart = 5,
	SpecialMesh = 6,
	Texture = 7,
	Decal = 8,
	PointLight = 9,
	SpotLight = 10,
	SurfaceLight = 11,
	Smoke = 12,
	Fire = 13,
	Sparkles = 14,
	Model = 15
};

local DefaultNames = {
	Part = 'Part',
	WedgePart = 'Wedge',
	CornerWedgePart = 'CornerWedge',
	VehicleSeat = 'VehicleSeat',
	Seat = 'Seat',
	TrussPart = 'Truss',
	SpecialMesh = 'Mesh',
	Texture = 'Texture',
	Decal = 'Decal',
	PointLight = 'PointLight',
	SpotLight = 'SpotLight',
	SurfaceLight = 'SurfaceLight',
	Smoke = 'Smoke',
	Fire = 'Fire',
	Sparkles = 'Sparkles',
	Model = 'Model'
};

function Serialization.SerializeModel(Items)
	-- Returns a serialized version of the given model

	-- Filter out non-serializable items in `Items`
	local SerializableItems = {};
	for Index, Item in ipairs(Items) do
		table.insert(SerializableItems, Types[Item.ClassName] and Item or nil);
	end;
	Items = SerializableItems;

	-- Get a snapshot of the content
	local Keys = Support.FlipTable(Items);

	local Data = {};
	Data.Version = 3;
	Data.Items = {};

	-- Serialize each item in the model
	for Index, Item in pairs(Items) do

		if Item:IsA 'BasePart' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Size.X;
			Datum[5] = Item.Size.Y;
			Datum[6] = Item.Size.Z;
			Support.ConcatTable(Datum, { Item.CFrame:components() });
			Datum[19] = Item.Color.r;
			Datum[20] = Item.Color.g;
			Datum[21] = Item.Color.b;
			Datum[22] = Item.Material.Value;
			Datum[23] = Item.Anchored and 1 or 0;
			Datum[24] = Item.CanCollide and 1 or 0;
			Datum[25] = Item.Reflectance;
			Datum[26] = Item.Transparency;
			Datum[27] = Item.TopSurface.Value;
			Datum[28] = Item.BottomSurface.Value;
			Datum[29] = Item.FrontSurface.Value;
			Datum[30] = Item.BackSurface.Value;
			Datum[31] = Item.LeftSurface.Value;
			Datum[32] = Item.RightSurface.Value;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'Part' then
			local Datum = Data.Items[Index];
			Datum[33] = Item.Shape.Value;
		end;

		if Item.ClassName == 'VehicleSeat' then
			local Datum = Data.Items[Index];
			Datum[33] = Item.MaxSpeed;
			Datum[34] = Item.Torque;
			Datum[35] = Item.TurnSpeed;
		end;

		if Item.ClassName == 'TrussPart' then
			local Datum = Data.Items[Index];
			Datum[33] = Item.Style.Value;
		end;

		if Item.ClassName == 'SpecialMesh' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.MeshType.Value;
			Datum[5] = Item.MeshId;
			Datum[6] = Item.TextureId;
			Datum[7] = Item.Offset.X;
			Datum[8] = Item.Offset.Y;
			Datum[9] = Item.Offset.Z;
			Datum[10] = Item.Scale.X;
			Datum[11] = Item.Scale.Y;
			Datum[12] = Item.Scale.Z;
			Datum[13] = Item.VertexColor.X;
			Datum[14] = Item.VertexColor.Y;
			Datum[15] = Item.VertexColor.Z;
			Data.Items[Index] = Datum;
		end;

		if Item:IsA 'Decal' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Texture;
			Datum[5] = Item.Transparency;
			Datum[6] = Item.Face.Value;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'Texture' then
			local Datum = Data.Items[Index];
			Datum[7] = Item.StudsPerTileU;
			Datum[8] = Item.StudsPerTileV;
		end;

		if Item:IsA 'Light' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Brightness;
			Datum[5] = Item.Color.r;
			Datum[6] = Item.Color.g;
			Datum[7] = Item.Color.b;
			Datum[8] = Item.Enabled and 1 or 0;
			Datum[9] = Item.Shadows and 1 or 0;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'PointLight' then
			local Datum = Data.Items[Index];
			Datum[10] = Item.Range;
		end;

		if Item.ClassName == 'SpotLight' then
			local Datum = Data.Items[Index];
			Datum[10] = Item.Range;
			Datum[11] = Item.Angle;
			Datum[12] = Item.Face.Value;
		end;

		if Item.ClassName == 'SurfaceLight' then
			local Datum = Data.Items[Index];
			Datum[10] = Item.Range;
			Datum[11] = Item.Angle;
			Datum[12] = Item.Face.Value;
		end;

		if Item.ClassName == 'Smoke' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Enabled and 1 or 0;
			Datum[5] = Item.Color.r;
			Datum[6] = Item.Color.g;
			Datum[7] = Item.Color.b;
			Datum[8] = Item.Size;
			Datum[9] = Item.RiseVelocity;
			Datum[10] = Item.Opacity;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'Fire' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Enabled and 1 or 0;
			Datum[5] = Item.Color.r;
			Datum[6] = Item.Color.g;
			Datum[7] = Item.Color.b;
			Datum[8] = Item.SecondaryColor.r;
			Datum[9] = Item.SecondaryColor.g;
			Datum[10] = Item.SecondaryColor.b;
			Datum[11] = Item.Heat;
			Datum[12] = Item.Size;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'Sparkles' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.Enabled and 1 or 0;
			Datum[5] = Item.SparkleColor.r;
			Datum[6] = Item.SparkleColor.g;
			Datum[7] = Item.SparkleColor.b;
			Data.Items[Index] = Datum;
		end;

		if Item.ClassName == 'Model' then
			local Datum = {};
			Datum[1] = Types[Item.ClassName];
			Datum[2] = Keys[Item.Parent] or 0;
			Datum[3] = Item.Name == DefaultNames[Item.ClassName] and '' or Item.Name;
			Datum[4] = Item.PrimaryPart and Keys[Item.PrimaryPart] or 0;
			Data.Items[Index] = Datum;
		end;

		-- Spread the workload over time to avoid locking up the CPU
		if Index % 100 == 0 then
			wait(0.01);
		end;

	end;

	-- Return the serialized data
	return HttpService:JSONEncode(Data);

end;

function Serialization.InflateBuildData(Data)
	-- Returns an inflated version of the given build data

	local Build = {};
	local Instances = {};

	-- Create each instance
	for Index, Datum in ipairs(Data.Items) do

		-- Inflate BaseParts
		if Datum[1] == Types.Part
			or Datum[1] == Types.WedgePart
			or Datum[1] == Types.CornerWedgePart
			or Datum[1] == Types.VehicleSeat
			or Datum[1] == Types.Seat
			or Datum[1] == Types.TrussPart
		then
			local Item = Instance.new(Support.FindTableOccurrence(Types, Datum[1]));
			Item.Size = Vector3.new(unpack(Support.Slice(Datum, 4, 6)));
			Item.CFrame = CFrame.new(unpack(Support.Slice(Datum, 7, 18)));
			Item.Color = Color3.new(Datum[19], Datum[20], Datum[21]);
			Item.Material = Datum[22];
			Item.Anchored = Datum[23] == 1;
			Item.CanCollide = Datum[24] == 1;
			Item.Reflectance = Datum[25];
			Item.Transparency = Datum[26];
			Item.TopSurface = Datum[27];
			Item.BottomSurface = Datum[28];
			Item.FrontSurface = Datum[29];
			Item.BackSurface = Datum[30];
			Item.LeftSurface = Datum[31];
			Item.RightSurface = Datum[32];

			-- Register the part
			Instances[Index] = Item;
		end;

		-- Inflate specific Part properties
		if Datum[1] == Types.Part then
			local Item = Instances[Index];
			Item.Shape = Datum[33];
		end;

		-- Inflate specific VehicleSeat properties
		if Datum[1] == Types.VehicleSeat then
			local Item = Instances[Index];
			Item.MaxSpeed = Datum[33];
			Item.Torque = Datum[34];
			Item.TurnSpeed = Datum[35];
		end;

		-- Inflate specific TrussPart properties
		if Datum[1] == Types.TrussPart then
			local Item = Instances[Index];
			Item.Style = Datum[33];
		end;

		-- Inflate SpecialMesh instances
		if Datum[1] == Types.SpecialMesh then
			local Item = Instance.new('SpecialMesh');
			Item.MeshType = Datum[4];
			Item.MeshId = Datum[5];
			Item.TextureId = Datum[6];
			Item.Offset = Vector3.new(unpack(Support.Slice(Datum, 7, 9)));
			Item.Scale = Vector3.new(unpack(Support.Slice(Datum, 10, 12)));
			Item.VertexColor = Vector3.new(unpack(Support.Slice(Datum, 13, 15)));

			-- Register the mesh
			Instances[Index] = Item;
		end;

		-- Inflate Decal instances
		if Datum[1] == Types.Decal or Datum[1] == Types.Texture then
			local Item = Instance.new(Support.FindTableOccurrence(Types, Datum[1]));
			Item.Texture = Datum[4];
			Item.Transparency = Datum[5];
			Item.Face = Datum[6];

			-- Register the Decal
			Instances[Index] = Item;
		end;

		-- Inflate specific Texture properties
		if Datum[1] == Types.Texture then
			local Item = Instances[Index];
			Item.StudsPerTileU = Datum[7];
			Item.StudsPerTileV = Datum[8];
		end;

		-- Inflate Light instances
		if Datum[1] == Types.PointLight
			or Datum[1] == Types.SpotLight
			or Datum[1] == Types.SurfaceLight
		then
			local Item = Instance.new(Support.FindTableOccurrence(Types, Datum[1]));
			Item.Brightness = Datum[4];
			Item.Color = Color3.new(unpack(Support.Slice(Datum, 5, 7)));
			Item.Enabled = Datum[8] == 1;
			Item.Shadows = Datum[9] == 1;

			-- Register the light
			Instances[Index] = Item;
		end;

		-- Inflate specific PointLight properties
		if Datum[1] == Types.PointLight then
			local Item = Instances[Index];
			Item.Range = Datum[10];
		end;

		-- Inflate specific SpotLight properties
		if Datum[1] == Types.SpotLight then
			local Item = Instances[Index];
			Item.Range = Datum[10];
			Item.Angle = Datum[11];
			Item.Face = Datum[12];
		end;

		-- Inflate specific SurfaceLight properties
		if Datum[1] == Types.SurfaceLight then
			local Item = Instances[Index];
			Item.Range = Datum[10];
			Item.Angle = Datum[11];
			Item.Face = Datum[12];
		end;

		-- Inflate Smoke instances
		if Datum[1] == Types.Smoke then
			local Item = Instance.new('Smoke');
			Item.Enabled = Datum[4] == 1;
			Item.Color = Color3.new(unpack(Support.Slice(Datum, 5, 7)));
			Item.Size = Datum[8];
			Item.RiseVelocity = Datum[9];
			Item.Opacity = Datum[10];

			-- Register the smoke
			Instances[Index] = Item;
		end;

		-- Inflate Fire instances
		if Datum[1] == Types.Fire then
			local Item = Instance.new('Fire');
			Item.Enabled = Datum[4] == 1;
			Item.Color = Color3.new(unpack(Support.Slice(Datum, 5, 7)));
			Item.SecondaryColor = Color3.new(unpack(Support.Slice(Datum, 8, 10)));
			Item.Heat = Datum[11];
			Item.Size = Datum[12];

			-- Register the fire
			Instances[Index] = Item;
		end;

		-- Inflate Sparkles instances
		if Datum[1] == Types.Sparkles then
			local Item = Instance.new('Sparkles');
			Item.Enabled = Datum[4] == 1;
			Item.SparkleColor = Color3.new(unpack(Support.Slice(Datum, 5, 7)));

			-- Register the instance
			Instances[Index] = Item;
		end;

		-- Inflate Model instances
		if Datum[1] == Types.Model then
			local Item = Instance.new('Model');

			-- Register the model
			Instances[Index] = Item;
		end;

	end;

	-- Set object values on each instance
	for Index, Datum in pairs(Data.Items) do

		-- Get the item's instance
		local Item = Instances[Index];

		-- Set each item's parent and name
		if Item and Datum[1] <= 15 then
			Item.Name = (Datum[3] == '') and DefaultNames[Item.ClassName] or Datum[3];
			if Datum[2] == 0 then
				table.insert(Build, Item);
			else
				Item.Parent = Instances[Datum[2]];
			end;
		end;

		-- Set model primary parts
		if Item and Datum[1] == 15 then
			Item.PrimaryPart = (Datum[4] ~= 0) and Instances[Datum[4]] or nil;
		end;

	end;

	-- Return the model
	return Build;

end;

-- Return the API
return Serialization;
end;
};
G2L_MODULES[G2L["30"]] = {
Closure = function()
    local script = G2L["30"];-- References
SyncAPI = script.Parent;
Tool = SyncAPI.Parent;
Player = nil;

-- Libraries
RbxUtility = LoadLibrary 'RbxUtility';
Support = require(Tool.SupportLibrary);
Security = require(Tool.SecurityModule);
RegionModule = require(Tool['Region by AxisAngle']);
Serialization = require(Tool.SerializationModule);
Create = RbxUtility.Create;
CreateSignal = RbxUtility.CreateSignal;

-- Import services
Support.ImportServices();

-- Default options
Options = {
	DefaultPartParent = Workspace
};

-- Keep track of created items in memory to not lose them in garbage collection
CreatedInstances = {};
LastParents = {};

-- Determine whether we're in tool or plugin mode
if Tool:IsA 'Tool' then
	ToolMode = 'Tool';
elseif Tool:IsA 'Model' then
	ToolMode = 'Plugin';
end;

-- List of actions that could be requested
Actions = {

	['RecolorHandle'] = function (NewColor)
		-- Recolors the tool handle
		Tool.Handle.BrickColor = NewColor;
	end;

	['Clone'] = function (Parts)
		-- Clones the given parts

		-- Make sure the given items are all parts
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, false, AreaPermissions) then
			return;
		end;

		local Clones = {};

		-- Clone the parts
		for _, Part in pairs(Parts) do

			-- Create the clone
			local Clone = Part:Clone();
			Clone.Parent = Options.DefaultPartParent;

			-- Register the clone
			table.insert(Clones, Clone);
			CreatedInstances[Part] = Part;

		end;

		-- Return the clones
		return Clones;
	end;

	['CreatePart'] = function (PartType, Position)
		-- Creates a new part based on `PartType`

		-- Create the part
		local NewPart = Support.CreatePart(PartType);
		NewPart.TopSurface = Enum.SurfaceType.Smooth;
		NewPart.BottomSurface = Enum.SurfaceType.Smooth;

		-- Position the part
		NewPart.CFrame = Position;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas({ NewPart }), Player);

		-- Make sure the player is allowed to create parts in the area
		if Security.ArePartsViolatingAreas({ NewPart }, Player, false, AreaPermissions) then
			return;
		end;

		-- Parent the part
		NewPart.Parent = Options.DefaultPartParent;

		-- Register the part
		CreatedInstances[NewPart] = NewPart;

		-- Return the part
		return NewPart;
	end;

	['Remove'] = function (Objects)
		-- Removes the given objects

		-- Get the relevant parts for each object, for permission checking
		local Parts = {};

		-- Go through the selection
		for _, Object in pairs(Objects) do

			-- Make sure the object still exists
			if Object then

				if Object:IsA 'BasePart' then
					table.insert(Parts, Object);

				elseif Object:IsA 'Smoke' or Object:IsA 'Fire' or Object:IsA 'Sparkles' or Object:IsA 'DataModelMesh' or Object:IsA 'Decal' or Object:IsA 'Texture' or Object:IsA 'Light' then
					table.insert(Parts, Object.Parent);
				end;

			end;

		end;

		-- Ensure relevant parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- After confirming permissions, perform each removal
		for _, Object in pairs(Objects) do

			-- Store the part's current parent
			LastParents[Object] = Object.Parent;

			-- Register the object
			CreatedInstances[Object] = Object;

			-- Set the object's current parent to `nil`
			Object.Parent = nil;

		end;

	end;

	['UndoRemove'] = function (Objects)
		-- Restores the given removed objects to their last parents

		-- Get the relevant parts for each object, for permission checking
		local Parts = {};

		-- Go through the selection
		for _, Object in pairs(Objects) do

			-- Make sure the object still exists, and that its last parent is registered
			if Object and LastParents[Object] then

				if Object:IsA 'BasePart' then
					table.insert(Parts, Object);

				elseif Object:IsA 'Smoke' or Object:IsA 'Fire' or Object:IsA 'Sparkles' or Object:IsA 'DataModelMesh' or Object:IsA 'Decal' or Object:IsA 'Texture' or Object:IsA 'Light' then
					table.insert(Parts, Object.Parent);
				end;

			end;

		end;

		-- Ensure relevant parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, false, AreaPermissions) then
			return;
		end;

		-- After confirming permissions, perform each removal
		for _, Object in pairs(Objects) do

			-- Store the part's current parent
			local LastParent = LastParents[Object];
			LastParents[Object] = Object.Parent;

			-- Register the object
			CreatedInstances[Object] = Object;

			-- Set the object's parent to the last parent
			Object.Parent = LastParent;

		end;

	end;

	['SyncMove'] = function (Changes)
		-- Updates parts server-side given their new CFrames

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				Change.InitialState = { Anchored = Change.Part.Anchored, CFrame = Change.Part.CFrame };
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Preserve joints
		for Part, Change in pairs(ChangeSet) do
			Change.Joints = PreserveJoints(Part, ChangeSet);
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do

			-- Stabilize the parts and maintain the original anchor state
			Part.Anchored = true;
			Part:BreakJoints();
			Part.Velocity = Vector3.new();
			Part.RotVelocity = Vector3.new();

			-- Set the part's CFrame
			Part.CFrame = Change.CFrame;

		end;

		-- Make sure the player is authorized to move parts into this area
		if Security.ArePartsViolatingAreas(Parts, Player, false, AreaPermissions) then

			-- Revert changes if unauthorized destination
			for Part, Change in pairs(ChangeSet) do
				Part.CFrame = Change.InitialState.CFrame;
			end;

		end;

		-- Restore the parts' original states
		for Part, Change in pairs(ChangeSet) do
			Part:MakeJoints();
			RestoreJoints(Change.Joints);
			Part.Anchored = Change.InitialState.Anchored;
		end;

	end;

	['SyncResize'] = function (Changes)
		-- Updates parts server-side given their new sizes and CFrames

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				Change.InitialState = { Anchored = Change.Part.Anchored, Size = Change.Part.Size, CFrame = Change.Part.CFrame };
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do

			-- Stabilize the parts and maintain the original anchor state
			Part.Anchored = true;
			Part:BreakJoints();
			Part.Velocity = Vector3.new();
			Part.RotVelocity = Vector3.new();

			-- Set the part's size and CFrame
			Part.Size = Change.Size;
			Part.CFrame = Change.CFrame;

		end;

		-- Make sure the player is authorized to move parts into this area
		if Security.ArePartsViolatingAreas(Parts, Player, false, AreaPermissions) then

			-- Revert changes if unauthorized destination
			for Part, Change in pairs(ChangeSet) do
				Part.Size = Change.InitialState.Size;
				Part.CFrame = Change.InitialState.CFrame;
			end;

		end;

		-- Restore the parts' original states
		for Part, Change in pairs(ChangeSet) do
			Part:MakeJoints();
			Part.Anchored = Change.InitialState.Anchored;
		end;

	end;

	['SyncRotate'] = function (Changes)
		-- Updates parts server-side given their new CFrames

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				Change.InitialState = { Anchored = Change.Part.Anchored, CFrame = Change.Part.CFrame };
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Preserve joints
		for Part, Change in pairs(ChangeSet) do
			Change.Joints = PreserveJoints(Part, ChangeSet);
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do

			-- Stabilize the parts and maintain the original anchor state
			Part.Anchored = true;
			Part:BreakJoints();
			Part.Velocity = Vector3.new();
			Part.RotVelocity = Vector3.new();

			-- Set the part's CFrame
			Part.CFrame = Change.CFrame;

		end;

		-- Make sure the player is authorized to move parts into this area
		if Security.ArePartsViolatingAreas(Parts, Player, false, AreaPermissions) then

			-- Revert changes if unauthorized destination
			for Part, Change in pairs(ChangeSet) do
				Part.CFrame = Change.InitialState.CFrame;
			end;

		end;

		-- Restore the parts' original states
		for Part, Change in pairs(ChangeSet) do
			Part:MakeJoints();
			RestoreJoints(Change.Joints);
			Part.Anchored = Change.InitialState.Anchored;
		end;

	end;

	['SyncColor'] = function (Changes)
		-- Updates parts server-side given their new colors

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do

			-- Set the part's color
			Part.Color = Change.Color;

			-- If this part is a union, set its UsePartColor state
			if Part.ClassName == 'UnionOperation' then
				Part.UsePartColor = Change.UnionColoring;
			end;

		end;

	end;

	['SyncSurface'] = function (Changes)
		-- Updates parts server-side given their new surfaces

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do

			-- Apply each surface change
			for Surface, SurfaceType in pairs(Change.Surfaces) do
				Part[Surface .. 'Surface'] = SurfaceType;
			end;

		end;

	end;

	['CreateLights'] = function (Changes)
		-- Creates lights in the given parts

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed light type requests
		local AllowedLightTypes = { PointLight = true, SurfaceLight = true, SpotLight = true };

		-- Keep track of the newly created lights
		local Lights = {};

		-- Create each light
		for Part, Change in pairs(ChangeSet) do

			-- Make sure the requested light type is valid
			if AllowedLightTypes[Change.LightType] then

				-- Create the light
				local Light = Instance.new(Change.LightType, Part);
				table.insert(Lights, Light);

				-- Register the light
				CreatedInstances[Light] = Light;

			end;

		end;

		-- Return the new lights
		return Lights;

	end;

	['SyncLighting'] = function (Changes)
		-- Updates aspects of the given selection's lights

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed light type requests
		local AllowedLightTypes = { PointLight = true, SurfaceLight = true, SpotLight = true };

		-- Update each part's lights
		for Part, Change in pairs(ChangeSet) do

			-- Make sure that the light type requested is valid
			if AllowedLightTypes[Change.LightType] then

				-- Grab the part's light
				local Light = Support.GetChildOfClass(Part, Change.LightType);

				-- Make sure the light exists
				if Light then

					-- Make the requested changes
					if Change.Range ~= nil then
						Light.Range = Change.Range;
					end;
					if Change.Brightness ~= nil then
						Light.Brightness = Change.Brightness;
					end;
					if Change.Color ~= nil then
						Light.Color = Change.Color;
					end;
					if Change.Shadows ~= nil then
						Light.Shadows = Change.Shadows;
					end;
					if Change.Face ~= nil then
						Light.Face = Change.Face;
					end;
					if Change.Angle ~= nil then
						Light.Angle = Change.Angle;
					end;

				end;

			end;

		end;

	end;

	['CreateDecorations'] = function (Changes)
		-- Creates decorations in the given parts

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed decoration type requests
		local AllowedDecorationTypes = { Smoke = true, Fire = true, Sparkles = true };

		-- Keep track of the newly created decorations
		local Decorations = {};

		-- Create each decoration
		for Part, Change in pairs(ChangeSet) do

			-- Make sure the requested decoration type is valid
			if AllowedDecorationTypes[Change.DecorationType] then

				-- Create the decoration
				local Decoration = Instance.new(Change.DecorationType, Part);
				table.insert(Decorations, Decoration);

				-- Register the decoration
				CreatedInstances[Decoration] = Decoration;

			end;

		end;

		-- Return the new decorations
		return Decorations;

	end;

	['SyncDecorate'] = function (Changes)
		-- Updates aspects of the given selection's decorations

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed decoration type requests
		local AllowedDecorationTypes = { Smoke = true, Fire = true, Sparkles = true };

		-- Update each part's decorations
		for Part, Change in pairs(ChangeSet) do

			-- Make sure that the decoration type requested is valid
			if AllowedDecorationTypes[Change.DecorationType] then

				-- Grab the part's decoration
				local Decoration = Support.GetChildOfClass(Part, Change.DecorationType);

				-- Make sure the decoration exists
				if Decoration then

					-- Make the requested changes
					if Change.Color ~= nil then
						Decoration.Color = Change.Color;
					end;
					if Change.Opacity ~= nil then
						Decoration.Opacity = Change.Opacity;
					end;
					if Change.RiseVelocity ~= nil then
						Decoration.RiseVelocity = Change.RiseVelocity;
					end;
					if Change.Size ~= nil then
						Decoration.Size = Change.Size;
					end;
					if Change.Heat ~= nil then
						Decoration.Heat = Change.Heat;
					end;
					if Change.SecondaryColor ~= nil then
						Decoration.SecondaryColor = Change.SecondaryColor;
					end;
					if Change.SparkleColor ~= nil then
						Decoration.SparkleColor = Change.SparkleColor;
					end;

				end;

			end;

		end;

	end;

	['CreateMeshes'] = function (Changes)
		-- Creates meshes in the given parts

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Keep track of the newly created meshes
		local Meshes = {};

		-- Create each mesh
		for Part, Change in pairs(ChangeSet) do

			-- Create the mesh
			local Mesh = Instance.new('SpecialMesh', Part);
			table.insert(Meshes, Mesh);

			-- Register the mesh
			CreatedInstances[Mesh] = Mesh;

		end;

		-- Return the new meshes
		return Meshes;

	end;

	['SyncMesh'] = function (Changes)
		-- Updates aspects of the given selection's meshes

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Update each part's meshes
		for Part, Change in pairs(ChangeSet) do

			-- Grab the part's mesh
			local Mesh = Support.GetChildOfClass(Part, 'SpecialMesh');

			-- Make sure the mesh exists
			if Mesh then

				-- Make the requested changes
				if Change.VertexColor ~= nil then
					Mesh.VertexColor = Change.VertexColor;
				end;
				if Change.MeshType ~= nil then
					Mesh.MeshType = Change.MeshType;
				end;
				if Change.Scale ~= nil then
					Mesh.Scale = Change.Scale;
				end;
				if Change.Offset ~= nil then
					Mesh.Offset = Change.Offset;
				end;
				if Change.MeshId ~= nil then
					Mesh.MeshId = Change.MeshId;
				end;
				if Change.TextureId ~= nil then
					Mesh.TextureId = Change.TextureId;
				end;

			end;

		end;

	end;

	['CreateTextures'] = function (Changes)
		-- Creates textures in the given parts

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed texture type requests
		local AllowedTextureTypes = { Texture = true, Decal = true };

		-- Keep track of the newly created textures
		local Textures = {};

		-- Create each texture
		for Part, Change in pairs(ChangeSet) do

			-- Make sure the requested light type is valid
			if AllowedTextureTypes[Change.TextureType] then

				-- Create the texture
				local Texture = Instance.new(Change.TextureType, Part);
				Texture.Face = Change.Face;
				table.insert(Textures, Texture);

				-- Register the texture
				CreatedInstances[Texture] = Texture;

			end;

		end;

		-- Return the new textures
		return Textures;

	end;

	['SyncTexture'] = function (Changes)
		-- Updates aspects of the given selection's textures

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Make a list of allowed texture type requests
		local AllowedTextureTypes = { Texture = true, Decal = true };

		-- Update each part's textures
		for Part, Change in pairs(ChangeSet) do

			-- Make sure that the texture type requested is valid
			if AllowedTextureTypes[Change.TextureType] then

				-- Get the right textures within the part
				for _, Texture in pairs(Part:GetChildren()) do
					if Texture.ClassName == Change.TextureType and Texture.Face == Change.Face then

						-- Perform the changes
						if Change.Texture ~= nil then
							Texture.Texture = Change.Texture;
						end;
						if Change.Transparency ~= nil then
							Texture.Transparency = Change.Transparency;
						end;
						if Change.StudsPerTileU ~= nil then
							Texture.StudsPerTileU = Change.StudsPerTileU;
						end;
						if Change.StudsPerTileV ~= nil then
							Texture.StudsPerTileV = Change.StudsPerTileV;
						end;

					end;
				end;

			end;

		end;

	end;

	['SyncAnchor'] = function (Changes)
		-- Updates parts server-side given their new anchor status

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do
			Part.Anchored = Change.Anchored;
		end;

	end;

	['SyncCollision'] = function (Changes)
		-- Updates parts server-side given their new collision status

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do
			Part.CanCollide = Change.CanCollide;
		end;

	end;

	['SyncMaterial'] = function (Changes)
		-- Updates parts server-side given their new material

		-- Grab a list of every part we're attempting to modify
		local Parts = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				table.insert(Parts, Change.Part);
			end;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Reorganize the changes
		local ChangeSet = {};
		for _, Change in pairs(Changes) do
			if Change.Part then
				ChangeSet[Change.Part] = Change;
			end;
		end;

		-- Perform each change
		for Part, Change in pairs(ChangeSet) do
			if Change.Material ~= nil then
				Part.Material = Change.Material;
			end;
			if Change.Transparency ~= nil then
				Part.Transparency = Change.Transparency;
			end;
			if Change.Reflectance ~= nil then
				Part.Reflectance = Change.Reflectance;
			end;
		end;

	end;

	['CreateWelds'] = function (Parts, TargetPart)
		-- Creates welds for the given parts to the target part

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to perform changes to these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		local Welds = {};

		-- Create the welds
		for _, Part in pairs(Parts) do

			-- Make sure we're not welding this part to itself
			if Part ~= TargetPart then

				-- Calculate the offset of the part from the target part
				local Offset = Part.CFrame:toObjectSpace(TargetPart.CFrame);

				-- Create the weld
				local Weld = Instance.new('Weld');
				Weld.Name = 'BTWeld';
				Weld.Part0 = TargetPart;
				Weld.Part1 = Part;
				Weld.C1 = Offset;
				Weld.Archivable = true;
				Weld.Parent = TargetPart;

				-- Register the weld
				CreatedInstances[Weld] = Weld;
				table.insert(Welds, Weld);

			end;

		end;

		-- Return the welds created
		return Welds;
	end;

	['RemoveWelds'] = function (Welds)
		-- Removes the given welds

		local Parts = {};

		-- Go through each weld
		for _, Weld in pairs(Welds) do

			-- Make sure each given weld is valid
			if Weld.ClassName ~= 'Weld' then
				return;
			end;

			-- Collect the relevant parts for this weld
			table.insert(Parts, Weld.Part0);
			table.insert(Parts, Weld.Part1);

		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		local WeldsRemoved = 0;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Go through each weld
		for _, Weld in pairs(Welds) do

			-- Check the permissions on each weld-related part
			local Part0Unauthorized = Security.ArePartsViolatingAreas({ Weld.Part0 }, Player, true, AreaPermissions);
			local Part1Unauthorized = Security.ArePartsViolatingAreas({ Weld.Part1 }, Player, true, AreaPermissions);

			-- If at least one of the involved parts is authorized, remove the weld
			if not Part0Unauthorized or not Part1Unauthorized then

				-- Register the weld
				CreatedInstances[Weld] = Weld;
				LastParents[Weld] = Weld.Parent;
				WeldsRemoved = WeldsRemoved + 1;

				-- Remove the weld
				Weld.Parent = nil;

			end;

		end;

		-- Return the number of welds removed
		return WeldsRemoved;
	end;

	['UndoRemovedWelds'] = function (Welds)
		-- Restores the given removed welds

		local Parts = {};

		-- Go through each weld
		for _, Weld in pairs(Welds) do

			-- Make sure each given weld is valid
			if Weld.ClassName ~= 'Weld' then
				return;
			end;

			-- Make sure each weld has its old parent registered
			if not LastParents[Weld] then
				return;
			end;

			-- Collect the relevant parts for this weld
			table.insert(Parts, Weld.Part0);
			table.insert(Parts, Weld.Part1);

		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Go through each weld
		for _, Weld in pairs(Welds) do

			-- Check the permissions on each weld-related part
			local Part0Unauthorized = Security.ArePartsViolatingAreas({ Weld.Part0 }, Player, false, AreaPermissions);
			local Part1Unauthorized = Security.ArePartsViolatingAreas({ Weld.Part0 }, Player, false, AreaPermissions);

			-- If at least one of the involved parts is authorized, restore the weld
			if not Part0Unauthorized or not Part1Unauthorized then

				-- Store the part's current parent
				local LastParent = LastParents[Weld];
				LastParents[Weld] = Weld.Parent;

				-- Register the weld
				CreatedInstances[Weld] = Weld;

				-- Set the weld's parent to the last parent
				Weld.Parent = LastParent;

			end;

		end;

	end;

	['Export'] = function (Parts)
		-- Serializes, exports, and returns ID for importing given parts

		-- Offload action to server-side if API is running locally
		if RunService:IsClient() and not RunService:IsStudio() then
			return SyncAPI.ServerEndpoint:InvokeServer('Export', Parts);
		end;

		-- Ensure valid selection
		assert(type(Parts) == 'table', 'Invalid item table');

		-- Ensure there are items to export
		if #Parts == 0 then
			return;
		end;

		-- Ensure parts are selectable
		if not ArePartsSelectable(Parts) then
			return;
		end;

		-- Cache up permissions for all private areas
		local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Parts), Player);

		-- Make sure the player is allowed to access these parts
		if Security.ArePartsViolatingAreas(Parts, Player, true, AreaPermissions) then
			return;
		end;

		-- Get all descendants of the parts
		local Items = Support.CloneTable(Parts);
		for _, Part in pairs(Parts) do
			Support.ConcatTable(Items, Support.GetAllDescendants(Part));
		end;

		-- After confirming permissions, serialize parts
		local SerializedBuildData = Serialization.SerializeModel(Items);

		-- Push serialized data to server
		local Response = HttpService:JSONDecode(
			HttpService:PostAsync(
				'http://f3xteam.com/bt/export',
				HttpService:JSONEncode { data = SerializedBuildData, version = 3, userId = (Player and Player.UserId) },
				Enum.HttpContentType.ApplicationJson,
				true
			)
		);

		-- Return creation ID on success
		if Response.success then
			return Response.id;
		else
			error('Export failed due to server-side error', 2);
		end;

	end;

	['IsHttpServiceEnabled'] = function ()
		-- Returns whether HttpService is enabled

		-- Offload action to server-side if API is running locally
		if RunService:IsClient() and not RunService:IsStudio() then
			return SyncAPI.ServerEndpoint:InvokeServer('IsHttpServiceEnabled');
		end;

		-- For in-game tool, return cached status if available
		if ToolMode == 'Tool' and (IsHttpServiceEnabled ~= nil) then
			return IsHttpServiceEnabled;
		end;

		-- Perform test HTTP request
		local Success, Error = pcall(function ()
			return HttpService:GetAsync('http://google.com');
		end);

		-- Determine whether HttpService is enabled
		if not Success and Error:match 'Http requests are not enabled' then
			IsHttpServiceEnabled = false;
		elseif Success then
			IsHttpServiceEnabled = true;
		end;

		-- Return HttpService status
		return IsHttpServiceEnabled;

	end;

	['ExtractMeshFromAsset'] = function (AssetId)
		-- Returns the first found mesh in the given asset

		-- Offload action to server-side if API is running locally
		if RunService:IsClient() and not RunService:IsStudio() then
			return SyncAPI.ServerEndpoint:InvokeServer('ExtractMeshFromAsset', AssetId);
		end;

		-- Ensure valid asset ID is given
		assert(type(AssetId) == 'number', 'Invalid asset ID');

		-- Return parsed response from API
		return HttpService:JSONDecode(
			HttpService:GetAsync('http://f3xteam.com/bt/getFirstMeshData/' .. AssetId)
		);

	end;

	['ExtractImageFromDecal'] = function (DecalAssetId)
		-- Returns the first image found in the given decal asset

		-- Offload action to server-side if API is running locally
		if RunService:IsClient() and not RunService:IsStudio() then
			return SyncAPI.ServerEndpoint:InvokeServer('ExtractImageFromDecal', DecalAssetId);
		end;

		-- Return direct response from the API
		return HttpService:GetAsync('http://f3xteam.com/bt/getDecalImageID/' .. DecalAssetId);

	end;

	['SetMouseLockEnabled'] = function (Enabled)
		-- Sets whether mouse lock is enabled for the current player

		-- Offload action to server-side if API is running locally
		if RunService:IsClient() and not RunService:IsStudio() then
			return SyncAPI.ServerEndpoint:InvokeServer('SetMouseLockEnabled', Enabled);
		end;

		-- Set whether mouse lock is enabled
		Player.DevEnableMouseLock = Enabled;

	end;

};

function ArePartsSelectable(Parts)
	-- Returns whether the parts are selectable

	-- Check whether each part is selectable
	for _, Part in pairs(Parts) do
		if not Part:IsA 'BasePart' or Part.Locked then
			return false;
		end;
	end;

	-- Return true if all parts are selectable
	return true;

end;

-- References to reduce indexing time
local GetConnectedParts = Instance.new('Part').GetConnectedParts;
local GetChildren = script.GetChildren;

function GetPartJoints(Part, Whitelist)
	-- Returns any manual joints involving `Part`

	local Joints = {};

	-- Get joints stored inside `Part`
	for Joint, JointParent in pairs(SearchJoints(Part, Part, Whitelist)) do
		Joints[Joint] = JointParent;
	end;

	-- Get joints stored inside connected parts
	for _, ConnectedPart in pairs(GetConnectedParts(Part)) do
		for Joint, JointParent in pairs(SearchJoints(ConnectedPart, Part, Whitelist)) do
			Joints[Joint] = JointParent;
		end;
	end;

	-- Return all found joints
	return Joints;

end;

-- Types of joints to assume should be preserved
local ManualJointTypes = Support.FlipTable { 'Weld', 'ManualWeld', 'ManualGlue', 'Motor', 'Motor6D' };

function SearchJoints(Haystack, Part, Whitelist)
	-- Searches for and returns manual joints in `Haystack` involving `Part` and other parts in `Whitelist`

	local Joints = {};

	-- Search the haystack for joints involving `Part`
	for _, Item in pairs(GetChildren(Haystack)) do

		-- Check if this item is a manual, intentional joint
		if ManualJointTypes[Item.ClassName] and
		   (Whitelist[Item.Part0] and Whitelist[Item.Part1]) then

			-- Save joint and state if intentional
			Joints[Item] = Item.Parent;

		end;

	end;

	-- Return the found joints
	return Joints;

end;

function RestoreJoints(Joints)
	-- Restores the joints from the given `Joints` data

	-- Restore each joint
	for Joint, JointParent in pairs(Joints) do
		Joint.Parent = JointParent;
	end;

end;

function PreserveJoints(Part, Whitelist)
	-- Preserves and returns intentional joints of `Part` connecting parts in `Whitelist`

	-- Get the part's joints
	local Joints = GetPartJoints(Part, Whitelist);

	-- Save the joints from being broken
	for Joint in pairs(Joints) do
		Joint.Parent = nil;
	end;

	-- Return the joints
	return Joints;

end;

-- Keep current player updated in tool mode
if ToolMode == 'Tool' then

	-- Set current player if in backpack
	if Tool.Parent and Tool.Parent:IsA 'Backpack' then
		Player = Tool.Parent.Parent;

	-- Set current player if in character
	elseif Tool.Parent and Tool.Parent:IsA 'Model' then
		Player = Players:GetPlayerFromCharacter(Tool.Parent);

	-- Clear `Player` if not in possession of a player
	else
		Player = nil;
	end;

	-- Stay updated with latest player operating the tool
	Tool.AncestryChanged:Connect(function (Child, Parent)

		-- Ensure tool's parent changed
		if Child ~= Tool then
			return;
		end;

		-- Set `Player` to player of the backpack the tool is in
		if Parent and Parent:IsA 'Backpack' then
			Player = Parent.Parent;

		-- Set `Player` to player of the character holding the tool
		elseif Parent and Parent:IsA 'Model' then
			Player = Players:GetPlayerFromCharacter(Parent);

		-- Clear `Player` if tool is not parented to a player
		else
			Player = nil;
		end;

	end);

end;

-- Provide an interface into the module
return {

	-- Provide access to internal options
	Options = Options;

	-- Provide client actions API
	PerformAction = function (Client, ActionName, ...)

		-- Make sure the action exists
		local Action = Actions[ActionName];
		if not Action then
			return;
		end;

		-- Ensure client is current player in tool mode
		if ToolMode == 'Tool' then
			assert(Player and (Client == Player), 'Permission denied for client');
		end;

		-- Execute valid actions
		return Action(...);

	end;

};
end;
};
G2L_MODULES[G2L["38"]] = {
Closure = function()
    local script = G2L["38"];Assets = {
	DarkSlantedRectangle	= 'rbxassetid://127774197';
	LightSlantedRectangle	= 'rbxassetid://127772502';
	ActionCompletionSound	= 'rbxassetid://99666917';
	ExpandArrow				= 'rbxassetid://134367382';
	UndoActiveDecal			= 'rbxassetid://141741408';
	UndoInactiveDecal		= 'rbxassetid://142074557';
	RedoActiveDecal			= 'rbxassetid://141741327';
	RedoInactiveDecal		= 'rbxassetid://142074553';
	DeleteActiveDecal		= 'rbxassetid://141896298';
	DeleteInactiveDecal		= 'rbxassetid://142074644';
	ExportActiveDecal		= 'rbxassetid://141741337';
	ExportInactiveDecal		= 'rbxassetid://142074569';
	CloneActiveDecal		= 'rbxassetid://142073926';
	CloneInactiveDecal		= 'rbxassetid://142074563';
	PluginIcon				= 'rbxassetid://142287521';
	GroupLockIcon			= 'rbxassetid://175396862';
	GroupUnlockIcon			= 'rbxassetid://160408836';
	GroupUpdateOKIcon		= 'rbxassetid://164421681';
	GroupUpdateIcon			= 'rbxassetid://160402908';
	CheckedCheckbox			= 'rbxassetid://401518893';
	UncheckedCheckbox		= 'rbxassetid://401518903';
	SemicheckedCheckbox		= 'rbxassetid://404298168';
	AnchorIcon				= 'rbxassetid://141741323';
	CollisionIcon			= 'rbxassetid://141809596';
	DecorateIcon			= 'rbxassetid://141741412';
	LightingIcon			= 'rbxassetid://141741341';
	MaterialIcon			= 'rbxassetid://141809090';
	MeshIcon				= 'rbxassetid://141806786';
	MoveIcon				= 'rbxassetid://141741366';
	NewPartIcon				= 'rbxassetid://141741393';
	PaintIcon				= 'rbxassetid://141741444';
	ResizeIcon				= 'rbxassetid://141794324';
	RotateIcon				= 'rbxassetid://141807775';
	SurfaceIcon				= 'rbxassetid://141803491';
	TextureIcon				= 'rbxassetid://141805275';
	WeldIcon				= 'rbxassetid://141741418';
};

return Assets;
end;
};
G2L_MODULES[G2L["39"]] = {
Closure = function()
    local script = G2L["39"];Tool = script.Parent;

-- Await initialization
repeat wait() until _G[Tool];
Plugin = _G[Tool].Plugin;

-- Detect mode
Mode = Plugin and 'Plugin' or 'Tool';

-- Load tool completely
local Indicator = Tool:WaitForChild 'Loaded';
while not Indicator.Value do
	Indicator.Changed:wait();
end;

-- Libraries
Security = require(Tool.SecurityModule);
History = require(Tool.HistoryModule);
Selection = require(Tool.SelectionModule);
Targeting = require(Tool.TargetingModule);
Region = require(Tool['Region by AxisAngle']);
RbxUtility = LoadLibrary 'RbxUtility';
Create = RbxUtility.Create;

-- Load additional libraries
while not _G.GetLibraries do wait() end
Support, Cheer, Try = _G.GetLibraries(
	'F3X/SupportLibrary@^1.0.0',
	'F3X/Cheer@^0.0.0',
	'F3X/Try@~1.0.0'
);

-- References
Support.ImportServices();
SyncAPI = Tool.SyncAPI;
Player = Players.LocalPlayer;

-- Preload assets
Assets = require(Tool.Assets);
ContentProvider:PreloadAsync(Support.Values(Assets));

-- Core events
ToolChanged = RbxUtility.CreateSignal();

function EquipTool(Tool)
	-- Equips and switches to the given tool

	-- Unequip current tool
	if CurrentTool and CurrentTool.Equipped then
		CurrentTool.Unequip();
		CurrentTool.Equipped = false;
	end;

	-- Set `Tool` as current
	CurrentTool = Tool;
	CurrentTool.Equipped = true;

	-- Fire relevant events
	ToolChanged:fire(Tool);

	-- Equip the tool
	Tool.Equip();

end;

function RecolorHandle(Color)
	SyncAPI:Invoke('RecolorHandle', Color);
end;

-- Theme UI to current tool
ToolChanged:connect(function (Tool)
	coroutine.wrap(RecolorHandle)(Tool.Color);
	coroutine.wrap(Selection.RecolorOutlines)(Tool.Color);
end);

-- Core hotkeys
Hotkeys = {};

function AssignHotkey(Hotkey, Callback)
	-- Assigns the given hotkey to `Callback`

	-- Standardize enum-described hotkeys
	if type(Hotkey) == 'userdata' then
		Hotkey = { Hotkey };

	-- Standardize string-described hotkeys
	elseif type(Hotkey) == 'string' then
		Hotkey = { Enum.KeyCode[Hotkey] };

	-- Standardize string table-described hotkeys
	elseif type(Hotkey) == 'table' then
		for Index, Key in ipairs(Hotkey) do
			if type(Key) == 'string' then
				Hotkey[Index] = Enum.KeyCode[Key];
			end;
		end;
	end;

	-- Register the hotkey
	table.insert(Hotkeys, { Keys = Hotkey, Callback = Callback });

end;

function EnableHotkeys()
	-- Begins to listen for hotkey triggering

	-- Listen for pressed keys
	Connections.Hotkeys = Support.AddUserInputListener('Began', 'Keyboard', false, function (Input)
		local _PressedKeys = Support.GetListMembers(UserInputService:GetKeysPressed(), 'KeyCode');

		-- Filter out problematic keys
		local PressedKeys = {};
		local FilteredKeys = Support.FlipTable { 'LeftAlt', 'W', 'S', 'A', 'D', 'Space' };
		for _, Key in ipairs(_PressedKeys) do
			if not FilteredKeys[Key.Name] then
				table.insert(PressedKeys, Key);
			end;
		end;

		-- Count pressed keys
		local KeyCount = #PressedKeys;

		-- Prioritize hotkeys based on # of required keys
		table.sort(Hotkeys, function (A, B)
			if #A.Keys > #B.Keys then
				return true;
			end;
		end);

		-- Identify matching hotkeys
		for _, Hotkey in ipairs(Hotkeys) do
			if KeyCount == #Hotkey.Keys then

				-- Get the hotkey's key index
				local Keys = Support.FlipTable(Hotkey.Keys)
				local MatchingKeys = 0;

				-- Check matching pressed keys
				for _, PressedKey in pairs(PressedKeys) do
					if Keys[PressedKey] then
						MatchingKeys = MatchingKeys + 1;
					end;
				end;

				-- Trigger the first matching hotkey's callback
				if MatchingKeys == KeyCount then
					Hotkey.Callback();
					break;
				end;

			end;
		end;
	end);

end;

Enabling = RbxUtility.CreateSignal();
Disabling = RbxUtility.CreateSignal();
Enabled = RbxUtility.CreateSignal();
Disabled = RbxUtility.CreateSignal();

function Enable(Mouse)

	-- Ensure tool is disabled or disabling, and not already enabling
	if (IsEnabled and not IsDisabling) or IsEnabling then
		return;

	-- If tool is disabling, enable it once fully disabled
	elseif IsDisabling then
		Disabled:Wait();
		return Enable(Mouse);
	end;

	-- Indicate that tool is enabling
	IsEnabling = true;
	Enabling:Fire();

	-- Update the core mouse
	getfenv(0).Mouse = Mouse;

	-- Use default mouse behavior
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default;

	-- Disable mouse lock in tool mode
	if Mode == 'Tool' then
		SyncAPI:Invoke('SetMouseLockEnabled', false);
	end;

	-- Wait for UI to initialize asynchronously
	while not UI do
		wait(0.1);
	end;

	-- Show UI
	UI.Parent = UIContainer;

	-- Display startup notifications
	if not StartupNotificationsDisplayed then
		Cheer(Tool.Interfaces.Notifications, UI).Start(getfenv(0));
		StartupNotificationsDisplayed = true;
	end;

	-- Start systems
	EnableHotkeys();
	Targeting.EnableTargeting();
	Selection.EnableOutlines();
	Selection.EnableMultiselectionHotkeys();

	-- Equip current tool
	EquipTool(CurrentTool or require(Tool.Tools.MoveTool));

	-- Indicate that tool is now enabled
	IsEnabled = true;
	IsEnabling = false;
	Enabled:Fire();

end;

function Disable()

	-- Ensure tool is enabled or enabling, and not already disabling
	if (not IsEnabled and not IsEnabling) or IsDisabling then
		return;

	-- If tool is enabling, disable it once fully enabled
	elseif IsEnabling then
		Enabled:Wait();
		return Disable();
	end;

	-- Indicate that tool is now disabling
	IsDisabling = true;
	Disabling:Fire();

	-- Reenable mouse lock option in tool mode
	if Mode == 'Tool' then
		pcall(SyncAPI.Invoke, SyncAPI, 'SetMouseLockEnabled', true);
	end;

	-- Hide UI
	if UI then
		UI.Parent = script;
	end;

	-- Unequip current tool
	if CurrentTool then
		CurrentTool.Unequip();
		CurrentTool.Equipped = false;
	end;

	-- Clear temporary connections
	ClearConnections();

	-- Indicate that tool is now disabled
	IsEnabled = false;
	IsDisabling = false;
	Disabled:Fire();

end;


-- Core connections
Connections = {};

function ClearConnections()
	-- Clears and disconnects temporary connections
	for Index, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[Index] = nil;
	end;
end;

function InitializeUI()
	-- Sets up the UI

	-- Ensure UI has not yet been initialized
	if UI then
		return;
	end;

	-- Create the root UI
	UI = Create 'ScreenGui' {
		Name = 'Building Tools by F3X (UI)'
	};

	-- Set up dock
	Dock = Cheer(Tool.Interfaces.Dock, UI).Start(getfenv(0));

end;

-- Enable tool or plugin
if Mode == 'Plugin' then

	-- Set the UI root
	UIContainer = CoreGui;

	-- Create the toolbar button
	PluginButton = Plugin:CreateToolbar('Building Tools by F3X'):CreateButton(
		'Building Tools by F3X',
		'Building Tools by F3X',
		Assets.PluginIcon
	);

	-- Connect the button to the system
	PluginButton.Click:connect(function ()
		PluginEnabled = not PluginEnabled;
		PluginButton:SetActive(PluginEnabled);

		-- Toggle the tool
		if PluginEnabled then
			Plugin:Activate(true);
			Enable(Plugin:GetMouse());
		else
			Disable();
		end;
	end);

	-- Disable the tool upon plugin deactivation
	Plugin.Deactivation:connect(Disable);

	-- Sync Studio selection to internal selection
	Selection.Changed:connect(function ()
		SelectionService:Set(Selection.Items);
	end);

	-- Sync internal selection to Studio selection on enabling
	Enabling:connect(function ()
		Selection.Replace(SelectionService:Get());
	end);

	-- Roughly sync Studio history to internal history (API lacking necessary functionality)
	History.Changed:connect(function ()
		ChangeHistoryService:SetWaypoint 'Building Tools by F3X';
	end);

elseif Mode == 'Tool' then

	-- Set the UI root
	UIContainer = Player:WaitForChild 'PlayerGui';

	-- Connect the tool to the system
	Tool.Equipped:connect(Enable);
	Tool.Unequipped:connect(Disable);

	-- Disable the tool if not parented
	if not Tool.Parent then
		Disable();
	end;

	-- Disable the tool automatically if not equipped or in backpack
	Tool.AncestryChanged:connect(function (Item, Parent)
		if not Parent or not (Parent:IsA 'Backpack' or (Parent:IsA 'Model' and Players:GetPlayerFromCharacter(Parent))) then
			Disable();
		end;
	end);

end;

-- Assign hotkeys for undoing (left or right shift + Z)
AssignHotkey({ 'LeftShift', 'Z' }, History.Undo);
AssignHotkey({ 'RightShift', 'Z' }, History.Undo);

-- Assign hotkeys for redoing (left or right shift + Y)
AssignHotkey({ 'LeftShift', 'Y' }, History.Redo);
AssignHotkey({ 'RightShift', 'Y' }, History.Redo);

-- If in-game, enable ctrl hotkeys for undoing and redoing
if Mode == 'Tool' then
	AssignHotkey({ 'LeftControl', 'Z' }, History.Undo);
	AssignHotkey({ 'RightControl', 'Z' }, History.Undo);
	AssignHotkey({ 'LeftControl', 'Y' }, History.Redo);
	AssignHotkey({ 'RightControl', 'Y' }, History.Redo);
end;

function CloneSelection()
	-- Clones selected parts

	-- Make sure that there are items in the selection
	if #Selection.Items == 0 then
		return;
	end;

	-- Send the cloning request to the server
	local Clones = SyncAPI:Invoke('Clone', Selection.Items);

	-- Put together the history record
	local HistoryRecord = {
		Clones = Clones;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Deselect the clones
			Selection.Remove(HistoryRecord.Clones, false);

			-- Remove the clones
			SyncAPI:Invoke('Remove', HistoryRecord.Clones);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the clones
			SyncAPI:Invoke('UndoRemove', HistoryRecord.Clones);

		end;

	};

	-- Register the history record
	History.Add(HistoryRecord);

	-- Select the clones
	Selection.Replace(Clones);

	-- Play a confirmation sound
	PlayConfirmationSound();

	-- Flash the outlines of the new parts
	coroutine.wrap(Selection.FlashOutlines)();

end;

ConfirmationSound = Create 'Sound' {
	Name = 'BTActionCompletionSound';
	Pitch = 1.5;
	SoundId = Assets.ActionCompletionSound;
	Volume = 1;
};

function PlayConfirmationSound()
	-- Plays a confirmation beep sound

	-- Trigger the sound locally
	SoundService:PlayLocalSound(ConfirmationSound);

end;

function DeleteSelection()
	-- Deletes selected items

	-- Put together the history record
	local HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the parts
			SyncAPI:Invoke('UndoRemove', HistoryRecord.Parts);

			-- Select the restored parts
			Selection.Replace(HistoryRecord.Parts);

		end;

		Apply = function (HistoryRecord)
			-- Applies this change

			-- Deselect the parts
			Selection.Remove(HistoryRecord.Parts, false);

			-- Remove the parts
			SyncAPI:Invoke('Remove', HistoryRecord.Parts);

		end;

	};

	-- Deselect parts before deleting
	Selection.Remove(HistoryRecord.Parts, false);

	-- Perform the removal
	SyncAPI:Invoke('Remove', HistoryRecord.Parts);

	-- Register the history record
	History.Add(HistoryRecord);

end;

-- Assign hotkeys for cloning (left or right shift + c)
AssignHotkey({ 'LeftShift', 'C' }, CloneSelection);
AssignHotkey({ 'RightShift', 'C' }, CloneSelection);

-- Assign hotkeys for deletion (left or right shift + X)
AssignHotkey({ 'LeftShift', 'X' }, DeleteSelection);
AssignHotkey({ 'RightShift', 'X' }, DeleteSelection);

-- If in-game, enable ctrl hotkeys for cloning and deleting
if Mode == 'Tool' then
	AssignHotkey({ 'LeftControl', 'C' }, CloneSelection);
	AssignHotkey({ 'RightControl', 'C' }, CloneSelection);
	AssignHotkey({ 'LeftControl', 'X' }, DeleteSelection);
	AssignHotkey({ 'RightControl', 'X' }, DeleteSelection);
end;

-- Assign hotkeys for prism selection
AssignHotkey({ 'LeftShift', 'K' }, Targeting.PrismSelect);
AssignHotkey({ 'RightShift', 'K' }, Targeting.PrismSelect);

-- If in-game, enable ctrl hotkeys for prism selection
if Mode == 'Tool' then
	AssignHotkey({ 'LeftControl', 'K' }, Targeting.PrismSelect);
	AssignHotkey({ 'RightControl', 'K' }, Targeting.PrismSelect);
end;

-- Assign hotkeys for sibling selection
AssignHotkey({ 'LeftBracket' }, Support.Call(Targeting.SelectSiblings, false, true));
AssignHotkey({ 'LeftShift', 'LeftBracket' }, Support.Call(Targeting.SelectSiblings, false, false));
AssignHotkey({ 'RightShift', 'LeftBracket' }, Support.Call(Targeting.SelectSiblings, false, false));

-- Assign hotkeys for selection clearing
AssignHotkey({ 'LeftShift', 'R' }, Support.Call(Selection.Clear, true));
AssignHotkey({ 'RightShift', 'R' }, Support.Call(Selection.Clear, true));

-- If in-game, enable ctrl hotkeys for sibling selection & selection clearing
if Mode == 'Tool' then
	AssignHotkey({ 'LeftControl', 'LeftBracket' }, Support.Call(Targeting.SelectSiblings, false, false));
	AssignHotkey({ 'RightControl', 'LeftBracket' }, Support.Call(Targeting.SelectSiblings, false, false));
	AssignHotkey({ 'LeftControl', 'R' }, Support.Call(Selection.Clear, true));
	AssignHotkey({ 'RightControl', 'R' }, Support.Call(Selection.Clear, true));
end;

function IsSelectable(Object)
	-- Returns whether `Object` can be selected

	-- Check if `Object` exists, is not locked, and is not ignored
	if not Object or not Object.Parent or not Object:IsA 'BasePart' or Object.Locked or IsIgnored(Object) then
		return false;
	end;

	-- If areas are enabled, check if `Object` violates any areas
	if Security.AreAreasEnabled() then
		return not Security.ArePartsViolatingAreas({ Object }, Player, true, {});
	end;

	-- If no checks fail, `Object` is selectable
	return Object;

end;

function IsIgnored(Object)
	-- TODO: Add ignoring capability
end;

function SetParent(Parent)
	-- Sets the current default parent for parts

end;

function ExportSelection()
	-- Exports the selected parts

	-- Make sure that there are items in the selection
	if #Selection.Items == 0 then
		return;
	end;

	-- Start an export dialog
	local Dialog = Cheer(Tool.Interfaces.ExportDialog, UI).Start();

	-- Send the exporting request to the server
	Try(SyncAPI.Invoke, SyncAPI, 'Export', Selection.Items)

	-- Display creation ID on success
	:Then(function (CreationId)
		Dialog.SetResult(CreationId);
		PlayConfirmationSound();
		print('[Building Tools by F3X] Uploaded Export:', CreationId);
	end)

	-- Display error messages on failure
	:Catch('Http requests are not enabled', function ()
		Dialog.SetError('Please enable HTTP requests');
	end)
	:Catch('Export failed due to server-side error', function ()
		Dialog.SetError('An error occurred, try again');
	end)
	:Catch('Post data too large', function ()
		Dialog.SetError('Try splitting up your build');
	end)
	:Catch(function (Error, Stack, Attempt)
		Dialog.SetError('An unknown error occurred, try again')
		warn(' [Building Tools by F3X] Failed to export selection', '\n\nError:\n', Error, '\n\nStack:\n', Stack);
	end);

end;

-- Assign hotkey for exporting selection
AssignHotkey({ 'LeftShift', 'P' }, ExportSelection);
AssignHotkey({ 'RightShift', 'P' }, ExportSelection);

-- If in-game, enable ctrl hotkeys for exporting
if Mode == 'Tool' then
	AssignHotkey({ 'LeftControl', 'P' }, ExportSelection);
	AssignHotkey({ 'RightControl', 'P' }, ExportSelection);
end;

function IsVersionOutdated()
	-- Returns whether this version of Building Tools is out of date

	-- Check most recent version number
	local AssetInfo = MarketplaceService:GetProductInfo(142785488, Enum.InfoType.Asset);
	local LatestMajorVersion, LatestMinorVersion, LatestPatchVersion = AssetInfo.Description:match '%[Version: ([0-9]+)%.([0-9]+)%.([0-9]+)%]';
	local CurrentMajorVersion, CurrentMinorVersion, CurrentPatchVersion = Tool.Version.Value:match '([0-9]+)%.([0-9]+)%.([0-9]+)';

	-- Convert version data into numbers
	local LatestMajorVersion, LatestMinorVersion, LatestPatchVersion =
		tonumber(LatestMajorVersion), tonumber(LatestMinorVersion), tonumber(LatestPatchVersion);
	local CurrentMajorVersion, CurrentMinorVersion, CurrentPatchVersion =
		tonumber(CurrentMajorVersion), tonumber(CurrentMinorVersion), tonumber(CurrentPatchVersion);

	-- Determine whether current version is outdated
	if LatestMajorVersion > CurrentMajorVersion then
		return true;
	elseif LatestMajorVersion == CurrentMajorVersion then
		if LatestMinorVersion > CurrentMinorVersion then
			return true;
		elseif LatestMinorVersion == CurrentMinorVersion then
			return LatestPatchVersion > CurrentPatchVersion;
		end;
	end;

	-- Return an up-to-date status if not oudated
	return false;

end;

function ToggleSwitch(CurrentButtonName, SwitchContainer)
	-- Toggles between the buttons in a switch

	-- Reset all buttons
	for _, Button in pairs(SwitchContainer:GetChildren()) do

		-- Make sure to not mistake the option label for a button
		if Button.Name ~= 'Label' then

			-- Set appearance to disabled
			Button.SelectedIndicator.BackgroundTransparency = 1;
			Button.Background.Image = Assets.LightSlantedRectangle;

		end;

	end;

	-- Make sure there's a new current button
	if CurrentButtonName then

		-- Get the current button
		local CurrentButton = SwitchContainer[CurrentButtonName];

		-- Set the current button's appearance to enabled
		CurrentButton.SelectedIndicator.BackgroundTransparency = 0;
		CurrentButton.Background.Image = Assets.DarkSlantedRectangle;

	end;
end;

-- References to reduce indexing time
local GetConnectedParts = Instance.new('Part').GetConnectedParts;
local GetChildren = script.GetChildren;

function GetPartJoints(Part, Whitelist)
	-- Returns any manual joints involving `Part`

	local Joints = {};

	-- Get joints stored inside `Part`
	for Joint, JointParent in pairs(SearchJoints(Part, Part, Whitelist)) do
		Joints[Joint] = JointParent;
	end;

	-- Get joints stored inside connected parts
	for _, ConnectedPart in pairs(GetConnectedParts(Part)) do
		for Joint, JointParent in pairs(SearchJoints(ConnectedPart, Part, Whitelist)) do
			Joints[Joint] = JointParent;
		end;
	end;

	-- Return all found joints
	return Joints;

end;

-- Types of joints to assume should be preserved
local ManualJointTypes = Support.FlipTable { 'Weld', 'ManualWeld', 'ManualGlue', 'Motor', 'Motor6D' };

function SearchJoints(Haystack, Part, Whitelist)
	-- Searches for and returns manual joints in `Haystack` involving `Part` and other parts in `Whitelist`

	local Joints = {};

	-- Search the haystack for joints involving `Part`
	for _, Item in pairs(GetChildren(Haystack)) do

		-- Check if this item is a manual, intentional joint
		if ManualJointTypes[Item.ClassName] and
		   (Whitelist[Item.Part0] and Whitelist[Item.Part1]) then

			-- Save joint and state if intentional
			Joints[Item] = Item.Parent;

		end;

	end;

	-- Return the found joints
	return Joints;

end;

function RestoreJoints(Joints)
	-- Restores the joints from the given `Joints` data

	-- Restore each joint
	for Joint, JointParent in pairs(Joints) do
		Joint.Parent = JointParent;
	end;

end;

function PreserveJoints(Part, Whitelist)
	-- Preserves and returns intentional joints of `Part` connecting parts in `Whitelist`

	-- Get the part's joints
	local Joints = GetPartJoints(Part, Whitelist);

	-- Save the joints from being broken
	for Joint in pairs(Joints) do
		Joint.Parent = nil;
	end;

	-- Return the joints
	return Joints;

end;

-- Initialize the UI
InitializeUI();

-- Return core
return getfenv(0);
end;
};
G2L_MODULES[G2L["3c"]] = {
Closure = function()
    local script = G2L["3c"];Tool = script.Parent.Parent;
Core = require(Tool.Core);
SnapTracking = require(Tool.SnappingModule);
BoundingBox = require(Tool.BoundingBoxModule);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local MoveTool = {

	Name = 'Move Tool';
	Color = BrickColor.new 'Deep orange';

	-- Default options
	Increment = 1;
	Axes = 'Global';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function MoveTool.Equip()
	-- Enables the tool's equipped functionality

	-- Set our current axis mode
	SetAxes(MoveTool.Axes);

	-- Start up our interface
	ShowUI();
	BindShortcutKeys();
	EnableDragging();

end;

function MoveTool.Unequip()
	-- Disables the tool's equipped functionality

	-- If dragging, finish dragging
	if Dragging then
		FinishDragging();
	end;

	-- Clear unnecessary resources
	HideUI();
	HideHandles();
	ClearConnections();
	BoundingBox.ClearBoundingBox();
	SnapTracking.StopTracking();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ClearConnection(ConnectionKey)
	-- Clears the given specific connection

	local Connection = Connections[ConnectionKey];

	-- Disconnect the connection if it exists
	if Connections[ConnectionKey] then
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if MoveTool.UI then

		-- Reveal the UI
		MoveTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	MoveTool.UI = Core.Tool.Interfaces.BTMoveToolGUI:Clone();
	MoveTool.UI.Parent = Core.UI;
	MoveTool.UI.Visible = true;

	-- Add functionality to the axes option switch
	local AxesSwitch = MoveTool.UI.AxesOption;
	AxesSwitch.Global.Button.MouseButton1Down:connect(function ()
		SetAxes('Global');
	end);
	AxesSwitch.Local.Button.MouseButton1Down:connect(function ()
		SetAxes('Local');
	end);
	AxesSwitch.Last.Button.MouseButton1Down:connect(function ()
		SetAxes('Last');
	end);

	-- Add functionality to the increment input
	local IncrementInput = MoveTool.UI.IncrementOption.Increment.TextBox;
	IncrementInput.FocusLost:connect(function (EnterPressed)
		MoveTool.Increment = tonumber(IncrementInput.Text) or MoveTool.Increment;
		IncrementInput.Text = Support.Round(MoveTool.Increment, 4);
	end);

	-- Add functionality to the position inputs
	local XInput = MoveTool.UI.Info.Center.X.TextBox;
	local YInput = MoveTool.UI.Info.Center.Y.TextBox;
	local ZInput = MoveTool.UI.Info.Center.Z.TextBox;
	XInput.FocusLost:connect(function (EnterPressed)
		local NewPosition = tonumber(XInput.Text);
		if NewPosition then
			SetAxisPosition('X', NewPosition);
		end;
	end);
	YInput.FocusLost:connect(function (EnterPressed)
		local NewPosition = tonumber(YInput.Text);
		if NewPosition then
			SetAxisPosition('Y', NewPosition);
		end;
	end);
	ZInput.FocusLost:connect(function (EnterPressed)
		local NewPosition = tonumber(ZInput.Text);
		if NewPosition then
			SetAxisPosition('Z', NewPosition);
		end;
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not MoveTool.UI then
		return;
	end;

	-- Hide the UI
	MoveTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not MoveTool.UI then
		return;
	end;

	-- Only show and calculate selection info if it's not empty
	if #Selection.Items == 0 then
		MoveTool.UI.Info.Visible = false;
		MoveTool.UI.Size = UDim2.new(0, 245, 0, 90);
		return;
	else
		MoveTool.UI.Info.Visible = true;
		MoveTool.UI.Size = UDim2.new(0, 245, 0, 150);
	end;

	---------------------------------------------
	-- Update the position information indicators
	---------------------------------------------

	-- Identify common positions across axes
	local XVariations, YVariations, ZVariations = {}, {}, {};
	for _, Part in pairs(Selection.Items) do
		table.insert(XVariations, Support.Round(Part.Position.X, 3));
		table.insert(YVariations, Support.Round(Part.Position.Y, 3));
		table.insert(ZVariations, Support.Round(Part.Position.Z, 3));
	end;
	local CommonX = Support.IdentifyCommonItem(XVariations);
	local CommonY = Support.IdentifyCommonItem(YVariations);
	local CommonZ = Support.IdentifyCommonItem(ZVariations);

	-- Shortcuts to indicators
	local XIndicator = MoveTool.UI.Info.Center.X.TextBox;
	local YIndicator = MoveTool.UI.Info.Center.Y.TextBox;
	local ZIndicator = MoveTool.UI.Info.Center.Z.TextBox;

	-- Update each indicator if it's not currently being edited
	if not XIndicator:IsFocused() then
		XIndicator.Text = CommonX or '*';
	end;
	if not YIndicator:IsFocused() then
		YIndicator.Text = CommonY or '*';
	end;
	if not ZIndicator:IsFocused() then
		ZIndicator.Text = CommonZ or '*';
	end;

end;

function SetAxes(AxisMode)
	-- Sets the given axis mode

	-- Update setting
	MoveTool.Axes = AxisMode;

	-- Update the UI switch
	if MoveTool.UI then
		Core.ToggleSwitch(AxisMode, MoveTool.UI.AxesOption);
	end;

	-- Disable any unnecessary bounding boxes
	BoundingBox.ClearBoundingBox();

	-- For global mode, use bounding box handles
	if AxisMode == 'Global' then
		BoundingBox.StartBoundingBox(AttachHandles);

	-- For local mode, use focused part handles
	elseif AxisMode == 'Local' then
		AttachHandles(Selection.Focus, true); 

	-- For last mode, use focused part handles
	elseif AxisMode == 'Last' then
		AttachHandles(Selection.Focus, true);
	end;

end;

-- Directions of movement for each handle's dragged face
local AxisMultipliers = {
	[Enum.NormalId.Top] = Vector3.new(0, 1, 0);
	[Enum.NormalId.Bottom] = Vector3.new(0, -1, 0);
	[Enum.NormalId.Front] = Vector3.new(0, 0, -1);
	[Enum.NormalId.Back] = Vector3.new(0, 0, 1);
	[Enum.NormalId.Left] = Vector3.new(-1, 0, 0);
	[Enum.NormalId.Right] = Vector3.new(1, 0, 0);
};

function AttachHandles(Part, Autofocus)
	-- Creates and attaches handles to `Part`, and optionally automatically attaches to the focused part

	-- Enable autofocus if requested and not already on
	if Autofocus and not Connections.AutofocusHandle then
		Connections.AutofocusHandle = Selection.FocusChanged:connect(function ()
			AttachHandles(Selection.Focus, true);
		end);

	-- Disable autofocus if not requested and on
	elseif not Autofocus and Connections.AutofocusHandle then
		ClearConnection 'AutofocusHandle';
	end;

	-- Just attach and show the handles if they already exist
	if Handles then
		Handles.Adornee = Part;
		Handles.Visible = true;
		Handles.Parent = Part and Core.UIContainer or nil;
		return;
	end;

	-- Create the handles
	Handles = Create 'Handles' {
		Name = 'BTMovementHandles';
		Color = MoveTool.Color;
		Parent = Core.UIContainer;
		Adornee = Part;
	};

	------------------------------------------------------
	-- Prepare for moving parts when the handle is clicked
	------------------------------------------------------

	local AreaPermissions;

	Handles.MouseButton1Down:connect(function ()

		-- Prevent selection
		Core.Targeting.CancelSelecting();

		-- Indicate dragging via handles
		HandleDragging = true;

		-- Freeze bounding box extents while dragging
		if BoundingBox.GetBoundingBox() then
			InitialExtentsSize, InitialExtentsCFrame = BoundingBox.CalculateExtents(Core.Selection.Items, BoundingBox.StaticExtents);
			BoundingBox.PauseMonitoring();
		end;

		-- Stop parts from moving, and capture the initial state of the parts
		InitialState = PreparePartsForDragging();

		-- Track the change
		TrackChange();

		-- Cache area permissions information
		if Core.Mode == 'Tool' then
			AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);
		end;

	end);

	------------------------------------------
	-- Update parts when the handles are moved
	------------------------------------------

	Handles.MouseDrag:connect(function (Face, Distance)

		-- Only drag if handle is enabled
		if not HandleDragging then
			return;
		end;

		-- Calculate the increment-aligned drag distance
		Distance = GetIncrementMultiple(Distance, MoveTool.Increment);

		-- Move the parts along the selected axes by the calculated distance
		MovePartsAlongAxesByFace(Face, Distance, MoveTool.Axes, Selection.Focus, InitialState);

		-- Make sure we're not entering any unauthorized private areas
		if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
			Selection.Focus.CFrame = InitialState[Selection.Focus].CFrame;
			TranslatePartsRelativeToPart(Selection.Focus, InitialState);
			Distance = 0;
		end;

		-- Update the "distance moved" indicator
		if MoveTool.UI then
			MoveTool.UI.Changes.Text.Text = 'moved ' .. math.abs(Distance) .. ' studs';
		end;

		-- Update bounding box if enabled in global axes movements
		if MoveTool.Axes == 'Global' and BoundingBox.GetBoundingBox() then
			BoundingBox.GetBoundingBox().CFrame = InitialExtentsCFrame + (AxisMultipliers[Face] * Distance);
		end;

	end);

end;

-- Finalize changes to parts when the handle is let go
Support.AddUserInputListener('Ended', 'MouseButton1', true, function (Input)

	-- Ensure handle dragging is ongoing
	if not HandleDragging then
		return;
	end;

	-- Disable dragging
	HandleDragging = false;

	-- Clear this connection to prevent it from firing again
	ClearConnection 'HandleRelease';

	-- Make joints, restore original anchor and collision states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

	-- Resume normal bounding box updating
	BoundingBox.RecalculateStaticExtents();
	BoundingBox.ResumeMonitoring();

end);

function HideHandles()
	-- Hides the resizing handles

	-- Make sure handles exist and are visible
	if not Handles or not Handles.Visible then
		return;
	end;

	-- Hide the handles
	Handles.Visible = false;
	Handles.Parent = nil;

	-- Disable handle autofocus
	ClearConnection 'AutofocusHandle';

end;

function MovePartsAlongAxesByFace(Face, Distance, Axes, BasePart, InitialStates)
	-- Moves the given parts in `InitialStates`, along the given axis mode, in the given face direction, by the given distance

	-- Get the axis multiplier for this face
	local AxisMultiplier = AxisMultipliers[Face];

	-- Get starting state for `BasePart`
	local InitialBasePartState = InitialStates[BasePart];

	-- Move each part
	for Part, InitialState in pairs(InitialStates) do

		-- Move along standard axes
		if Axes == 'Global' then
			Part.CFrame = InitialState.CFrame + (Distance * AxisMultiplier);

		-- Move along item's axes
		elseif Axes == 'Local' then
			Part.CFrame = InitialState.CFrame * CFrame.new(Distance * AxisMultiplier);

		-- Move along focused part's axes
		elseif Axes == 'Last' then

			-- Calculate the focused part's position
			local RelativeTo = InitialBasePartState.CFrame * CFrame.new(Distance * AxisMultiplier);

			-- Calculate how far apart we should be from the focused part
			local Offset = InitialBasePartState.CFrame:toObjectSpace(InitialState.CFrame);

			-- Move relative to the focused part by this part's offset from it
			Part.CFrame = RelativeTo * Offset;

		end;

	end;

end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Toggle the current axis mode
			if MoveTool.Axes == 'Global' then
				SetAxes('Local');

			elseif MoveTool.Axes == 'Local' then
				SetAxes('Last');

			elseif MoveTool.Axes == 'Last' then
				SetAxes('Global');
			end;

		-- Check if the - key was pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.Minus or InputInfo.KeyCode == Enum.KeyCode.KeypadMinus then

			-- Focus on the increment input
			if MoveTool.UI then
				MoveTool.UI.IncrementOption.Increment.TextBox:CaptureFocus();
			end;

		-- Check if the R key was pressed down, and it's not the selection clearing hotkey
		elseif InputInfo.KeyCode == Enum.KeyCode.R and not Selection.Multiselecting then

			-- Start tracking snap points nearest to the mouse
			StartSnapping();

		-- Nudge up if the 8 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadEight then
			NudgeSelectionByFace(Enum.NormalId.Top);

		-- Nudge down if the 2 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadTwo then
			NudgeSelectionByFace(Enum.NormalId.Bottom);

		-- Nudge forward if the 9 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadNine then
			NudgeSelectionByFace(Enum.NormalId.Front);

		-- Nudge backward if the 1 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadOne then
			NudgeSelectionByFace(Enum.NormalId.Back);

		-- Nudge left if the 4 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadFour then
			NudgeSelectionByFace(Enum.NormalId.Left);

		-- Nudge right if the 6 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadSix then
			NudgeSelectionByFace(Enum.NormalId.Right);

		-- Align the selection to the current target surface if T is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.T then
			AlignSelectionToTarget();

		end;

	end));

	-- Track ending user input while this tool is equipped
	table.insert(Connections, UserInputService.InputEnded:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this is input from the keyboard
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Check if the R key was let go
		if InputInfo.KeyCode == Enum.KeyCode.R then

			-- Make sure it wasn't pressed while typing
			if UserInputService:GetFocusedTextBox() then
				return;
			end;

			-- Reset handles if not dragging
			if not Dragging then
				SetAxes(MoveTool.Axes);
			end;

			-- Stop snapping point tracking if it was enabled
			SnapTracking.StopTracking();

		end;

	end));

end;

-- Event that fires when new point comes into focus while snapping
local PointSnapped = Core.RbxUtility.CreateSignal();

function StartSnapping()
	-- Starts tracking snap points nearest to the mouse

	-- Hide any handles or bounding boxes
	AttachHandles(nil, true);
	BoundingBox.ClearBoundingBox();

	-- Avoid targeting snap points in selected parts while dragging
	if Dragging then
		SnapTracking.TargetBlacklist = Selection.Items;
	end;

	-- Start tracking the closest snapping point
	SnapTracking.StartTracking(function (NewPoint)

		-- Fire `SnappedPoint` and update `SnappedPoint` when there is a new snap point in focus
		if NewPoint then
			SnappedPoint = NewPoint.p;
			PointSnapped:fire(SnappedPoint);
		end;

	end);

end;

function SetAxisPosition(Axis, Position)
	-- Sets the selection's position on axis `Axis` to `Position`

	-- Track this change
	TrackChange();

	-- Prepare parts to be moved
	local InitialStates = PreparePartsForDragging();

	-- Update each part
	for Part in pairs(InitialStates) do

		-- Set the part's new CFrame
		Part.CFrame = CFrame.new(
			Axis == 'X' and Position or Part.Position.X,
			Axis == 'Y' and Position or Part.Position.Y,
			Axis == 'Z' and Position or Part.Position.Z
		) * (Part.CFrame - Part.CFrame.p);

	end;

	-- Cache up permissions for all private areas
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Revert changes if player is not authorized to move parts to target destination
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialStates) do
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Restore the parts' original states
	for Part, State in pairs(InitialStates) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function NudgeSelectionByFace(Face)
	-- Nudges the selection along the current axes mode in the direction of the focused part's face

	-- Get amount to nudge by
	local NudgeAmount = MoveTool.Increment;

	-- Reverse nudge amount if shift key is held while nudging
	local PressedKeys = Support.FlipTable(Support.GetListMembers(UserInputService:GetKeysPressed(), 'KeyCode'));
	if PressedKeys[Enum.KeyCode.LeftShift] or PressedKeys[Enum.KeyCode.RightShift] then
		NudgeAmount = -NudgeAmount;
	end;

	-- Track this change
	TrackChange();

	-- Prepare parts to be moved
	local InitialState = PreparePartsForDragging();

	-- Perform the movement
	MovePartsAlongAxesByFace(Face, NudgeAmount, MoveTool.Axes, Selection.Focus, InitialState);

	-- Update the "distance moved" indicator
	if MoveTool.UI then
		MoveTool.UI.Changes.Text.Text = 'moved ' .. math.abs(NudgeAmount) .. ' studs';
	end;

	-- Cache up permissions for all private areas
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Revert changes if player is not authorized to move parts to target destination
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialState) do
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Restore the parts' original states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);
		BeforeCFrame = {};
		AfterCFrame = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, CFrame = Record.BeforeCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMove', Changes);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, CFrame = Record.AfterCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMove', Changes);

		end;

	};

	-- Collect the selection's initial state
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.BeforeCFrame[Part] = Part.CFrame;
	end;

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Collect the selection's final state
	local Changes = {};
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.AfterCFrame[Part] = Part.CFrame;
		table.insert(Changes, { Part = Part, CFrame = Part.CFrame });
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncMove', Changes);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

function EnableDragging()
	-- Enables part dragging

	-- Pay attention to when the user intends to start dragging
	Connections.DragStart = Core.Mouse.Button1Down:connect(function ()

		-- Get mouse target
		local TargetPart = Core.Mouse.Target;

		-- Make sure this click was not to select
		if Selection.Multiselecting then
			return;
		end;

		-- Check whether the user is snapping
		local IsSnapping = UserInputService:IsKeyDown(Enum.KeyCode.R) and #Selection.Items > 0;

		-- Make sure target is draggable, unless snapping is ongoing
		if not Core.IsSelectable(TargetPart) and not IsSnapping then
			return;
		end;

		-- Initialize dragging detection data
		DragStartTarget = IsSnapping and Selection.Focus or TargetPart;
		DragStart = Vector2.new(Core.Mouse.X, Core.Mouse.Y);

		-- Select the target if it's not selected, and snapping is not ongoing
		if not Selection.IsSelected(TargetPart) and not IsSnapping then
			Selection.Replace({ TargetPart }, true);
		end;

		-- Watch for potential dragging
		Connections.WatchForDrag = Core.Mouse.Move:connect(function ()

			-- Trigger dragging if the mouse is moved over 2 pixels
			if DragStart and (Vector2.new(Core.Mouse.X, Core.Mouse.Y) - DragStart).magnitude >= 2 then

				-- Prepare for dragging
				BoundingBox.ClearBoundingBox();
				SetUpDragging(DragStartTarget, SnapTracking.Enabled and SnappedPoint or nil);

				-- Disable watching for potential dragging
				ClearConnection 'WatchForDrag';

			end;

		end);

	end);

end;

-- Catch whenever the user finishes dragging
UserInputService.InputEnded:connect(function (InputInfo, GameProcessedEvent)

	-- Make sure this was button 1 being released
	if InputInfo.UserInputType ~= Enum.UserInputType.MouseButton1 then
		return;
	end;

	-- Clean up dragging detection listeners and data
	if DragStart then

		-- Clear dragging detection data
		DragStart = nil;
		DragStartTarget = nil;

		-- Disconnect dragging initiation listeners
		ClearConnection 'WatchForDrag';

	end;

	-- Reset from drag mode if dragging
	if Dragging then

		-- Reset normal axes option state
		SetAxes(MoveTool.Axes);

		-- Finalize the dragging operation
		FinishDragging();

	end;

end);

function SetUpDragging(BasePart, BasePoint)
	-- Sets up and initiates dragging based on the given base part

	-- Prevent selection while dragging
	Core.Targeting.CancelSelecting();

	-- Prepare parts, and start dragging
	InitialState = PreparePartsForDragging();
	StartDragging(BasePart, InitialState, BasePoint);

end;

MoveTool.SetUpDragging = SetUpDragging;

function PreparePartsForDragging()
	-- Prepares parts for dragging and returns the initial state of the parts

	local InitialState = {};

	-- Get index of parts
	local PartIndex = Support.FlipTable(Selection.Items);

	-- Stop parts from moving, and capture the initial state of the parts
	for _, Part in pairs(Selection.Items) do
		InitialState[Part] = { Anchored = Part.Anchored, CanCollide = Part.CanCollide, CFrame = Part.CFrame };
		Part.Anchored = true;
		Part.CanCollide = false;
		InitialState[Part].Joints = Core.PreserveJoints(Part, PartIndex);
		Part:BreakJoints();
		Part.Velocity = Vector3.new();
		Part.RotVelocity = Vector3.new();
	end;

	return InitialState;
end;

function StartDragging(BasePart, InitialState, BasePoint)
	-- Begins dragging the selection

	-- Ensure dragging is not already ongoing
	if Dragging then
		return;
	end;

	-- Indicate that we're dragging
	Dragging = true;

	-- Track changes
	TrackChange();

	-- Disable bounding box calculation
	BoundingBox.ClearBoundingBox();

	-- Cache area permissions information
	local AreaPermissions;
	if Core.Mode == 'Tool' then
		AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);
	end;

	-- Ensure a base part is provided
	if not BasePart or not InitialState[BasePart] then
		return;
	end;

	-- Determine the base point for dragging
	local BasePartOffset = -BasePart.CFrame:pointToObjectSpace(Core.Mouse.Hit.p);

	-- Improve base point alignment for the given increment
	BasePartOffset = Vector3.new(
		math.clamp(GetIncrementMultiple(BasePartOffset.X, MoveTool.Increment), -BasePart.Size.X / 2, BasePart.Size.X / 2),
		math.clamp(GetIncrementMultiple(BasePartOffset.Y, MoveTool.Increment), -BasePart.Size.Y / 2, BasePart.Size.Y / 2),
		math.clamp(GetIncrementMultiple(BasePartOffset.Z, MoveTool.Increment), -BasePart.Size.Z / 2, BasePart.Size.Z / 2)
	);

	-- Use the given base point instead if any
	if BasePoint then
		BasePartOffset = -BasePart.CFrame:pointToObjectSpace(BasePoint);
	end;

	-- Prepare snapping in case it is enabled, and make sure to override its default target selection
	SnapTracking.TargetBlacklist = Selection.Items;
	Connections.DragSnapping = PointSnapped:connect(function (SnappedPoint)

		-- Align the selection's base point to the snapped point
		local Rotation = SurfaceAlignment or (InitialState[BasePart].CFrame - InitialState[BasePart].CFrame.p);
		BasePart.CFrame = CFrame.new(SnappedPoint) * Rotation * CFrame.new(BasePartOffset);
		TranslatePartsRelativeToPart(BasePart, InitialState);

		-- Make sure we're not entering any unauthorized private areas
		if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
			BasePart.CFrame = InitialState[BasePart].CFrame;
			TranslatePartsRelativeToPart(BasePart, InitialState);
		end;

	end);

	-- Update cache of corner offsets for later crossthrough calculations
	CornerOffsets = GetCornerOffsets(InitialState[BasePart].CFrame, InitialState);

	-- Provide a callback to trigger alignment
	TriggerAlignment = function ()

		-- Trigger drag recalculation
		DragToMouse(BasePart, BasePartOffset, InitialState, AreaPermissions);

		-- Trigger snapping recalculation
		if SnapTracking.Enabled then
			PointSnapped:fire(SnappedPoint);
		end;

	end;

	-- Start up the dragging action
	Connections.Drag = Core.Mouse.Move:connect(function ()
		DragToMouse(BasePart, BasePartOffset, InitialState, AreaPermissions);
	end);

end;

-- Cache common functions to avoid unnecessary table lookups
local TableInsert, NewVector3 = table.insert, Vector3.new;

function GetCornerOffsets(Origin, InitialStates)
	-- Calculates and returns the offset of every corner in the initial state from the origin CFrame

	local CornerOffsets = {};

	-- Get offset for origin point
	local OriginOffset = Origin:inverse();

	-- Go through each item in the initial state
	for Item, State in pairs(InitialStates) do
		local ItemCFrame = State.CFrame;
		local SizeX, SizeY, SizeZ = Item.Size.X / 2, Item.Size.Y / 2, Item.Size.Z / 2;

		-- Gather each corner
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(SizeX, SizeY, SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(-SizeX, SizeY, SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(SizeX, -SizeY, SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(SizeX, SizeY, -SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(-SizeX, SizeY, -SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(-SizeX, -SizeY, SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(SizeX, -SizeY, -SizeZ)));
		TableInsert(CornerOffsets, OriginOffset * (ItemCFrame * NewVector3(-SizeX, -SizeY, -SizeZ)));
	end;

	-- Return the offsets
	return CornerOffsets;

end;

function DragToMouse(BasePart, BasePartOffset, InitialState, AreaPermissions)
	-- Drags the selection by `BasePart`, judging area authorization from `AreaPermissions`

	----------------------------------------------
	-- Check what and where the mouse is aiming at
	----------------------------------------------

	-- Don't consider other selected parts possible targets
	local IgnoreList = Support.CloneTable(Selection.Items);
	table.insert(IgnoreList, Core.Player and Core.Player.Character);

	-- Perform the mouse target search
	Target, TargetPoint, TargetNormal = Workspace:FindPartOnRayWithIgnoreList(
		Ray.new(Core.Mouse.UnitRay.Origin, Core.Mouse.UnitRay.Direction * 5000),
		IgnoreList
	);

	-- Reset any surface alignment and calculated crossthrough if target surface changes
	if LastTargetNormal ~= TargetNormal then
		SurfaceAlignment = nil;
		CrossthroughCorrection = nil;
	end;

	-- Reset any calculated crossthrough if selection, drag offset, or surface alignment change
	if (LastSelection ~= Selection.Items) or (LastBasePartOffset ~= BasePartOffset) or (LastSurfaceAlignment ~= SurfaceAlignment) then
		CrossthroughCorrection = nil;
	end;

	-- Save last dragging options for change detection
	LastSelection = Selection.Items;
	LastBasePartOffset = BasePartOffset;
	LastSurfaceAlignment = SurfaceAlignment;
	LastTargetNormal = TargetNormal;

	------------------------------------------------
	-- Move the selection towards any snapped points
	------------------------------------------------

	-- If snapping is enabled, skip regular dragging
	if SnapTracking.Enabled then
		return;
	end;

	------------------------------------------------------
	-- Move the selection towards the right mouse location
	------------------------------------------------------

	-- Get the increment-aligned target point
	TargetPoint = GetAlignedTargetPoint(Target, TargetPoint, TargetNormal);

	-- Move the parts towards their target destination
	local Rotation = SurfaceAlignment or (InitialState[BasePart].CFrame - InitialState[BasePart].CFrame.p);
	local TargetCFrame = CFrame.new(TargetPoint) * Rotation * CFrame.new(BasePartOffset);

	-- Calculate crossthrough against target plane if necessary
	if not CrossthroughCorrection then
		CrossthroughCorrection = 0;

		-- Calculate each corner's tentative position
		for _, CornerOffset in pairs(CornerOffsets) do
			local Corner = TargetCFrame * CornerOffset;

			-- Calculate the corner's target plane crossthrough
			local CornerCrossthrough = -(TargetPoint - Corner):Dot(TargetNormal);

			-- Check if this corner crosses through the most
			if CornerCrossthrough < CrossthroughCorrection then
				CrossthroughCorrection = CornerCrossthrough;
			end;
		end;
	end;

	-- Move the selection, retracted by the max. crossthrough amount
	BasePart.CFrame = TargetCFrame - (TargetNormal * CrossthroughCorrection);
	TranslatePartsRelativeToPart(BasePart, InitialState);

	----------------------------------------
	-- Check for relevant area authorization
	----------------------------------------

	-- Make sure we're not entering any unauthorized private areas
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		BasePart.CFrame = InitialState[BasePart].CFrame;
		TranslatePartsRelativeToPart(BasePart, InitialState);
	end;

end;

function AlignSelectionToTarget()
	-- Aligns the selection to the current target surface while dragging

	-- Ensure dragging is ongoing
	if not Dragging or not TargetNormal then
		return;
	end;

	-- Get target surface normal as arbitrarily oriented CFrame
	local TargetNormalCF = CFrame.new(Vector3.new(), TargetNormal);

	-- Use detected surface normal directly if not targeting a part
	if not Target then
		SurfaceAlignment = TargetNormalCF * CFrame.Angles(-math.pi / 2, 0, 0);

	-- For parts, calculate orientation based on the target surface, and the target part's orientation
	else

		-- Set upward direction to match the target surface normal
		local UpVector, LookVector, RightVector = TargetNormal;

		-- Use target's rightward orientation for calculating orientation (when targeting forward or backward directions)
		if TargetNormal:isClose(Target.CFrame.lookVector, 0.000001) or TargetNormal:isClose(-Target.CFrame.lookVector, 0.000001) then
			LookVector = TargetNormal:Cross(Target.CFrame.rightVector).unit;
			RightVector = LookVector:Cross(TargetNormal).unit;

		-- Use target's forward orientation for calculating orientation (when targeting any other direction)
		else
			RightVector = Target.CFrame.lookVector:Cross(TargetNormal).unit;
			LookVector = TargetNormal:Cross(RightVector).unit;
		end;

		-- Generate rotation matrix based on direction vectors
		SurfaceAlignment = CFrame.new(
			0, 0, 0,
			RightVector.X, UpVector.X, -LookVector.X,
			RightVector.Y, UpVector.Y, -LookVector.Y,
			RightVector.Z, UpVector.Z, -LookVector.Z
		);

	end;

	-- Trigger alignment
	TriggerAlignment();

end;

function GetAlignedTargetPoint(Target, TargetPoint, TargetNormal)
	-- Returns the target point aligned to the nearest increment multiple

	-- By default, use the center of the universe for alignment on all axes
	local ReferencePoint = CFrame.new();
	local PlaneAxes = Vector3.new(1, 1, 1);

	-----------------------------------------------------------------------------
	-- Detect appropriate reference points and plane axes for recognized surfaces
	-----------------------------------------------------------------------------

	-- Make sure the target is a part
	if Target and Target:IsA 'BasePart' and Target.ClassName ~= 'Terrain' then
		local Size = Target.Size / 2;

		-- Calculate the direction of a wedge surface
		local WedgeDirection = (Target.CFrame - Target.CFrame.p) *
			CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), math.atan(Target.Size.Z / Target.Size.Y));

		-- Calculate the direction of a corner part's Z-axis surface
		local CornerDirectionZ = (Target.CFrame - Target.CFrame.p) *
			CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), math.pi - math.atan(Target.Size.Z / Target.Size.Y));

		-- Calculate the direction of a corner part's X-axis surface
		local CornerDirectionX = (Target.CFrame - Target.CFrame.p) *
			CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.Z), math.atan(Target.Size.Y / Target.Size.X)) *
			CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), math.pi / 2) *
			CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.Z), -math.pi / 2);

		-- Get the right alignment reference point on a part's front surface
		if TargetNormal:isClose(Target.CFrame.lookVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z);
			PlaneAxes = Vector3.new(1, 1, 0);

		-- Get the right alignment reference point on a part's back surface
		elseif TargetNormal:isClose(-Target.CFrame.lookVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z);
			PlaneAxes = Vector3.new(1, 1, 0);

		-- Get the right alignment reference point on a part's left surface
		elseif TargetNormal:isClose(-Target.CFrame.rightVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z);
			PlaneAxes = Vector3.new(0, 1, 1);

		-- Get the right alignment reference point on a part's right surface
		elseif TargetNormal:isClose(Target.CFrame.rightVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(Size.X, Size.Y, Size.Z);
			PlaneAxes = Vector3.new(0, 1, 1);

		-- Get the right alignment reference point on a part's upper surface
		elseif TargetNormal:isClose(Target.CFrame.upVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(Size.X, Size.Y, Size.Z);
			PlaneAxes = Vector3.new(1, 0, 1);

		-- Get the right alignment reference point on a part's bottom surface
		elseif TargetNormal:isClose(-Target.CFrame.upVector, 0.000001) then
			ReferencePoint = Target.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z);
			PlaneAxes = Vector3.new(1, 0, 1);

		-- Get the right alignment reference point on wedged part surfaces
		elseif TargetNormal:isClose(WedgeDirection.lookVector, 0.000001) then

			-- Get reference point oriented to wedge plane
			ReferencePoint = WedgeDirection *
				CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), -math.pi / 2) +
				(Target.CFrame * Vector3.new(Size.X, Size.Y, Size.Z));

			-- Set plane offset axes
			PlaneAxes = Vector3.new(1, 0, 1);

		-- Get the right alignment reference point on the Z-axis surface of a corner part
		elseif TargetNormal:isClose(CornerDirectionZ.lookVector, 0.000001) then

			-- Get reference point oriented to wedged plane
			ReferencePoint = CornerDirectionZ *
				CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), -math.pi / 2) +
				(Target.CFrame * Vector3.new(-Size.X, Size.Y, -Size.Z));

			-- Set plane offset axes
			PlaneAxes = Vector3.new(1, 0, 1);

		-- Get the right alignment reference point on the X-axis surface of a corner part
		elseif TargetNormal:isClose(CornerDirectionX.lookVector, 0.000001) then

			-- Get reference point oriented to wedged plane
			ReferencePoint = CornerDirectionX *
				CFrame.fromAxisAngle(Vector3.FromAxis(Enum.Axis.X), -math.pi / 2) +
				(Target.CFrame * Vector3.new(Size.X, Size.Y, -Size.Z));

			-- Set plane offset axes
			PlaneAxes = Vector3.new(1, 0, 1);

		-- Return an unaligned point for unrecognized surfaces
		else
			return TargetPoint;
		end;

	end;

	-------------------------------------
	-- Calculate the aligned target point
	-------------------------------------

	-- Get target point offset from reference point
	local ReferencePointOffset = ReferencePoint:inverse() * CFrame.new(TargetPoint);

	-- Align target point on increment grid from reference point along the plane axes
	local AlignedTargetPoint = ReferencePoint * (Vector3.new(
		GetIncrementMultiple(ReferencePointOffset.X, MoveTool.Increment),
		GetIncrementMultiple(ReferencePointOffset.Y, MoveTool.Increment),
		GetIncrementMultiple(ReferencePointOffset.Z, MoveTool.Increment)
	) * PlaneAxes);

	-- Return the aligned target point
	return AlignedTargetPoint;

end;

function GetIncrementMultiple(Number, Increment)

	-- Get how far the actual distance is from a multiple of our increment
	local MultipleDifference = Number % Increment;

	-- Identify the closest lower and upper multiples of the increment 
	local LowerMultiple = Number - MultipleDifference;
	local UpperMultiple = Number - MultipleDifference + Increment;

	-- Calculate to which of the two multiples we're closer
	local LowerMultipleProximity = math.abs(Number - LowerMultiple);
	local UpperMultipleProximity = math.abs(Number - UpperMultiple);

	-- Use the closest multiple of our increment as the distance moved
	if LowerMultipleProximity <= UpperMultipleProximity then
		Number = LowerMultiple;
	else
		Number = UpperMultiple;
	end;

	return Number;
end;

function TranslatePartsRelativeToPart(BasePart, InitialStates)
	-- Moves the given parts in `InitialStates` to BasePart's current position, with their original offset from it

	-- Get focused part's position for offsetting
	local RelativeTo = InitialStates[BasePart].CFrame:inverse();

	-- Calculate offset and move each part
	for Part, InitialState in pairs(InitialStates) do

		-- Calculate how far apart we should be from the focused part
		local Offset = RelativeTo * InitialState.CFrame;

		-- Move relative to the focused part by this part's offset from it
		Part.CFrame = BasePart.CFrame * Offset;

	end;

end;

function FinishDragging()
	-- Releases parts and registers position changes from dragging

	-- Make sure dragging is active
	if not Dragging then
		return;
	end;

	-- Indicate that we're no longer dragging
	Dragging = false;

	-- Clear any surface alignment
	SurfaceAlignment = nil;

	-- Stop the dragging action
	ClearConnection 'Drag';

	-- Stop, clean up snapping point tracking
	SnapTracking.StopTracking();
	ClearConnection 'DragSnapping';

	-- Restore the original state of each part
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register changes
	RegisterChange();

end;

-- Return the tool
return MoveTool;
end;
};
G2L_MODULES[G2L["3d"]] = {
Closure = function()
    local script = G2L["3d"];Tool = script.Parent.Parent;
Core = require(Tool.Core);
SnapTracking = require(Tool.SnappingModule);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local ResizeTool = {

	Name = 'Resize Tool';
	Color = BrickColor.new 'Cyan';

	-- Default options
	Increment = 1;
	Directions = 'Normal';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function ResizeTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	ShowHandles();
	BindShortcutKeys();

end;

function ResizeTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	HideHandles();
	ClearConnections();
	SnapTracking.StopTracking();
	FinishSnapping();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ClearConnection(ConnectionKey)
	-- Clears the given specific connection

	local Connection = Connections[ConnectionKey];

	-- Disconnect the connection if it exists
	if Connection then
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if ResizeTool.UI then

		-- Reveal the UI
		ResizeTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	ResizeTool.UI = Core.Tool.Interfaces.BTResizeToolGUI:Clone();
	ResizeTool.UI.Parent = Core.UI;
	ResizeTool.UI.Visible = true;

	-- Add functionality to the directions option switch
	local DirectionsSwitch = ResizeTool.UI.DirectionsOption;
	DirectionsSwitch.Normal.Button.MouseButton1Down:connect(function ()
		SetDirections('Normal');
	end);
	DirectionsSwitch.Both.Button.MouseButton1Down:connect(function ()
		SetDirections('Both');
	end);

	-- Add functionality to the increment input
	local IncrementInput = ResizeTool.UI.IncrementOption.Increment.TextBox;
	IncrementInput.FocusLost:connect(function (EnterPressed)
		ResizeTool.Increment = tonumber(IncrementInput.Text) or ResizeTool.Increment;
		IncrementInput.Text = Support.Round(ResizeTool.Increment, 4);
	end);

	-- Add functionality to the size inputs
	local XInput = ResizeTool.UI.Info.SizeInfo.X.TextBox;
	local YInput = ResizeTool.UI.Info.SizeInfo.Y.TextBox;
	local ZInput = ResizeTool.UI.Info.SizeInfo.Z.TextBox;
	XInput.FocusLost:connect(function (EnterPressed)
		local NewSize = tonumber(XInput.Text);
		if NewSize then
			SetAxisSize('X', NewSize);
		end;
	end);
	YInput.FocusLost:connect(function (EnterPressed)
		local NewSize = tonumber(YInput.Text);
		if NewSize then
			SetAxisSize('Y', NewSize);
		end;
	end);
	ZInput.FocusLost:connect(function (EnterPressed)
		local NewSize = tonumber(ZInput.Text);
		if NewSize then
			SetAxisSize('Z', NewSize);
		end;
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not ResizeTool.UI then
		return;
	end;

	-- Hide the UI
	ResizeTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not ResizeTool.UI then
		return;
	end;

	-- Only show and calculate selection info if it's not empty
	if #Selection.Items == 0 then
		ResizeTool.UI.Info.Visible = false;
		ResizeTool.UI.Size = UDim2.new(0, 245, 0, 90);
		return;
	else
		ResizeTool.UI.Info.Visible = true;
		ResizeTool.UI.Size = UDim2.new(0, 245, 0, 150);
	end;

	-----------------------------------------
	-- Update the size information indicators
	-----------------------------------------

	-- Identify common sizes across axes
	local XVariations, YVariations, ZVariations = {}, {}, {};
	for _, Part in pairs(Selection.Items) do
		table.insert(XVariations, Support.Round(Part.Size.X, 3));
		table.insert(YVariations, Support.Round(Part.Size.Y, 3));
		table.insert(ZVariations, Support.Round(Part.Size.Z, 3));
	end;
	local CommonX = Support.IdentifyCommonItem(XVariations);
	local CommonY = Support.IdentifyCommonItem(YVariations);
	local CommonZ = Support.IdentifyCommonItem(ZVariations);

	-- Shortcuts to indicators
	local XIndicator = ResizeTool.UI.Info.SizeInfo.X.TextBox;
	local YIndicator = ResizeTool.UI.Info.SizeInfo.Y.TextBox;
	local ZIndicator = ResizeTool.UI.Info.SizeInfo.Z.TextBox;

	-- Update each indicator if it's not currently being edited
	if not XIndicator:IsFocused() then
		XIndicator.Text = CommonX or '*';
	end;
	if not YIndicator:IsFocused() then
		YIndicator.Text = CommonY or '*';
	end;
	if not ZIndicator:IsFocused() then
		ZIndicator.Text = CommonZ or '*';
	end;

end;

function SetDirections(DirectionMode)
	-- Sets the given resizing direction mode

	-- Update setting
	ResizeTool.Directions = DirectionMode;

	-- Update the UI switch
	if ResizeTool.UI then
		Core.ToggleSwitch(DirectionMode, ResizeTool.UI.DirectionsOption);
	end;

end;

-- Directions of resizing for each handle's dragged face
local AxisSizeMultipliers = {
	[Enum.NormalId.Top] = Vector3.new(0, 1, 0);
	[Enum.NormalId.Bottom] = Vector3.new(0, 1, 0);
	[Enum.NormalId.Front] = Vector3.new(0, 0, 1);
	[Enum.NormalId.Back] = Vector3.new(0, 0, 1);
	[Enum.NormalId.Left] = Vector3.new(1, 0, 0);
	[Enum.NormalId.Right] = Vector3.new(1, 0, 0);
};

-- Directions of positioning adjustment for each handle's dragged face
local AxisPositioningMultipliers = {
	[Enum.NormalId.Top] = Vector3.new(0, 1, 0);
	[Enum.NormalId.Bottom] = Vector3.new(0, -1, 0);
	[Enum.NormalId.Front] = Vector3.new(0, 0, -1);
	[Enum.NormalId.Back] = Vector3.new(0, 0, 1);
	[Enum.NormalId.Left] = Vector3.new(-1, 0, 0);
	[Enum.NormalId.Right] = Vector3.new(1, 0, 0);
};

-- Axis names corresponding to each face
local FaceAxisNames = {
	[Enum.NormalId.Top] = 'Y';
	[Enum.NormalId.Bottom] = 'Y';
	[Enum.NormalId.Front] = 'Z';
	[Enum.NormalId.Back] = 'Z';
	[Enum.NormalId.Left] = 'X';
	[Enum.NormalId.Right] = 'X';
};

function ShowHandles()
	-- Creates and automatically attaches handles to the currently focused part

	-- Autofocus handles on latest focused part
	if not Connections.AutofocusHandle then
		Connections.AutofocusHandle = Selection.FocusChanged:connect(ShowHandles);
	end;

	-- If handles already exist, only show them
	if Handles then
		Handles.Adornee = Selection.Focus;
		Handles.Visible = true;
		Handles.Parent = Selection.Focus and Core.UIContainer or nil;
		return;
	end;

	-- Create the handles
	Handles = Create 'Handles' {
		Name = 'BTResizingHandles';
		Color = ResizeTool.Color;
		Parent = Core.UIContainer;
		Adornee = Selection.Focus;
	};

	--------------------------------------------------------
	-- Prepare for resizing parts when the handle is clicked
	--------------------------------------------------------

	local AreaPermissions;

	Handles.MouseButton1Down:connect(function ()

		-- Prevent selection
		Core.Targeting.CancelSelecting();

		-- Indicate resizing via handles
		HandleResizing = true;

		-- Stop parts from moving, and capture the initial state of the parts
		InitialState = PreparePartsForResizing();

		-- Track the change
		TrackChange();

		-- Cache area permissions information
		if Core.Mode == 'Tool' then
			AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);
		end;

	end);

	------------------------------------------
	-- Update parts when the handles are moved
	------------------------------------------

	Handles.MouseDrag:connect(function (Face, Distance)

		-- Only resize if handle is enabled
		if not HandleResizing then
			return;
		end;

		-- Calculate the increment-aligned drag distance
		Distance = GetIncrementMultiple(Distance, ResizeTool.Increment);

		-- Resize the parts on the selected faces by the calculated distance
		local Success, Adjustment = ResizePartsByFace(Face, Distance, ResizeTool.Directions, InitialState);

		-- If the resizing did not succeed, resize according to the suggested adjustment
		if not Success then
			ResizePartsByFace(Face, Adjustment, ResizeTool.Directions, InitialState);
		end;

		-- Update the "studs resized" indicator
		if ResizeTool.UI then
			ResizeTool.UI.Changes.Text.Text = 'resized ' .. Support.Round(math.abs(Adjustment or Distance), 3) .. ' studs';
		end;

		-- Make sure we're not entering any unauthorized private areas
		if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
			for Part, State in pairs(InitialState) do
				Part.Size = State.Size;
				Part.CFrame = State.CFrame;
			end;
		end;

	end);

end;


-- Finalize changes to parts when the handle is let go
Support.AddUserInputListener('Ended', 'MouseButton1', true, function (Input)

	-- Ensure handle resizing is ongoing
	if not HandleResizing then
		return;
	end;

	-- Disable resizing
	HandleResizing = false;

	-- Prevent selection
	Core.Targeting.CancelSelecting();

	-- Clear this connection to prevent it from firing again
	ClearConnection 'HandleRelease';

	-- Make joints, restore original anchor and collision states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end);

function HideHandles()
	-- Hides the resizing handles

	-- Make sure handles exist and are visible
	if not Handles or not Handles.Visible then
		return;
	end;

	-- Hide the handles
	Handles.Visible = false;
	Handles.Parent = nil;

	-- Clear unnecessary resources
	ClearConnection 'AutofocusHandle';

end;

function ResizePartsByFace(Face, Distance, Directions, InitialStates)
	-- Resizes the selection on face `Face` by `Distance` studs, in the given `Directions`

	-- Adjust the size increment to the resizing direction mode
	if Directions == 'Both' then
		Distance = Distance * 2;
	end;

	-- Calculate the increment vector for this resizing
	local AxisSizeMultiplier = AxisSizeMultipliers[Face];
	local IncrementVector = Distance * AxisSizeMultiplier;

	-- Get name of axis the resize will occur on
	local AxisName = FaceAxisNames[Face];

	-- Check for any potential undersizing or oversizing
	local ShortestSize, ShortestPart, LongestSize, LongestPart;
	for Part, InitialState in pairs(InitialStates) do

		-- Calculate target size for this resize
		local TargetSize = InitialState.Size[AxisName] + Distance;

		-- If target size is under 0.05, note if it's the shortest size
		if TargetSize < 0.049999 and (not ShortestSize or (ShortestSize and TargetSize < ShortestSize)) then
			ShortestSize, ShortestPart = TargetSize, Part;

		-- If target size is over 2048, note if it's the longest size
		elseif TargetSize > 2048 and (not LongestSize or (LongestSize and TargetSize > LongestSize)) then
			LongestSize, LongestPart = TargetSize, Part;
		end;

	end;

	-- Return adjustment for undersized parts (snap to lowest possible valid increment multiple)
	if ShortestSize then
		local InitialSize = InitialStates[ShortestPart].Size[AxisName];
		local TargetSize = InitialSize - ResizeTool.Increment * tonumber((tostring((InitialSize - 0.05) / ResizeTool.Increment):gsub('%..+', '')));
		return false, Distance + TargetSize - ShortestSize;
	end;

	-- Return adjustment for oversized parts (snap to highest possible valid increment multiple)
	if LongestSize then
		local TargetSize = ResizeTool.Increment * tonumber((tostring(2048 / ResizeTool.Increment):gsub('%..+', '')));
		return false, Distance + TargetSize - LongestSize;
	end;

	-- Resize each part
	for Part, InitialState in pairs(InitialStates) do

		-- Perform the size change depending on shape
		if Part:IsA 'Part' then

			-- Resize spheres on all axes
			if Part.Shape == Enum.PartType.Ball then
				Part.Size = InitialState.Size + Vector3.new(Distance, Distance, Distance);

			-- Resize cylinders on both Y & Z axes for circle sides
			elseif Part.Shape == Enum.PartType.Cylinder and AxisName ~= 'X' then
				Part.Size = InitialState.Size + Vector3.new(0, Distance, Distance);

			-- Resize block parts and cylinder lengths normally
			else
				Part.Size = InitialState.Size + IncrementVector;
			end;

		-- Perform the size change normally on all other parts
		else
			Part.Size = InitialState.Size + IncrementVector;
		end;

		-- Offset the part when resizing in the normal, one direction
		if Directions == 'Normal' then
			Part.CFrame = InitialState.CFrame * CFrame.new(AxisPositioningMultipliers[Face] * Distance / 2);

		-- Keep the part centered when resizing in both directions
		elseif Directions == 'Both' then
			Part.CFrame = InitialState.CFrame;

		end;

	end;

	-- Indicate that the resizing happened successfully
	return true;
end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Toggle the current directions mode
			if ResizeTool.Directions == 'Normal' then
				SetDirections('Both');

			elseif ResizeTool.Directions == 'Both' then
				SetDirections('Normal');
			end;

		-- Check if the - key was pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.Minus or InputInfo.KeyCode == Enum.KeyCode.KeypadMinus then

			-- Focus on the increment input
			if ResizeTool.UI then
				ResizeTool.UI.IncrementOption.Increment.TextBox:CaptureFocus();
			end;

		-- Nudge up if the 8 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadEight then
			NudgeSelectionByFace(Enum.NormalId.Top);

		-- Nudge down if the 2 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadTwo then
			NudgeSelectionByFace(Enum.NormalId.Bottom);

		-- Nudge forward if the 9 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadNine then
			NudgeSelectionByFace(Enum.NormalId.Front);

		-- Nudge backward if the 1 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadOne then
			NudgeSelectionByFace(Enum.NormalId.Back);

		-- Nudge left if the 4 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadFour then
			NudgeSelectionByFace(Enum.NormalId.Left);

		-- Nudge right if the 6 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadSix then
			NudgeSelectionByFace(Enum.NormalId.Right);

		-- Start snapping when the R key is pressed down, and it's not the selection clearing hotkey
		elseif InputInfo.KeyCode == Enum.KeyCode.R and not Selection.Multiselecting then
			StartSnapping();

		end;

	end));

	-- Track ending user input while this tool is equipped
	table.insert(Connections, UserInputService.InputEnded:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this is input from the keyboard
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Finish snapping when the R key is released, and it's not the selection clearing hotkey
		if InputInfo.KeyCode == Enum.KeyCode.R and not Selection.Multiselecting then
			FinishSnapping();

		end;

	end));

end;

function SetAxisSize(Axis, Size)
	-- Sets the selection's size on axis `Axis` to `Size`

	-- Track this change
	TrackChange();

	-- Prepare parts to be resized
	local InitialStates = PreparePartsForResizing();

	-- Update each part
	for Part, InitialState in pairs(InitialStates) do

		-- Set the part's new size
		Part.Size = Vector3.new(
			Axis == 'X' and Size or Part.Size.X,
			Axis == 'Y' and Size or Part.Size.Y,
			Axis == 'Z' and Size or Part.Size.Z
		);

		-- Keep the part in place
		Part.CFrame = InitialState.CFrame;

	end;

	-- Cache up permissions for all private areas
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Revert changes if player is not authorized to resize parts towards the end destination
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialStates) do
			Part.Size = State.Size;
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Restore the parts' original states
	for Part, State in pairs(InitialStates) do
		Part:MakeJoints();
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function NudgeSelectionByFace(Face)
	-- Nudges the size of the selection in the direction of the given face

	-- Get amount to nudge by
	local NudgeAmount = ResizeTool.Increment;

	-- Reverse nudge amount if shift key is held while nudging
	local PressedKeys = Support.FlipTable(Support.GetListMembers(UserInputService:GetKeysPressed(), 'KeyCode'));
	if PressedKeys[Enum.KeyCode.LeftShift] or PressedKeys[Enum.KeyCode.RightShift] then
		NudgeAmount = -NudgeAmount;
	end;

	-- Track this change
	TrackChange();

	-- Prepare parts to be resized
	local InitialState = PreparePartsForResizing();

	-- Perform the resizing
	local Success, Adjustment = ResizePartsByFace(Face, NudgeAmount, ResizeTool.Directions, InitialState);

	-- If the resizing did not succeed, resize according to the suggested adjustment
	if not Success then
		ResizePartsByFace(Face, Adjustment, ResizeTool.Directions, InitialState);
	end;

	-- Update "studs resized" indicator
	if ResizeTool.UI then
		ResizeTool.UI.Changes.Text.Text = 'resized ' .. Support.Round(Adjustment or NudgeAmount, 3) .. ' studs';
	end;

	-- Cache up permissions for all private areas
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Revert changes if player is not authorized to resize parts towards the end destination
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialState) do
			Part.Size = State.Size;
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Restore the parts' original states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);
		BeforeSize = {};
		AfterSize = {};
		BeforeCFrame = {};
		AfterCFrame = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Size = Record.BeforeSize[Part], CFrame = Record.BeforeCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncResize', Changes);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Size = Record.AfterSize[Part], CFrame = Record.AfterCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncResize', Changes);

		end;

	};

	-- Collect the selection's initial state
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.BeforeSize[Part] = Part.Size;
		HistoryRecord.BeforeCFrame[Part] = Part.CFrame;
	end;

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Collect the selection's final state
	local Changes = {};
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.AfterSize[Part] = Part.Size;
		HistoryRecord.AfterCFrame[Part] = Part.CFrame;
		table.insert(Changes, { Part = Part, Size = Part.Size, CFrame = Part.CFrame });
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncResize', Changes);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

function PreparePartsForResizing()
	-- Prepares parts for resizing and returns the initial state of the parts

	local InitialState = {};

	-- Stop parts from moving, and capture the initial state of the parts
	for _, Part in pairs(Selection.Items) do
		InitialState[Part] = { Anchored = Part.Anchored, CanCollide = Part.CanCollide, Size = Part.Size, CFrame = Part.CFrame };
		Part.Anchored = true;
		Part.CanCollide = false;
		Part:BreakJoints();
		Part.Velocity = Vector3.new();
		Part.RotVelocity = Vector3.new();
	end;

	return InitialState;
end;

function GetIncrementMultiple(Number, Increment)

	-- Get how far the actual distance is from a multiple of our increment
	local MultipleDifference = Number % Increment;

	-- Identify the closest lower and upper multiples of the increment
	local LowerMultiple = Number - MultipleDifference;
	local UpperMultiple = Number - MultipleDifference + Increment;

	-- Calculate to which of the two multiples we're closer
	local LowerMultipleProximity = math.abs(Number - LowerMultiple);
	local UpperMultipleProximity = math.abs(Number - UpperMultiple);

	-- Use the closest multiple of our increment as the distance moved
	if LowerMultipleProximity <= UpperMultipleProximity then
		Number = LowerMultiple;
	else
		Number = UpperMultiple;
	end;

	return Number;
end;

-- Event that fires when a new point is snapped
PointSnapped = Core.RbxUtility.CreateSignal();

function StartSnapping()

	-- Make sure snapping isn't already enabled
	if SnappingStage or SnapTracking.Enabled then
		return;
	end;

	-- Start first snapping stage
	SnappingStage = 'Starting';

	-- Only enable corner snapping
	SnapTracking.TrackEdgeMidpoints = false;
	SnapTracking.TrackFaceCentroids = false;
	SnapTracking.TargetFilter = Selection.IsSelected;

	-- Trigger the PointSnapped event when a new point is snapped
	SnapTracking.StartTracking(function (NewPoint)
		if NewPoint and NewPoint.p ~= SnappedPoint then
			SnappedPoint = NewPoint.p;
			PointSnapped:fire(NewPoint.p);
		end;
	end);

	-- Listen for when the user starts dragging while in snap mode
	Connections.SnapDragStart = Support.AddUserInputListener('Began', 'MouseButton1', false, function (Input)

		-- Initialize snapping state
		SnappingStage = 'Direction';
		SnappingStartAim = Vector2.new(Input.Position.X, Input.Position.Y);
		SnappingStartPoint = SnappedPoint;
		SnappingStartTarget = SnapTracking.Target;
		SnappingStartDirections = GetFaceOffsetsFromCorner(SnappingStartTarget, SnappingStartPoint);
		SnappingStartSelectionState = PreparePartsForResizing();
		AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

		-- Pause snapping
		SnapTracking.StopTracking();

		-- Start a direction line
		DirectionLine = Core.Tool.Interfaces.SnapLine:Clone();
		DirectionLine.Parent = Core.UI;
		DirectionLine.Visible = false;

		-- Track changes for history
		TrackChange();

		-- Listen for when the user drags
		Connections.SnapDrag = Support.AddUserInputListener('Changed', 'MouseMovement', true, function (Input)

			-- Update the latest aim
			SnappingEndAim = Vector2.new(Input.Position.X, Input.Position.Y);
			ScreenSnappedPoint = Workspace.CurrentCamera:WorldToScreenPoint(SnappingStartPoint);
			ScreenSnappedPoint = Vector2.new(ScreenSnappedPoint.X, ScreenSnappedPoint.Y);

			-- Calculate direction setting length
			local DirectionSettingLength = math.min(50, math.max(50, (SnappingStartAim - ScreenSnappedPoint).magnitude * 1.5));

			-- Use the mouse position to figure out the resize direction (until after direction setting length)
			if SnappingStage == 'Direction' then

				-- Get current angle from snap point
				local DragAngle = math.deg(math.atan2(SnappingEndAim.Y - ScreenSnappedPoint.Y, SnappingEndAim.X - ScreenSnappedPoint.X));
				DragAngle = (DragAngle > 0) and (DragAngle - 360) or DragAngle;

				-- Go through corner offsets representing the possible directions
				local Directions = {};
				for _, Direction in pairs(SnappingStartDirections) do

					-- Map the corner & corner offset to screen points
					local ScreenOffsetPoint = Workspace.CurrentCamera:WorldToScreenPoint(Direction.Offset);

					-- Get direction angle from snap point
					local DirectionAngle = math.deg(math.atan2(ScreenOffsetPoint.Y - ScreenSnappedPoint.Y, ScreenOffsetPoint.X - ScreenSnappedPoint.X));
					DirectionAngle = (DirectionAngle > 0) and (DirectionAngle - 360) or DirectionAngle;

					-- Calculate delta between drag and direction angles
					local AngleDelta = math.abs(DragAngle - DirectionAngle) % 180;
					AngleDelta = (AngleDelta > 90) and (180 - AngleDelta) or AngleDelta;

					-- Insert the potential direction
					table.insert(Directions, {
						Face = Direction.Face,
						AngleDelta = AngleDelta,
						DirectionAngle = DirectionAngle,
						Offset = Direction.Offset
					});

				end;

				-- Get the direction most similar to the dragging angle
				table.sort(Directions, function (A, B)
					return A.AngleDelta < B.AngleDelta;
				end);

				-- Center direction line at snap point
				DirectionLine.Position = UDim2.new(0, ScreenSnappedPoint.X, 0, ScreenSnappedPoint.Y);

				-- Orient direction line towards drag direction
				if math.abs(DragAngle - Directions[1].DirectionAngle) <= 90 then
					DirectionLine.Rotation = Directions[1].DirectionAngle;
				else
					DirectionLine.Rotation = 180 + Directions[1].DirectionAngle;
				end;

				-- Show the direction line
				DirectionLine.PointMarker.Rotation = -DirectionLine.Rotation;
				DirectionLine.SnapProgress.Size = UDim2.new(0, DirectionSettingLength, 2, 0);
				DirectionLine.Visible = true;

				-- Check if drag has passed direction setting length
				local Length = (SnappingEndAim - ScreenSnappedPoint).magnitude;
				if Length < DirectionSettingLength then
					return;
				end;

				-- Clear the direction line
				DirectionLine:Destroy()

				-- Select the resizing direction that was closest to the mouse drag
				SnappingDirection = Directions[1].Face;
				SnappingDirectionOffset = Directions[1].Offset;

				-- Move to the destination-picking stage of snapping
				SnappingStage = 'Destination';

				-- Set destination-stage snapping options
				SnapTracking.TrackEdgeMidpoints = true;
				SnapTracking.TrackFaceCentroids = true;
				SnapTracking.TargetFilter = function (Target) return not Target.Locked; end;
				SnapTracking.TargetBlacklist = Selection.Items;

				-- Start a distance alignment line
				AlignmentLine = Core.Tool.Interfaces.SnapLineSegment:Clone();
				AlignmentLine.Visible = false;
				AlignmentLine.Parent = Core.UI;

				-- Re-enable snapping to select destination
				SnapTracking.StartTracking(function (NewPoint)
					if NewPoint and NewPoint.p ~= SnappedPoint then
						SnappedPoint = NewPoint.p;
						PointSnapped:fire(NewPoint.p);
					end;
				end);

			end;

		end);

		-- Listen for when a new point is snapped
		Connections.Snap = PointSnapped:connect(function (SnappedPoint)

			-- Resize to snap point if in the destination stage of snapping
			if SnappingStage == 'Destination' then

				-- Calculate direction and distance to resize towards
				local Direction = (SnappingDirectionOffset - SnappingStartPoint).unit;
				local Distance = (SnappedPoint - SnappingStartPoint):Dot(Direction);

				-- Resize the parts on the selected faces by the calculated distance
				local Success = ResizePartsByFace(SnappingDirection, Distance, 'Normal', SnappingStartSelectionState);

				-- Update the UI on resize success
				if Success then

					-- Update "studs resized" indicator
					if ResizeTool.UI then
						ResizeTool.UI.Changes.Text.Text = 'resized ' .. Support.Round(Distance, 3) .. ' studs';
					end;

					-- Get snap point and destination point screen positions for UI alignment
					local ScreenStartPoint = Workspace.CurrentCamera:WorldToScreenPoint(SnappingStartPoint + (Direction * Distance));
					ScreenStartPoint = Vector2.new(ScreenStartPoint.X, ScreenStartPoint.Y);
					local ScreenDestinationPoint = Workspace.CurrentCamera:WorldToScreenPoint(SnappedPoint);
					ScreenDestinationPoint = Vector2.new(ScreenDestinationPoint.X, ScreenDestinationPoint.Y)

					-- Update the distance alignment line
					local AlignmentAngle = math.deg(math.atan2(ScreenDestinationPoint.Y - ScreenStartPoint.Y, ScreenDestinationPoint.X - ScreenStartPoint.X));
					local AlignmentCenter = ScreenStartPoint:Lerp(ScreenDestinationPoint, 0.5);
					AlignmentLine.Position = UDim2.new(0, AlignmentCenter.X, 0, AlignmentCenter.Y);
					AlignmentLine.Rotation = AlignmentAngle;
					AlignmentLine.Size = UDim2.new(0, (ScreenDestinationPoint - ScreenStartPoint).magnitude, 0, 1);
					AlignmentLine.PointMarkerA.Rotation = -AlignmentAngle;
					AlignmentLine.Visible = true;

				end;

				-- Make sure we're not entering any unauthorized private areas
				if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
					for Part, State in pairs(SnappingStartSelectionState) do
						Part.Size = State.Size;
						Part.CFrame = State.CFrame;
					end;
				end;

			end;

		end);

	end);

end;

-- Stop snapping whenever mouse is released
Support.AddUserInputListener('Ended', 'MouseButton1', true, function (Input)

	-- Ensure snapping is ongoing
	if not SnappingStage then
		return;
	end;

	-- Finish snapping
	FinishSnapping();

end);


function FinishSnapping()
	-- Cleans up and finalizes the snapping operation

	-- Ensure snapping is ongoing
	if not SnappingStage then
		return;
	end;

	-- Restore the selection's original state if stage was reached
	if SnappingStartSelectionState then
		for Part, State in pairs(SnappingStartSelectionState) do
			Part:MakeJoints();
			Part.CanCollide = State.CanCollide;
			Part.Anchored = State.Anchored;
		end;
	end;

	-- Disable any snapping stage
	SnappingStage = nil;

	-- Stop snap point tracking
	SnapTracking.StopTracking();

	-- Clear any UI
	if DirectionLine then
		DirectionLine:Destroy();
		DirectionLine = nil;
	end;
	if AlignmentLine then
		AlignmentLine:Destroy();
		AlignmentLine = nil;
	end;

	-- Register any change
	if HistoryRecord then
		RegisterChange();
	end;

	-- Disconnect snapping listeners
	ClearConnection 'SnapDragStart';
	ClearConnection 'SnapDrag';
	ClearConnection 'Snap';
	ClearConnection 'SnapDragEnd';

end;


function GetFaceOffsetsFromCorner(Part, Point)
	-- Returns offsets of the given corner point in the direction of its intersecting faces

	local Offsets = {};

	-- Go through each face the corner intersects
	local Faces = GetFacesFromCorner(Part, Point);
	for _, Face in pairs(Faces) do

		-- Calculate the offset from the corner in the direction of the face
		local FaceOffset = (Vector3.FromNormalId(Face) * Part.Size) / 2;
		local Offset = CFrame.new(Point) * CFrame.Angles(Part.CFrame:toEulerAnglesXYZ()) * FaceOffset;
		table.insert(Offsets, { Face = Face, Offset = Offset });

	end;

	-- Return the list of offsets
	return Offsets;
end;

function GetFacesFromCorner(Part, Point)
	-- Returns the 3 faces that the given corner point intersects

	local Faces = {};

	-- Get all the face centers of the part
	for _, FaceEnum in pairs(Enum.NormalId:GetEnumItems()) do
		local Face = Part.CFrame * (Part.Size / 2 * Vector3.FromNormalId(FaceEnum));

		-- Get the face's proximity to the point
		local Proximity = (Point - Face).magnitude;

		-- Keep track of the proximity to the point
		table.insert(Faces, { Proximity = Proximity, Face = FaceEnum });
	end;

	-- Find the closest faces to the point
	table.sort(Faces, function (A, B)
		return A.Proximity < B.Proximity;
	end);

	-- Return the 3 closest faces
	return { Faces[1].Face, Faces[2].Face, Faces[3].Face };
end;

-- Return the tool
return ResizeTool;
end;
};
G2L_MODULES[G2L["3e"]] = {
Closure = function()
    local script = G2L["3e"];Tool = script.Parent.Parent;
Core = require(Tool.Core);
SnapTracking = require(Tool.SnappingModule);
BoundingBox = require(Tool.BoundingBoxModule);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local RotateTool = {

	Name = 'Rotate Tool';
	Color = BrickColor.new 'Bright green';

	-- Default options
	Increment = 15;
	Pivot = 'Center';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function RotateTool.Equip()
	-- Enables the tool's equipped functionality

	-- Set our current pivot mode
	SetPivot(RotateTool.Pivot);

	-- Start up our interface
	ShowUI();
	BindShortcutKeys();

end;

function RotateTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	HideHandles();
	ClearConnections();
	BoundingBox.ClearBoundingBox();
	SnapTracking.StopTracking();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ClearConnection(ConnectionKey)
	-- Clears the given specific connection

	local Connection = Connections[ConnectionKey];

	-- Disconnect the connection if it exists
	if Connections[ConnectionKey] then
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if RotateTool.UI then

		-- Reveal the UI
		RotateTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	RotateTool.UI = Core.Tool.Interfaces.BTRotateToolGUI:Clone();
	RotateTool.UI.Parent = Core.UI;
	RotateTool.UI.Visible = true;

	-- Add functionality to the pivot option switch
	local PivotSwitch = RotateTool.UI.PivotOption;
	PivotSwitch.Center.Button.MouseButton1Down:connect(function ()
		SetPivot('Center');
	end);
	PivotSwitch.Local.Button.MouseButton1Down:connect(function ()
		SetPivot('Local');
	end);
	PivotSwitch.Last.Button.MouseButton1Down:connect(function ()
		SetPivot('Last');
	end);

	-- Add functionality to the increment input
	local IncrementInput = RotateTool.UI.IncrementOption.Increment.TextBox;
	IncrementInput.FocusLost:connect(function (EnterPressed)
		RotateTool.Increment = tonumber(IncrementInput.Text) or RotateTool.Increment;
		IncrementInput.Text = Support.Round(RotateTool.Increment, 4);
	end);

	-- Add functionality to the rotation inputs
	local XInput = RotateTool.UI.Info.RotationInfo.X.TextBox;
	local YInput = RotateTool.UI.Info.RotationInfo.Y.TextBox;
	local ZInput = RotateTool.UI.Info.RotationInfo.Z.TextBox;
	XInput.FocusLost:connect(function (EnterPressed)
		local NewAngle = tonumber(XInput.Text);
		if NewAngle then
			SetAxisAngle('X', NewAngle);
		end;
	end);
	YInput.FocusLost:connect(function (EnterPressed)
		local NewAngle = tonumber(YInput.Text);
		if NewAngle then
			SetAxisAngle('Y', NewAngle);
		end;
	end);
	ZInput.FocusLost:connect(function (EnterPressed)
		local NewAngle = tonumber(ZInput.Text);
		if NewAngle then
			SetAxisAngle('Z', NewAngle);
		end;
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not RotateTool.UI then
		return;
	end;

	-- Hide the UI
	RotateTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not RotateTool.UI then
		return;
	end;

	-- Only show and calculate selection info if it's not empty
	if #Selection.Items == 0 then
		RotateTool.UI.Info.Visible = false;
		RotateTool.UI.Size = UDim2.new(0, 245, 0, 90);
		return;
	else
		RotateTool.UI.Info.Visible = true;
		RotateTool.UI.Size = UDim2.new(0, 245, 0, 150);
	end;

	-----------------------------------------
	-- Update the size information indicators
	-----------------------------------------

	-- Identify common angles across axes
	local XVariations, YVariations, ZVariations = {}, {}, {};
	for _, Part in pairs(Selection.Items) do
		table.insert(XVariations, Support.Round(Part.Orientation.X, 3));
		table.insert(YVariations, Support.Round(Part.Orientation.Y, 3));
		table.insert(ZVariations, Support.Round(Part.Orientation.Z, 3));
	end;
	local CommonX = Support.IdentifyCommonItem(XVariations);
	local CommonY = Support.IdentifyCommonItem(YVariations);
	local CommonZ = Support.IdentifyCommonItem(ZVariations);

	-- Shortcuts to indicators
	local XIndicator = RotateTool.UI.Info.RotationInfo.X.TextBox;
	local YIndicator = RotateTool.UI.Info.RotationInfo.Y.TextBox;
	local ZIndicator = RotateTool.UI.Info.RotationInfo.Z.TextBox;

	-- Update each indicator if it's not currently being edited
	if not XIndicator:IsFocused() then
		XIndicator.Text = CommonX or '*';
	end;
	if not YIndicator:IsFocused() then
		YIndicator.Text = CommonY or '*';
	end;
	if not ZIndicator:IsFocused() then
		ZIndicator.Text = CommonZ or '*';
	end;

end;

function SetPivot(PivotMode)
	-- Sets the given rotation pivot mode

	-- Update setting
	RotateTool.Pivot = PivotMode;

	-- Update the UI switch
	if RotateTool.UI then
		Core.ToggleSwitch(PivotMode, RotateTool.UI.PivotOption);
	end;

	-- Disable any unnecessary bounding boxes
	BoundingBox.ClearBoundingBox();

	-- For center mode, use bounding box handles
	if PivotMode == 'Center' then
		BoundingBox.StartBoundingBox(AttachHandles);

	-- For local mode, use focused part handles
	elseif PivotMode == 'Local' then
		AttachHandles(Selection.Focus, true); 

	-- For last mode, use focused part handles
	elseif PivotMode == 'Last' then
		AttachHandles(CustomPivotPoint and Handles.Adornee or Selection.Focus, true);
	end;

end;

function AttachHandles(Part, Autofocus)
	-- Creates and attaches handles to `Part`, and optionally automatically attaches to the focused part

	-- Enable autofocus if requested and not already on
	if Autofocus and not Connections.AutofocusHandle then
		Connections.AutofocusHandle = Selection.FocusChanged:connect(function ()
			AttachHandles(Selection.Focus, true);
		end);

	-- Disable autofocus if not requested and on
	elseif not Autofocus and Connections.AutofocusHandle then
		ClearConnection 'AutofocusHandle';
	end;

	-- Just attach and show the handles if they already exist
	if Handles then
		Handles.Adornee = Part;
		Handles.Visible = true;
		Handles.Parent = Part and Core.UIContainer or nil;
		return;
	end;

	-- Create the handles
	Handles = Create 'ArcHandles' {
		Name = 'BTRotationHandles';
		Color = RotateTool.Color;
		Parent = Core.UIContainer;
		Adornee = Part;
	};

	--------------------------------------------------------
	-- Prepare for rotating parts when the handle is clicked
	--------------------------------------------------------

	local AreaPermissions;

	Handles.MouseButton1Down:connect(function ()

		-- Prevent selection
		Core.Targeting.CancelSelecting();

		-- Indicate rotating via handle
		HandleRotating = true;

		-- Freeze bounding box extents while rotating
		if BoundingBox.GetBoundingBox() then
			InitialExtentsSize, InitialExtentsCFrame = BoundingBox.CalculateExtents(Core.Selection.Items, BoundingBox.StaticExtents);
			BoundingBox.PauseMonitoring();
		end;

		-- Stop parts from moving, and capture the initial state of the parts
		InitialState = PreparePartsForRotating();

		-- Track the change
		TrackChange();

		-- Cache area permissions information
		if Core.Mode == 'Tool' then
			AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);
		end;

		-- Set the pivot point to the center of the selection if in Center mode
		if RotateTool.Pivot == 'Center' then
			PivotPoint = BoundingBox.GetBoundingBox().CFrame;

		-- Set the pivot point to the center of the focused part if in Last mode
		elseif RotateTool.Pivot == 'Last' and not CustomPivotPoint then
			PivotPoint = InitialState[Selection.Focus].CFrame;
		end;

	end);

	------------------------------------------
	-- Update parts when the handles are moved
	------------------------------------------

	Handles.MouseDrag:connect(function (Axis, Rotation)

		-- Only rotate if handle is enabled
		if not HandleRotating then
			return;
		end;

		-- Turn the rotation amount into degrees
		Rotation = math.deg(Rotation);

		-- Calculate the increment-aligned rotation amount
		Rotation = GetIncrementMultiple(Rotation, RotateTool.Increment) % 360;

		-- Get displayable rotation delta
		local DisplayedRotation = GetHandleDisplayDelta(Rotation);

		-- Perform the rotation
		RotatePartsAroundPivot(RotateTool.Pivot, PivotPoint, Axis, Rotation, InitialState);

		-- Make sure we're not entering any unauthorized private areas
		if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
			for Part, State in pairs(InitialState) do
				Part.CFrame = State.CFrame;
			end;

			-- Reset displayed rotation delta
			DisplayedRotation = 0;
		end;

		-- Update the "degrees rotated" indicator
		if RotateTool.UI then
			RotateTool.UI.Changes.Text.Text = 'rotated ' .. DisplayedRotation .. ' degrees';
		end;

	end);

end;

-- Finalize changes to parts when the handle is let go
Support.AddUserInputListener('Ended', 'MouseButton1', true, function (Input)

	-- Make sure rotating is ongoing
	if not HandleRotating then
		return;
	end;

	-- Prevent selection
	Core.Targeting.CancelSelecting();

	-- Disable rotating
	HandleRotating = false;

	-- Clear this connection to prevent it from firing again
	ClearConnection 'HandleRelease';

	-- Clear change indicator states
	HandleDirection = nil;
	HandleFirstAngle = nil;
	LastDisplayedRotation = nil;

	-- Make joints, restore original anchor and collision states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

	-- Resume normal bounding box updating
	BoundingBox.RecalculateStaticExtents();
	BoundingBox.ResumeMonitoring();

end);

function HideHandles()
	-- Hides the resizing handles

	-- Make sure handles exist and are visible
	if not Handles or not Handles.Visible then
		return;
	end;

	-- Hide the handles
	Handles.Visible = false;
	Handles.Parent = nil;

	-- Disable handle autofocus if enabled
	ClearConnection 'AutofocusHandle';

end;

function RotatePartsAroundPivot(PivotMode, PivotPoint, Axis, Rotation, InitialStates)
	-- Rotates the given parts in `InitialStates` around `PivotMode` (using `PivotPoint` if applicable)'s `Axis` by `Rotation`

	-- Create a CFrame that increments rotation by `Rotation` around `Axis`
	local RotationCFrame = CFrame.fromAxisAngle(Vector3.FromAxis(Axis), math.rad(Rotation));

	-- Rotate each part
	for Part, InitialState in pairs(InitialStates) do

		-- Rotate around the selection's center, or the currently focused part
		if PivotMode == 'Center' or PivotMode == 'Last' then

			-- Calculate the focused part's rotation
			local RelativeTo = PivotPoint * RotationCFrame;

			-- Calculate this part's offset from the focused part's rotation
			local Offset = PivotPoint:toObjectSpace(InitialState.CFrame);

			-- Rotate relative to the focused part by this part's offset from it
			Part.CFrame = RelativeTo * Offset;

		-- Rotate around the part's center
		elseif RotateTool.Pivot == 'Local' then
			Part.CFrame = InitialState.CFrame * RotationCFrame;

		end;

	end;

end;

function GetHandleDisplayDelta(HandleRotation)
	-- Returns a human-friendly version of the handle's rotation delta

	-- Prepare to capture first angle
	if HandleFirstAngle == nil then
		HandleFirstAngle = true;
		HandleDirection = true;

	-- Capture first angle
	elseif HandleFirstAngle == true then

		-- Determine direction based on first angle
		if math.abs(HandleRotation) > 180 then
			HandleDirection = false;
		else
			HandleDirection = true;
		end;

		-- Disable first angle capturing
		HandleFirstAngle = false;

	end;

	-- Determine the rotation delta to display
	local DisplayedRotation;
	if HandleDirection == true then
		DisplayedRotation = (360 - HandleRotation) % 360;
	else
		DisplayedRotation = HandleRotation % 360;
	end;

	-- Switch delta calculation direction if crossing directions
	if LastDisplayedRotation and (
	   (LastDisplayedRotation <= 120 and DisplayedRotation >= 240) or
	   (LastDisplayedRotation >= 240 and DisplayedRotation <= 120)) then
		HandleDirection = not HandleDirection;
	end;

	-- Update displayed rotation after direction correction
	if HandleDirection == true then
		DisplayedRotation = (360 - HandleRotation) % 360;
	else
		DisplayedRotation = HandleRotation % 360;
	end;

	-- Store this last display rotation
	LastDisplayedRotation = DisplayedRotation;

	-- Return updated display delta
	return DisplayedRotation;

end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Toggle the current axis mode
			if RotateTool.Pivot == 'Center' then
				SetPivot('Local');

			elseif RotateTool.Pivot == 'Local' then
				SetPivot('Last');

			elseif RotateTool.Pivot == 'Last' then
				SetPivot('Center');
			end;

		-- Check if the - key was pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.Minus or InputInfo.KeyCode == Enum.KeyCode.KeypadMinus then

			-- Focus on the increment input
			if RotateTool.UI then
				RotateTool.UI.IncrementOption.Increment.TextBox:CaptureFocus();
			end;

		-- Nudge around X axis if the 8 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadEight then
			NudgeSelectionByAxis(Enum.Axis.X, 1);

		-- Nudge around X axis if the 2 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadTwo then
			NudgeSelectionByAxis(Enum.Axis.X, -1);

		-- Nudge around Z axis if the 9 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadNine then
			NudgeSelectionByAxis(Enum.Axis.Z, 1);

		-- Nudge around Z axis if the 1 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadOne then
			NudgeSelectionByAxis(Enum.Axis.Z, -1);

		-- Nudge around Y axis if the 4 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadFour then
			NudgeSelectionByAxis(Enum.Axis.Y, -1);

		-- Nudge around Y axis if the 6 button on the keypad is pressed
		elseif InputInfo.KeyCode == Enum.KeyCode.KeypadSix then
			NudgeSelectionByAxis(Enum.Axis.Y, 1);

		-- Start snapping when the R key is pressed down, and it's not the selection clearing hotkey
		elseif (InputInfo.KeyCode == Enum.KeyCode.R) and not Selection.Multiselecting then
			StartSnapping();

		-- Start snapping when T key is pressed down (alias)
		elseif InputInfo.KeyCode == Enum.KeyCode.T then
			StartSnapping();

		end;

	end));

end;

function StartSnapping()

	-- Make sure snapping isn't already enabled
	if SnapTracking.Enabled then
		return;
	end;

	-- Listen for snapped points
	SnapTracking.StartTracking(function (NewPoint)
		SnappedPoint = NewPoint;
	end);

	-- Select the snapped pivot point upon clicking
	Connections.SelectSnappedPivot = Core.Mouse.Button1Down:connect(function ()

		-- Disable unintentional selection
		Core.Targeting.CancelSelecting();

		-- Ensure there is a snap point
		if not SnappedPoint then
			return;
		end;

		-- Disable snapping
		SnapTracking.StopTracking();

		-- Attach the handles to a part at the snapped point
		local Part = Create 'Part' {
			CFrame = SnappedPoint,
			Size = Vector3.new(5, 1, 5)
		};
		SetPivot 'Last';
		AttachHandles(Part, true);

		-- Maintain the part in memory to prevent garbage collection
		GCBypass = { Part };

		-- Set the pivot point
		PivotPoint = SnappedPoint;
		CustomPivotPoint = true;

		-- Disconnect snapped pivot point selection listener
		ClearConnection 'SelectSnappedPivot';

		-- Disable custom pivot point mode when the handles attach elsewhere
		DisableCustomPivotPoint = Handles.Changed:Connect(function (Property)
			if Property == 'Adornee' then
				CustomPivotPoint = false;
				DisableCustomPivotPoint:Disconnect();
			end;
		end);

	end);

end;

function SetAxisAngle(Axis, Angle)
	-- Sets the selection's angle on axis `Axis` to `Angle`

	-- Turn the given angle from degrees to radians
	local Angle = math.rad(Angle);

	-- Track this change
	TrackChange();

	-- Prepare parts to be moved
	local InitialStates = PreparePartsForRotating();

	-- Update each part
	for Part, State in pairs(InitialStates) do

		-- Set the part's new CFrame
		Part.CFrame = CFrame.new(Part.Position) * CFrame.fromOrientation(
			Axis == 'X' and Angle or math.rad(Part.Orientation.X),
			Axis == 'Y' and Angle or math.rad(Part.Orientation.Y),
			Axis == 'Z' and Angle or math.rad(Part.Orientation.Z)
		);

	end;

	-- Cache up permissions for all private areas
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Revert changes if player is not authorized to move parts to target destination
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialStates) do
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Restore the parts' original states
	for Part, State in pairs(InitialStates) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function NudgeSelectionByAxis(Axis, Direction)
	-- Nudges the rotation of the selection in the direction of the given axis

	-- Ensure selection is not empty
	if #Selection.Items == 0 then
		return;
	end;

	-- Get amount to nudge by
	local NudgeAmount = RotateTool.Increment;

	-- Reverse nudge amount if shift key is held while nudging
	local PressedKeys = Support.FlipTable(Support.GetListMembers(UserInputService:GetKeysPressed(), 'KeyCode'));
	if PressedKeys[Enum.KeyCode.LeftShift] or PressedKeys[Enum.KeyCode.RightShift] then
		NudgeAmount = -NudgeAmount;
	end;

	-- Track the change
	TrackChange();

	-- Stop parts from moving, and capture the initial state of the parts
	local InitialState = PreparePartsForRotating();

	-- Set the pivot point to the center of the selection if in Center mode
	if RotateTool.Pivot == 'Center' then
		local BoundingBoxSize, BoundingBoxCFrame = BoundingBox.CalculateExtents(Selection.Items);
		PivotPoint = BoundingBoxCFrame;

	-- Set the pivot point to the center of the focused part if in Last mode
	elseif RotateTool.Pivot == 'Last' and not CustomPivotPoint then
		PivotPoint = InitialState[Selection.Focus].CFrame;
	end;

	-- Perform the rotation
	RotatePartsAroundPivot(RotateTool.Pivot, PivotPoint, Axis, NudgeAmount * (Direction or 1), InitialState);

	-- Update the "degrees rotated" indicator
	if RotateTool.UI then
		RotateTool.UI.Changes.Text.Text = 'rotated ' .. (NudgeAmount * (Direction or 1)) .. ' degrees';
	end;

	-- Cache area permissions information
	local AreaPermissions = Security.GetPermissions(Security.GetSelectionAreas(Selection.Items), Core.Player);

	-- Make sure we're not entering any unauthorized private areas
	if Core.Mode == 'Tool' and Security.ArePartsViolatingAreas(Selection.Items, Core.Player, false, AreaPermissions) then
		for Part, State in pairs(InitialState) do
			Part.CFrame = State.CFrame;
		end;
	end;

	-- Make joints, restore original anchor and collision states
	for Part, State in pairs(InitialState) do
		Part:MakeJoints();
		Core.RestoreJoints(State.Joints);
		Part.CanCollide = State.CanCollide;
		Part.Anchored = State.Anchored;
	end;

	-- Register the change
	RegisterChange();

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);
		BeforeCFrame = {};
		AfterCFrame = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, CFrame = Record.BeforeCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncRotate', Changes);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, CFrame = Record.AfterCFrame[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncRotate', Changes);

		end;

	};

	-- Collect the selection's initial state
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.BeforeCFrame[Part] = Part.CFrame;
	end;

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Collect the selection's final state
	local Changes = {};
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.AfterCFrame[Part] = Part.CFrame;
		table.insert(Changes, { Part = Part, CFrame = Part.CFrame });
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncRotate', Changes);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

function PreparePartsForRotating()
	-- Prepares parts for rotating and returns the initial state of the parts

	local InitialState = {};

	-- Get index of parts
	local PartIndex = Support.FlipTable(Selection.Items);

	-- Stop parts from moving, and capture the initial state of the parts
	for _, Part in pairs(Selection.Items) do
		InitialState[Part] = { Anchored = Part.Anchored, CanCollide = Part.CanCollide, CFrame = Part.CFrame };
		Part.Anchored = true;
		Part.CanCollide = false;
		InitialState[Part].Joints = Core.PreserveJoints(Part, PartIndex);
		Part:BreakJoints();
		Part.Velocity = Vector3.new();
		Part.RotVelocity = Vector3.new();
	end;

	return InitialState;
end;

function GetIncrementMultiple(Number, Increment)

	-- Get how far the actual distance is from a multiple of our increment
	local MultipleDifference = Number % Increment;

	-- Identify the closest lower and upper multiples of the increment
	local LowerMultiple = Number - MultipleDifference;
	local UpperMultiple = Number - MultipleDifference + Increment;

	-- Calculate to which of the two multiples we're closer
	local LowerMultipleProximity = math.abs(Number - LowerMultiple);
	local UpperMultipleProximity = math.abs(Number - UpperMultiple);

	-- Use the closest multiple of our increment as the distance moved
	if LowerMultipleProximity <= UpperMultipleProximity then
		Number = LowerMultiple;
	else
		Number = UpperMultiple;
	end;

	return Number;
end;

-- Return the tool
return RotateTool;
end;
};
G2L_MODULES[G2L["3f"]] = {
Closure = function()
    local script = G2L["3f"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local PaintTool = {

	Name = 'Paint Tool';
	Color = BrickColor.new 'Really red';

	-- Default options
	BrickColor = nil;

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function PaintTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	BindShortcutKeys();
	EnableClickPainting();

end;

function PaintTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if PaintTool.UI then

		-- Reveal the UI
		PaintTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	PaintTool.UI = Core.Tool.Interfaces.BTPaintToolGUI:Clone();
	PaintTool.UI.Parent = Core.UI;
	PaintTool.UI.Visible = true;

	-- Track palette buttons
	PaletteButtons = {};

	-- Enable the palette
	for _, Column in pairs(PaintTool.UI.Palette:GetChildren()) do
		for _, Button in pairs(Column:GetChildren()) do
			if Button.ClassName == 'TextButton' then

				-- Recolor the selection when the button is clicked
				Button.MouseButton1Click:connect(function ()
					SetColor(BrickColor.new(Button.Name).Color);
				end);

				-- Register the button
				PaletteButtons[Button.Name] = Button;

			end;
		end;
	end;

	-- Paint selection when current color indicator is clicked
	PaintTool.UI.Controls.LastColorButton.MouseButton1Click:connect(PaintParts);

	-- Enable color picker button
	PaintTool.UI.Controls.ColorPickerButton.MouseButton1Click:connect(function ()
		Core.Cheer(Core.Tool.Interfaces.BTHSVColorPicker, Core.UI).Start(
			Support.IdentifyCommonProperty(Selection.Items, 'Color') or Color3.new(1, 1, 1),
			SetColor,
			Core.Targeting.CancelSelecting,
			PreviewColor
		);
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not PaintTool.UI then
		return;
	end;

	-- Hide the UI
	PaintTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not PaintTool.UI then
		return;
	end;

	-----------------------------------------
	-- Update the color information indicator
	-----------------------------------------

	-- Clear old color indicators
	for Color, Button in pairs(PaletteButtons) do
		Button.Text = '';
	end;

	-- Indicate the variety of colors in the selection
	for _, Part in pairs(Selection.Items) do
		if PaletteButtons[Part.BrickColor.Name] and Part.Color == Part.BrickColor.Color then
			PaletteButtons[Part.BrickColor.Name].Text = '+';
		end;
	end;

	-- Update the color picker button's background
	local CommonColor = Support.IdentifyCommonProperty(Selection.Items, 'Color');
	PaintTool.UI.Controls.ColorPickerButton.ImageColor3 = CommonColor or PaintTool.BrickColor or Color3.new(1, 0, 0);

end;

function SetColor(Color)
	-- Changes the color option to `Color`

	-- Set the color option
	PaintTool.BrickColor = Color;

	-- Use BrickColor name if color matches one
	local EquivalentBrickColor = BrickColor.new(Color);
	local RGBText = ('(%d, %d, %d)'):format(Color.r * 255, Color.g * 255, Color.b * 255);
	local ColorText = (EquivalentBrickColor.Color == Color) and EquivalentBrickColor.Name or RGBText;

	-- Shortcuts to color indicators
	local ColorLabel = PaintTool.UI.Controls.LastColorButton.ColorName;
	local ColorSquare = ColorLabel.ColorSquare;

	-- Update the indicators
	ColorLabel.Visible = true;
	ColorLabel.Text = ColorText;
	ColorSquare.BackgroundColor3 = Color;
	ColorSquare.Position = UDim2.new(1, -ColorLabel.TextBounds.X - 18, 0.2, 1);

	-- Paint currently selected parts
	PaintParts();

end;

function PaintParts()
	-- Recolors the selection with the selected color

	-- Make sure a color has been selected
	if not PaintTool.BrickColor then
		return;
	end;

	-- Track changes
	TrackChange();

	-- Change the color of the parts locally
	for _, Part in pairs(Selection.Items) do
		Part.Color = PaintTool.BrickColor;

		-- Allow part coloring for unions
		if Part.ClassName == 'UnionOperation' then
			Part.UsePartColor = true;
		end;
	end;

	-- Register changes
	RegisterChange();

end;

function PreviewColor(Color)
	-- Previews the given color on the selection

	-- Reset colors to initial state if previewing is over
	if not Color and InitialState then
		for Part, State in pairs(InitialState) do

			-- Reset part color
			Part.Color = State.Color;

			-- Update union coloring options
			if Part.ClassName == 'UnionOperation' then
				Part.UsePartColor = State.UsePartColor;
			end;
		end;

		-- Clear initial state
		InitialState = nil;

		-- Skip rest of function
		return;

	-- Ensure valid color is given
	elseif not Color then
		return;

	-- Save initial state if first time previewing
	elseif not InitialState then
		InitialState = {};
		for _, Part in pairs(Selection.Items) do
			InitialState[Part] = { Color = Part.Color, UsePartColor = (Part.ClassName == 'UnionOperation') and Part.UsePartColor or nil };
		end;
	end;

	-- Apply preview color
	for _, Part in pairs(Selection.Items) do
		Part.Color = Color;

		-- Enable union coloring
		if Part.ClassName == 'UnionOperation' then
			Part.UsePartColor = true;
		end;
	end;

end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Paint the selection with the current color
			PaintParts();

		end;

		-- Check if the R key was pressed, and it wasn't the selection clearing hotkey
		if InputInfo.KeyCode == Enum.KeyCode.R and not Selection.Multiselecting then

			-- Set the current color to that of the current mouse target (if any)
			if Core.Mouse.Target then
				SetColor(Core.Mouse.Target.Color);
			end;

		end;

	end));

end;

function EnableClickPainting()
	-- Allows the player to paint parts by clicking on them

	-- Watch out for clicks on selected parts
	Connections.ClickPainting = Selection.FocusChanged:connect(function (Part)
		if Selection.IsSelected(Core.Mouse.Target) then

			-- Paint the selected parts
			PaintParts();

		end;
	end);

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);
		BeforeColor = {};
		BeforeUnionColoring = {};
		AfterColor = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Color = Record.BeforeColor[Part], UnionColoring = Record.BeforeUnionColoring[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncColor', Changes);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Color = Record.AfterColor[Part], UnionColoring = true });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncColor', Changes);

		end;

	};

	-- Collect the selection's initial state
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.BeforeColor[Part] = Part.Color;

		-- If this part is a union, collect its UsePartColor state
		if Part.ClassName == 'UnionOperation' then
			HistoryRecord.BeforeUnionColoring[Part] = Part.UsePartColor;
		end;
	end;

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Collect the selection's final state
	local Changes = {};
	for _, Part in pairs(HistoryRecord.Parts) do
		HistoryRecord.AfterColor[Part] = Part.Color;
		table.insert(Changes, { Part = Part, Color = Part.Color, UnionColoring = true });
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncColor', Changes);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return PaintTool;
end;
};
G2L_MODULES[G2L["40"]] = {
Closure = function()
    local script = G2L["40"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local MaterialTool = {

	Name = 'Material Tool';
	Color = BrickColor.new 'Bright violet';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function MaterialTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();

end;

function MaterialTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

-- Designate a friendly name to each material
local Materials = {
	[Enum.Material.SmoothPlastic] = 'Smooth Plastic';
	[Enum.Material.Plastic] = 'Plastic';
	[Enum.Material.Brick] = 'Brick';
	[Enum.Material.Cobblestone] = 'Cobblestone';
	[Enum.Material.Concrete] = 'Concrete';
	[Enum.Material.CorrodedMetal] = 'Corroded Metal';
	[Enum.Material.DiamondPlate] = 'Diamond Plate';
	[Enum.Material.Fabric] = 'Fabric';
	[Enum.Material.Foil] = 'Foil';
	[Enum.Material.Granite] = 'Granite';
	[Enum.Material.Grass] = 'Grass';
	[Enum.Material.Ice] = 'Ice';
	[Enum.Material.Marble] = 'Marble';
	[Enum.Material.Metal] = 'Metal';
	[Enum.Material.Neon] = 'Neon';
	[Enum.Material.Pebble] = 'Pebble';
	[Enum.Material.Sand] = 'Sand';
	[Enum.Material.Slate] = 'Slate';
	[Enum.Material.Wood] = 'Wood';
	[Enum.Material.WoodPlanks] = 'Wood Planks';
	[Enum.Material.Glass] = 'Glass';
};

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTMaterialToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- References to inputs
	local TransparencyInput = UI.TransparencyOption.Input.TextBox;
	local ReflectanceInput = UI.ReflectanceOption.Input.TextBox;

	-- Sort the material list
	local MaterialList = Support.Values(Materials);
	table.sort(MaterialList);

	-- Create the material selection dropdown
	MaterialDropdown = Core.Cheer(UI.MaterialOption.Dropdown).Start(MaterialList, '', function (Material)
		SetProperty('Material', Support.FindTableOccurrence(Materials, Material));
	end);

	-- Enable the transparency and reflectance inputs
	SyncInputToProperty('Transparency', TransparencyInput);
	SyncInputToProperty('Reflectance', ReflectanceInput);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function SyncInputToProperty(Property, Input)
	-- Enables `Input` to change the given property

	-- Enable inputs
	Input.FocusLost:connect(function ()
		SetProperty(Property, tonumber(Input.Text));
	end);

end;

function SetProperty(Property, Value)

	-- Make sure the given value is valid
	if Value == nil then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each part
	for _, Part in pairs(Selection.Items) do

		-- Store the state of the part before modification
		table.insert(HistoryRecord.Before, { Part = Part, [Property] = Part[Property] });

		-- Create the change request for this part
		table.insert(HistoryRecord.After, { Part = Part, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function UpdateDataInputs(Data)
	-- Updates the data in the given TextBoxes when the user isn't typing in them

	-- Go through the inputs and data
	for Input, UpdatedValue in pairs(Data) do

		-- Makwe sure the user isn't typing into the input
		if not Input:IsFocused() then

			-- Set the input's value
			Input.Text = tostring(UpdatedValue);

		end;

	end;

end;

-- List of UI layouts
local Layouts = {
	EmptySelection = { 'SelectNote' };
	Normal = { 'MaterialOption', 'TransparencyOption', 'ReflectanceOption' };
};

-- List of UI elements
local UIElements = { 'SelectNote', 'MaterialOption', 'TransparencyOption', 'ReflectanceOption' };

-- Current UI layout
local CurrentLayout;

function ChangeLayout(Layout)
	-- Sets the UI to the given layout

	-- Make sure the new layout isn't already set
	if CurrentLayout == Layout then
		return;
	end;

	-- Set this as the current layout
	CurrentLayout = Layout;

	-- Reset the UI
	for _, ElementName in pairs(UIElements) do
		local Element = UI[ElementName];
		Element.Visible = false;
	end;

	-- Keep track of the total vertical extents of all items
	local Sum = 0;

	-- Go through each layout element
	for ItemIndex, ItemName in ipairs(Layout) do

		local Item = UI[ItemName];

		-- Make the item visible
		Item.Visible = true;

		-- Position this item underneath the past items
		Item.Position = UDim2.new(0, 0, 0, 20) + UDim2.new(
			Item.Position.X.Scale,
			Item.Position.X.Offset,
			0,
			Sum + 10
		);

		-- Update the sum of item heights
		Sum = Sum + 10 + Item.AbsoluteSize.Y;

	end;

	-- Resize the container to fit the new layout
	UI.Size = UDim2.new(0, 200, 0, 40 + Sum);

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not UI then
		return;
	end;

	-- References to inputs
	local TransparencyInput = UI.TransparencyOption.Input.TextBox;
	local ReflectanceInput = UI.ReflectanceOption.Input.TextBox;

	-----------------------
	-- Update the UI layout
	-----------------------

	-- Figure out the necessary UI layout
	if #Selection.Items == 0 then
		ChangeLayout(Layouts.EmptySelection);
		return;

	-- When the selection isn't empty
	else
		ChangeLayout(Layouts.Normal);
	end;

	-- Get the common properties
	local Material = Support.IdentifyCommonProperty(Selection.Items, 'Material');
	local Transparency = Support.IdentifyCommonProperty(Selection.Items, 'Transparency');
	local Reflectance = Support.IdentifyCommonProperty(Selection.Items, 'Reflectance');

	-- Update the material dropdown
	MaterialDropdown.SetOption(Material and Materials[Material] or '*');

	-- Update inputs
	UpdateDataInputs {
		[TransparencyInput] = Transparency and Support.Round(Transparency, 2) or '*';
		[ReflectanceInput] = Reflectance and Support.Round(Reflectance, 2) or '*';
	};

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMaterial', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMaterial', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncMaterial', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return MaterialTool;
end;
};
G2L_MODULES[G2L["41"]] = {
Closure = function()
    local script = G2L["41"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local SurfaceTool = {

	Name = 'Surface Tool';
	Color = BrickColor.new 'Bright violet';

	-- Default options
	Surface = 'All';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function SurfaceTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	EnableSurfaceSelection();

	-- Set our current surface mode
	SetSurface(SurfaceTool.Surface);

end;

function SurfaceTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if SurfaceTool.UI then

		-- Reveal the UI
		SurfaceTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	SurfaceTool.UI = Core.Tool.Interfaces.BTSurfaceToolGUI:Clone();
	SurfaceTool.UI.Parent = Core.UI;
	SurfaceTool.UI.Visible = true;

	-- Create the surface selection dropdown
	SurfaceDropdown = Core.Cheer(SurfaceTool.UI.SideOption.Dropdown).Start({ 'All', 'Top', 'Bottom', 'Front', 'Back', 'Left', 'Right' }, 'All', SetSurface);

	-- Map type label names to actual type names
	local SurfaceTypes = {
		['Studs'] = 'Studs',
		['Inlets'] = 'Inlet',
		['Smooth'] = 'Smooth',
		['Weld'] = 'Weld',
		['Glue'] = 'Glue',
		['Universal'] = 'Universal',
		['Hinge'] = 'Hinge',
		['Motor'] = 'Motor',
		['No Outline'] = 'SmoothNoOutlines'
	};

	-- Create the surface type selection dropdown
	SurfaceTypeDropdown = Core.Cheer(SurfaceTool.UI.TypeOption.Dropdown).Start({ 'Studs', 'Inlets', 'Smooth', 'Weld', 'Glue', 'Universal', 'Hinge', 'Motor', 'No Outline' }, '', function (Option)
		SetSurfaceType(Enum.SurfaceType[SurfaceTypes[Option]]);
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not SurfaceTool.UI then
		return;
	end;

	-- Hide the UI
	SurfaceTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function GetSurfaceTypeDisplayName(SurfaceType)
	-- Returns a more friendly name for the given `SurfaceType`

	-- For stepping motors, add a space
	if SurfaceType == Enum.SurfaceType.SteppingMotor then
		return 'Stepping Motor';

	-- For no outlines, simplify name
	elseif SurfaceType == Enum.SurfaceType.SmoothNoOutlines then
		return 'No Outline';

	-- For other surface types, return their normal name
	else
		return SurfaceType.Name;

	end;

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not SurfaceTool.UI then
		return;
	end;

	-- Only show and identify current surface type if selection is not empty
	if #Selection.Items == 0 then
		SurfaceTypeDropdown.SetOption('');
		return;
	end;

	------------------------------------
	-- Update the surface type indicator
	------------------------------------

	-- Collect all different surface types in selection
	local SurfaceTypeVariations = {};
	for _, Part in pairs(Selection.Items) do

		-- Search for variations on all surfaces if all surfaces are selected
		if SurfaceTool.Surface == 'All' then
			table.insert(SurfaceTypeVariations, Part.TopSurface);
			table.insert(SurfaceTypeVariations, Part.BottomSurface);
			table.insert(SurfaceTypeVariations, Part.FrontSurface);
			table.insert(SurfaceTypeVariations, Part.BackSurface);
			table.insert(SurfaceTypeVariations, Part.LeftSurface);
			table.insert(SurfaceTypeVariations, Part.RightSurface);

		-- Search for variations on single selected surface
		else
			table.insert(SurfaceTypeVariations, Part[SurfaceTool.Surface .. 'Surface']);
		end;

	end;

	-- Identify common surface type in selection
	local CommonSurfaceType = Support.IdentifyCommonItem(SurfaceTypeVariations);

	-- Update the current surface type in the surface type dropdown
	SurfaceTypeDropdown.SetOption(CommonSurfaceType and GetSurfaceTypeDisplayName(CommonSurfaceType) or '*');

end;

function SetSurface(Surface)
	-- Changes the surface option to `Surface`

	-- Set the surface option
	SurfaceTool.Surface = Surface;

	-- Update the current surface in the surface dropdown
	SurfaceDropdown.SetOption(Surface);

end;

function SetSurfaceType(SurfaceType)
	-- Changes the selection's surface type on the currently selected surface

	-- Make sure a surface has been selected
	if not SurfaceTool.Surface then
		return;
	end;

	-- Track changes
	TrackChange();

	-- Change the surface of the parts locally
	for _, Part in pairs(Selection.Items) do

		-- Change all surfaces if all selected
		if SurfaceTool.Surface == 'All' then
			Part.TopSurface = SurfaceType;
			Part.BottomSurface = SurfaceType;
			Part.FrontSurface = SurfaceType;
			Part.BackSurface = SurfaceType;
			Part.LeftSurface = SurfaceType;
			Part.RightSurface = SurfaceType;

		-- Change specific selected surface
		else
			Part[SurfaceTool.Surface .. 'Surface'] = SurfaceType;
		end;

	end;

	-- Register changes
	RegisterChange();

end;

function EnableSurfaceSelection()
	-- Allows the player to select surfaces by clicking on them

	-- Watch out for clicks on selected parts
	Connections.SurfaceSelection = Selection.FocusChanged:connect(function (Part)
		if Selection.IsSelected(Core.Mouse.Target) then

			-- Set the surface option to the target surface
			SetSurface(Core.Mouse.TargetSurface.Name);

		end;
	end);

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Parts = Support.CloneTable(Selection.Items);
		BeforeSurfaces = {};
		AfterSurfaces = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Surfaces = Record.BeforeSurfaces[Part]	});
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncSurface', Changes);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Record.Parts);

			-- Put together the change request
			local Changes = {};
			for _, Part in pairs(Record.Parts) do
				table.insert(Changes, { Part = Part, Surfaces = Record.AfterSurfaces[Part] });
			end;

			-- Send the change request
			Core.SyncAPI:Invoke('SyncSurface', Changes);

		end;

	};

	-- Collect the selection's initial state
	for _, Part in pairs(HistoryRecord.Parts) do

		-- Begin to record surfaces
		HistoryRecord.BeforeSurfaces[Part] = {};
		local Surfaces = HistoryRecord.BeforeSurfaces[Part];

		-- Record all surfaces if all selected
		if SurfaceTool.Surface == 'All' then
			Surfaces.Top = Part.TopSurface;
			Surfaces.Bottom = Part.BottomSurface;
			Surfaces.Front = Part.FrontSurface;
			Surfaces.Back = Part.BackSurface;
			Surfaces.Left = Part.LeftSurface;
			Surfaces.Right = Part.RightSurface;

		-- Record specific selected surface
		else
			Surfaces[SurfaceTool.Surface] = Part[SurfaceTool.Surface .. 'Surface'];
		end;

	end;

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Collect the selection's final state
	local Changes = {};
	for _, Part in pairs(HistoryRecord.Parts) do

		-- Begin to record surfaces
		HistoryRecord.AfterSurfaces[Part] = {};
		local Surfaces = HistoryRecord.AfterSurfaces[Part];

		-- Record all surfaces if all selected
		if SurfaceTool.Surface == 'All' then
			Surfaces.Top = Part.TopSurface;
			Surfaces.Bottom = Part.BottomSurface;
			Surfaces.Front = Part.FrontSurface;
			Surfaces.Back = Part.BackSurface;
			Surfaces.Left = Part.LeftSurface;
			Surfaces.Right = Part.RightSurface;

		-- Record specific selected surface
		else
			Surfaces[SurfaceTool.Surface] = Part[SurfaceTool.Surface .. 'Surface'];
		end;

		-- Create the change request for this part
		table.insert(Changes, { Part = Part, Surfaces = Surfaces });

	end;

	-- Send the changes to the server
	Core.SyncAPI:Invoke('SyncSurface', Changes);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return SurfaceTool;
end;
};
G2L_MODULES[G2L["42"]] = {
Closure = function()
    local script = G2L["42"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local AnchorTool = {

	Name = 'Anchor Tool';
	Color = BrickColor.new 'Really black';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function AnchorTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	BindShortcutKeys();

end;

function AnchorTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTAnchorToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- References to UI elements
	local AnchorButton = UI.Status.Anchored.Button;
	local UnanchorButton = UI.Status.Unanchored.Button;

	-- Enable the anchor status switch
	AnchorButton.MouseButton1Click:connect(function ()
		SetProperty('Anchored', true);
	end);
	UnanchorButton.MouseButton1Click:connect(function ()
		SetProperty('Anchored', false);
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not UI then
		return;
	end;

	-- Check the common anchor status of selection
	local Anchored = Support.IdentifyCommonProperty(Selection.Items, 'Anchored');

	-- Update the anchor option switch
	if Anchored == true then
		Core.ToggleSwitch('Anchored', UI.Status);

	-- If the selection is unanchored
	elseif Anchored == false then
		Core.ToggleSwitch('Unanchored', UI.Status);

	-- If the anchor status varies, don't select a current switch
	elseif Anchored == nil then
		Core.ToggleSwitch(nil, UI.Status);
	end;

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function SetProperty(Property, Value)

	-- Make sure the given value is valid
	if Value == nil then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each part
	for _, Part in pairs(Selection.Items) do

		-- Store the state of the part before modification
		table.insert(HistoryRecord.Before, { Part = Part, [Property] = Part[Property] });

		-- Create the change request for this part
		table.insert(HistoryRecord.After, { Part = Part, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Toggle the selection's anchor status
			ToggleAnchors();

		end;

	end));

end;

function ToggleAnchors()
	-- Toggles the anchor status of the selection

	-- Change the anchor status to the opposite of the common anchor status
	SetProperty('Anchored', not Support.IdentifyCommonProperty(Selection.Items, 'Anchored'));

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncAnchor', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncAnchor', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncAnchor', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return AnchorTool;
end;
};
G2L_MODULES[G2L["43"]] = {
Closure = function()
    local script = G2L["43"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local WeldTool = {

	Name = 'Weld Tool';
	Color = BrickColor.new 'Really black';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function WeldTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	EnableFocusHighlighting();

end;

function WeldTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTWeldToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- Hook up the buttons
	UI.Interface.WeldButton.MouseButton1Click:connect(CreateWelds);
	UI.Interface.BreakWeldsButton.MouseButton1Click:connect(BreakWelds);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

end;

-- References to reduce indexing time
local GetConnectedParts = Instance.new('Part').GetConnectedParts;
local GetChildren = script.GetChildren;

function GetPartWelds(Part)
	-- Returns any BT-created welds involving `Part`

	local Welds = {};

	-- Get welds stored inside `Part`
	for Weld in pairs(SearchWelds(Part, Part)) do
		Welds[Weld] = true;
	end;

	-- Get welds stored inside connected parts
	for _, ConnectedPart in pairs(GetConnectedParts(Part)) do
		for Weld in pairs(SearchWelds(ConnectedPart, Part)) do
			Welds[Weld] = true;
		end;
	end;

	-- Return all found welds
	return Welds;

end;

function SearchWelds(Haystack, Part)
	-- Searches for and returns BT-created welds in `Haystack` involving `Part`

	local Welds = {};

	-- Search the haystack for welds involving `Part`
	for _, Item in pairs(GetChildren(Haystack)) do

		-- Check if this item is a BT-created weld involving the part
		if Item.Name == 'BTWeld' and Item.ClassName == 'Weld' and
		   (Item.Part0 == Part or Item.Part1 == Part) then

			-- Store weld if valid
			Welds[Item] = true;

		end;

	end;

	-- Return the found welds
	return Welds;

end;

function CreateWelds()
	-- Creates welds for every selected part to the focused part

	-- Send the change request to the server API
	local Welds = Core.SyncAPI:Invoke('CreateWelds', Selection.Items, Selection.Focus);

	-- Update the UI with the number of welds created
	UI.Changes.Text.Text = ('created %s weld%s'):format(#Welds, #Welds == 1 and '' or 's');

	-- Play a confirmation sound
	Core.PlayConfirmationSound();

	-- Put together the history record
	local HistoryRecord = {
		Welds = Welds;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Remove the welds
			Core.SyncAPI:Invoke('RemoveWelds', HistoryRecord.Welds);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the welds
			Core.SyncAPI:Invoke('UndoRemovedWelds', HistoryRecord.Welds);

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function BreakWelds()
	-- Search for any selection-connecting, BT-created welds and remove them

	local Welds = {};

	-- Find welds in selected parts
	for _, Part in pairs(Selection.Items) do
		for Weld in pairs(GetPartWelds(Part)) do
			Welds[Weld] = true;
		end;
	end;

	-- Turn weld index into list
	Welds = Support.Keys(Welds);

	-- Send the change request to the server API
	local WeldsRemoved = Core.SyncAPI:Invoke('RemoveWelds', Welds);

	-- Update the UI with the number of welds removed
	UI.Changes.Text.Text = ('removed %s weld%s'):format(WeldsRemoved, WeldsRemoved == 1 and '' or 's');

	-- Put together the history record
	local HistoryRecord = {
		Welds = Welds;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the welds
			Core.SyncAPI:Invoke('UndoRemovedWelds', HistoryRecord.Welds);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Remove the welds
			Core.SyncAPI:Invoke('RemoveWelds', HistoryRecord.Welds);

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function EnableFocusHighlighting()
	-- Enables automatic highlighting of the focused part in the selection

	-- Only enable focus highlighting in tool mode
	if Core.Mode ~= 'Tool' then
		return;
	end;

	-- Reset all outline colors
	Core.Selection.RecolorOutlines(Core.Selection.Color);

	-- Recolor current focused item
	if Selection.Focus and (#Selection.Items > 1) then
		Core.Selection.Outlines[Selection.Focus].Color = BrickColor.new('Deep orange');
	end;

	-- Recolor future focused items
	Connections.FocusHighlighting = Selection.FocusChanged:connect(function (FocusedItem)

		-- Reset all outline colors
		Core.Selection.RecolorOutlines(Core.Selection.Color);

		-- Recolor newly focused item
		if FocusedItem and (#Selection.Items > 1) then
			Core.Selection.Outlines[FocusedItem].Color = BrickColor.new('Deep orange');
		end;

	end);

end;

-- Return the tool
return WeldTool;
end;
};
G2L_MODULES[G2L["44"]] = {
Closure = function()
    local script = G2L["44"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local TextureTool = {

	Name = 'Texture Tool';
	Color = BrickColor.new 'Bright violet';

	-- Default options
	Type = 'Decal';
	Face = Enum.NormalId.Front;

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function TextureTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	EnableSurfaceClickSelection();

	-- Set our current texture type and face
	SetTextureType(TextureTool.Type);
	SetFace(TextureTool.Face);

end;

function TextureTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTTextureToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- References to UI elements
	local AddButton = UI.AddButton;
	local RemoveButton = UI.RemoveButton;
	local DecalModeButton = UI.ModeOption.Decal.Button;
	local TextureModeButton = UI.ModeOption.Texture.Button;
	local ImageIdInput = UI.ImageIDOption.TextBox;
	local TransparencyInput = UI.TransparencyOption.Input.TextBox;
	local RepeatXInput = UI.RepeatOption.XInput.TextBox;
	local RepeatYInput = UI.RepeatOption.YInput.TextBox;

	-- Enable the texture type switch
	DecalModeButton.MouseButton1Click:connect(function ()
		SetTextureType 'Decal';
	end);
	TextureModeButton.MouseButton1Click:connect(function ()
		SetTextureType 'Texture';
	end);

	-- Create the face selection dropdown
	local Faces = { 'Top', 'Bottom', 'Front', 'Back', 'Left', 'Right' };
	FaceDropdown = Core.Cheer(UI.SideOption.Dropdown).Start(Faces, '', function (Face)
		SetFace(Enum.NormalId[Face]);
	end);

	-- Enable the image ID input
	ImageIdInput.FocusLost:connect(function (EnterPressed)
		SetTextureId(TextureTool.Type, TextureTool.Face, ParseAssetId(ImageIdInput.Text));
	end);

	-- Enable other inputs
	SyncInputToProperty('Transparency', TransparencyInput);
	SyncInputToProperty('StudsPerTileU', RepeatXInput);
	SyncInputToProperty('StudsPerTileV', RepeatYInput);

	-- Enable the texture adding button
	AddButton.Button.MouseButton1Click:connect(function ()
		AddTextures(TextureTool.Type, TextureTool.Face);
	end);
	RemoveButton.Button.MouseButton1Click:connect(function ()
		RemoveTextures(TextureTool.Type, TextureTool.Face);
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function SyncInputToProperty(Property, Input)
	-- Enables `Input` to change the given property

	-- Enable inputs
	Input.FocusLost:connect(function ()
		SetProperty(TextureTool.Type, TextureTool.Face, Property, tonumber(Input.Text));
	end);

end;

function EnableSurfaceClickSelection()
	-- Allows for the setting of the current face by clicking

	-- Clear out any existing connection
	if Connections.SurfaceClickSelection then
		Connections.SurfaceClickSelection:disconnect();
		Connections.SurfaceClickSelection = nil;
	end;

	-- Add the new click connection
	Connections.SurfaceClickSelection = UserInputService.InputEnded:connect(function (Input, GameProcessedEvent)
		if not GameProcessedEvent and Input.UserInputType == Enum.UserInputType.MouseButton1 and Selection.IsSelected(Core.Mouse.Target) then
			SetFace(Core.Mouse.TargetSurface);
		end;
	end);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function GetTextures(TextureType, Face)
	-- Returns all the textures in the selection

	local Textures = {};

	-- Get any textures from any selected parts
	for _, Part in pairs(Selection.Items) do
		for _, Child in pairs(Part:GetChildren()) do

			-- If this child is texture we're looking for, collect it
			if Child.ClassName == TextureType and Child.Face == Face then
				table.insert(Textures, Child);
			end;

		end;
	end;

	-- Return the found textures
	return Textures;

end;

-- List of creatable textures
local TextureTypes = { 'Decal', 'Texture' };

-- List of UI layouts
local Layouts = {
	EmptySelection = { 'SelectNote' };
	NoTextures = { 'ModeOption', 'SideOption', 'AddButton' };
	SomeDecals = { 'ModeOption', 'SideOption', 'ImageIDOption', 'TransparencyOption', 'AddButton', 'RemoveButton' };
	AllDecals = { 'ModeOption', 'SideOption', 'ImageIDOption', 'TransparencyOption', 'RemoveButton' };
	SomeTextures = { 'ModeOption', 'SideOption', 'ImageIDOption', 'TransparencyOption', 'RepeatOption', 'AddButton', 'RemoveButton' };
	AllTextures = { 'ModeOption', 'SideOption', 'ImageIDOption', 'TransparencyOption', 'RepeatOption', 'RemoveButton' };
};

-- List of UI elements
local UIElements = { 'SelectNote', 'ModeOption', 'SideOption', 'ImageIDOption', 'TransparencyOption', 'RepeatOption', 'AddButton', 'RemoveButton' };

-- Current UI layout
local CurrentLayout;

function ChangeLayout(Layout)
	-- Sets the UI to the given layout

	-- Make sure the new layout isn't already set
	if CurrentLayout == Layout then
		return;
	end;

	-- Set this as the current layout
	CurrentLayout = Layout;

	-- Reset the UI
	for _, ElementName in pairs(UIElements) do
		local Element = UI[ElementName];
		Element.Visible = false;
	end;

	-- Keep track of the total vertical extents of all items
	local Sum = 0;

	-- Go through each layout element
	for ItemIndex, ItemName in ipairs(Layout) do

		local Item = UI[ItemName];

		-- Make the item visible
		Item.Visible = true;

		-- Position this item underneath the past items
		Item.Position = UDim2.new(0, 0, 0, 20) + UDim2.new(
			Item.Position.X.Scale,
			Item.Position.X.Offset,
			0,
			Sum + 10
		);

		-- Update the sum of item heights
		Sum = Sum + 10 + Item.AbsoluteSize.Y;

	end;

	-- Resize the container to fit the new layout
	UI.Size = UDim2.new(0, 200, 0, 30 + Sum);

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not UI then
		return;
	end;

	-- Get the textures in the selection
	local Textures = GetTextures(TextureTool.Type, TextureTool.Face);

	-- References to UI elements
	local ImageIdInput = UI.ImageIDOption.TextBox;
	local TransparencyInput = UI.TransparencyOption.Input.TextBox;

	-----------------------
	-- Update the UI layout
	-----------------------

	-- Get the plural version of the current texture type
	local PluralTextureType = TextureTool.Type .. 's';

	-- Figure out the necessary UI layout
	if #Selection.Items == 0 then
		ChangeLayout(Layouts.EmptySelection);
		return;

	-- When the selection has no textures
	elseif #Textures == 0 then
		ChangeLayout(Layouts.NoTextures);
		return;

	-- When only some selected items have textures
	elseif #Selection.Items ~= #Textures then
		ChangeLayout(Layouts['Some' .. PluralTextureType]);

	-- When all selected items have textures
	elseif #Selection.Items == #Textures then
		ChangeLayout(Layouts['All' .. PluralTextureType]);
	end;

	------------------------
	-- Update UI information
	------------------------

	-- Get the common properties
	local ImageId = Support.IdentifyCommonProperty(Textures, 'Texture');
	local Transparency = Support.IdentifyCommonProperty(Textures, 'Transparency');

	-- Update the common inputs
	UpdateDataInputs {
		[ImageIdInput] = ImageId and ParseAssetId(ImageId) or ImageId or '*';
		[TransparencyInput] = Transparency and Support.Round(Transparency, 3) or '*';
	};

	-- Update texture-specific information on UI
	if TextureTool.Type == 'Texture' then

		-- Get texture-specific UI elements
		local RepeatXInput = UI.RepeatOption.XInput.TextBox;
		local RepeatYInput = UI.RepeatOption.YInput.TextBox;

		-- Get texture-specific common properties
		local RepeatX = Support.IdentifyCommonProperty(Textures, 'StudsPerTileU');
		local RepeatY = Support.IdentifyCommonProperty(Textures, 'StudsPerTileV');

		-- Update inputs
		UpdateDataInputs {
			[RepeatXInput] = RepeatX and Support.Round(RepeatX, 3) or '*';
			[RepeatYInput] = RepeatY and Support.Round(RepeatY, 3) or '*';
		};

	end;

end;

function UpdateDataInputs(Data)
	-- Updates the data in the given TextBoxes when the user isn't typing in them

	-- Go through the inputs and data
	for Input, UpdatedValue in pairs(Data) do

		-- Makwe sure the user isn't typing into the input
		if not Input:IsFocused() then

			-- Set the input's value
			Input.Text = tostring(UpdatedValue);

		end;

	end;

end;

function ParseAssetId(Input)
	-- Returns the intended asset ID for the given input

	-- Get the ID number from the input
	local Id = tonumber(Input)
		or tonumber(Input:lower():match('%?id=([0-9]+)'))
		or tonumber(Input:match('/([0-9]+)/'))
		or tonumber(Input:lower():match('rbxassetid://([0-9]+)'));

	-- Return the ID
	return Id;
end;

function SetFace(Face)

	-- Update the tool option
	TextureTool.Face = Face;

	-- Update the UI
	FaceDropdown.SetOption(Face and Face.Name or '*');

end;

function SetTextureType(TextureType)

	-- Update the tool option
	TextureTool.Type = TextureType;

	-- Update the UI
	Core.ToggleSwitch(TextureType, UI.ModeOption);
	UI.AddButton.Button.Text = 'ADD ' .. TextureType:upper();
	UI.RemoveButton.Button.Text = 'REMOVE ' .. TextureType:upper();

end;

function SetProperty(TextureType, Face, Property, Value)

	-- Make sure the given value is valid
	if not Value then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each texture
	for _, Texture in pairs(GetTextures(TextureType, Face)) do

		-- Store the state of the texture before modification
		table.insert(HistoryRecord.Before, { Part = Texture.Parent, TextureType = TextureType, Face = Face, [Property] = Texture[Property] });

		-- Create the change request for this texture
		table.insert(HistoryRecord.After, { Part = Texture.Parent, TextureType = TextureType, Face = Face, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetTextureId(TextureType, Face, AssetId)
	-- Sets the textures in the selection to the intended, given image asset

	-- Make sure the given asset ID is valid
	if not AssetId then
		return;
	end;

	-- Prepare the change request
	local Changes = {
		Texture = 'rbxassetid://' .. AssetId;
	};

	-- Attempt an image extraction on the given asset
	Core.Try(Core.SyncAPI.Invoke, Core.SyncAPI, 'ExtractImageFromDecal', AssetId)
		:Then(function (ExtractedImage)
			Changes.Texture = 'rbxassetid://' .. ExtractedImage;
		end);

	-- Start a history record
	TrackChange();

	-- Go through each texture
	for _, Texture in pairs(GetTextures(TextureType, Face)) do

		-- Create the history change requests for this texture
		local Before, After = { Part = Texture.Parent, TextureType = TextureType, Face = Face }, { Part = Texture.Parent, TextureType = TextureType, Face = Face };

		-- Gather change information to finish up the history change requests
		for Property, Value in pairs(Changes) do
			Before[Property] = Texture[Property];
			After[Property] = Value;
		end;

		-- Store the state of the texture before modification
		table.insert(HistoryRecord.Before, Before);

		-- Create the change request for this texture
		table.insert(HistoryRecord.After, After);

	end;

	-- Register the changes
	RegisterChange();

end;

function AddTextures(TextureType, Face)

	-- Prepare the change request for the server
	local Changes = {};

	-- Go through the selection
	for _, Part in pairs(Selection.Items) do

		-- Make sure this part doesn't already have a texture of the same type
		local HasTextures;
		for _, Child in pairs(Part:GetChildren()) do
			if Child.ClassName == TextureType and Child.Face == Face then
				HasTextures = true;
			end;
		end;

		-- Queue a texture to be created for this part, if not already existent
		if not HasTextures then
			table.insert(Changes, { Part = Part, TextureType = TextureType, Face = Face });
		end;

	end;

	-- Send the change request to the server
	local Textures = Core.SyncAPI:Invoke('CreateTextures', Changes);

	-- Put together the history record
	local HistoryRecord = {
		Textures = Textures;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Textures, 'Parent'));

			-- Remove the textures
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Textures);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the textures
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Textures);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Textures, 'Parent'));

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function RemoveTextures(TextureType, Face)

	-- Get all the textures in the selection
	local Textures = GetTextures(TextureType, Face);

	-- Create the history record
	local HistoryRecord = {
		Textures = Textures;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the textures
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Textures);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Textures, 'Parent'));

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Textures, 'Parent'));

			-- Remove the textures
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Textures);

		end;

	};

	-- Send the removal request
	Core.SyncAPI:Invoke('Remove', Textures);

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncTexture', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncTexture', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncTexture', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return TextureTool;
end;
};
G2L_MODULES[G2L["45"]] = {
Closure = function()
    local script = G2L["45"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local MeshTool = {

	Name = 'Mesh Tool';
	Color = BrickColor.new 'Bright violet';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function MeshTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();

end;

function MeshTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if MeshTool.UI then

		-- Reveal the UI
		MeshTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	MeshTool.UI = Core.Tool.Interfaces.BTMeshToolGUI:Clone();
	MeshTool.UI.Parent = Core.UI;
	MeshTool.UI.Visible = true;

	local AddButton = MeshTool.UI.AddButton;
	local RemoveButton = MeshTool.UI.RemoveButton;

	local MeshIdInput = MeshTool.UI.MeshIdOption.TextBox;
	local TextureIdInput = MeshTool.UI.TextureIdOption.TextBox;
	local VertexColorInput = MeshTool.UI.TintOption.HSVPicker;

	MeshTypes = {
		Block = Enum.MeshType.Brick,
		Cylinder = Enum.MeshType.Cylinder,
		File = Enum.MeshType.FileMesh,
		Head = Enum.MeshType.Head,
		Sphere = Enum.MeshType.Sphere,
		Trapezoid = Enum.MeshType.Torso,
		Wedge = Enum.MeshType.Wedge
	};

	-- Sort the mesh types
	SortedMeshTypes = Support.Keys(MeshTypes);
	table.sort(SortedMeshTypes);

	-- Create the mesh type dropdown
	TypeDropdown = Core.Cheer(MeshTool.UI.TypeOption.Dropdown).Start(SortedMeshTypes, '', function (Type)
		SetProperty('MeshType', MeshTypes[Type]);
	end);

	-- Enable the scale inputs
	local XScaleInput = MeshTool.UI.ScaleOption.XInput.TextBox;
	local YScaleInput = MeshTool.UI.ScaleOption.YInput.TextBox;
	local ZScaleInput = MeshTool.UI.ScaleOption.ZInput.TextBox;
	XScaleInput.FocusLost:connect(function (EnterPressed)
		local NewScale = tonumber(XScaleInput.Text);
		SetAxisScale('X', NewScale);
	end);
	YScaleInput.FocusLost:connect(function (EnterPressed)
		local NewScale = tonumber(YScaleInput.Text);
		SetAxisScale('Y', NewScale);
	end);
	ZScaleInput.FocusLost:connect(function (EnterPressed)
		local NewScale = tonumber(ZScaleInput.Text);
		SetAxisScale('Z', NewScale);
	end);

	-- Enable the offset inputs
	local XOffsetInput = MeshTool.UI.OffsetOption.XInput.TextBox;
	local YOffsetInput = MeshTool.UI.OffsetOption.YInput.TextBox;
	local ZOffsetInput = MeshTool.UI.OffsetOption.ZInput.TextBox;
	XOffsetInput.FocusLost:connect(function (EnterPressed)
		local NewOffset = tonumber(XOffsetInput.Text);
		SetAxisOffset('X', NewOffset);
	end);
	YOffsetInput.FocusLost:connect(function (EnterPressed)
		local NewOffset = tonumber(YOffsetInput.Text);
		SetAxisOffset('Y', NewOffset);
	end);
	ZOffsetInput.FocusLost:connect(function (EnterPressed)
		local NewOffset = tonumber(ZOffsetInput.Text);
		SetAxisOffset('Z', NewOffset);
	end);

	-- Enable the mesh ID input
	MeshIdInput.FocusLost:connect(function (EnterPressed)
		SetMeshId(ParseAssetId(MeshIdInput.Text));
	end);

	-- Enable the texture ID input
	TextureIdInput.FocusLost:connect(function (EnterPressed)
		SetTextureId(ParseAssetId(TextureIdInput.Text));
	end);

	-- Enable the vertex color/tint option
	VertexColorInput.MouseButton1Click:connect(function ()
		Core.Cheer(Core.Tool.Interfaces.BTHSVColorPicker, Core.UI).Start(
			VectorToColor(Support.IdentifyCommonProperty(GetMeshes(), 'VertexColor')) or Color3.new(1, 1, 1),
			function (Color) SetProperty('VertexColor', ColorToVector(Color)) end,
			Core.Targeting.CancelSelecting
		);
	end);

	-- Enable the mesh adding button
	AddButton.Button.MouseButton1Click:connect(function ()
		AddMeshes();
	end);
	RemoveButton.Button.MouseButton1Click:connect(function ()
		RemoveMeshes();
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not MeshTool.UI then
		return;
	end;

	-- Get all meshes
	local Meshes = GetMeshes();

	-- Identify all common properties
	local MeshType = Support.IdentifyCommonProperty(Meshes, 'MeshType');
	local MeshId = Support.IdentifyCommonProperty(Meshes, 'MeshId');
	local TextureId = Support.IdentifyCommonProperty(Meshes, 'TextureId');
	local VertexColor = VectorToColor(Support.IdentifyCommonProperty(Meshes, 'VertexColor'));

	-- Check if there's a file mesh in the selection
	local FileMeshInSelection = false;
	for _, Mesh in pairs(GetMeshes()) do
		if Mesh.MeshType == Enum.MeshType.FileMesh then
			FileMeshInSelection = true;
			break;
		end;
	end;

	-- Identify common scales and offsets across axes
	local XScaleVariations, YScaleVariations, ZScaleVariations = {}, {}, {};
	local XOffsetVariations, YOffsetVariations, ZOffsetVariations = {}, {}, {};
	for _, Mesh in pairs(GetMeshes()) do
		table.insert(XScaleVariations, Support.Round(Mesh.Scale.X, 3));
		table.insert(YScaleVariations, Support.Round(Mesh.Scale.Y, 3));
		table.insert(ZScaleVariations, Support.Round(Mesh.Scale.Z, 3));
		table.insert(XOffsetVariations, Support.Round(Mesh.Offset.X, 3));
		table.insert(YOffsetVariations, Support.Round(Mesh.Offset.Y, 3));
		table.insert(ZOffsetVariations, Support.Round(Mesh.Offset.Z, 3));
	end;
	local CommonXScale = Support.IdentifyCommonItem(XScaleVariations);
	local CommonYScale = Support.IdentifyCommonItem(YScaleVariations);
	local CommonZScale = Support.IdentifyCommonItem(ZScaleVariations);
	local CommonXOffset = Support.IdentifyCommonItem(XOffsetVariations);
	local CommonYOffset = Support.IdentifyCommonItem(YOffsetVariations);
	local CommonZOffset = Support.IdentifyCommonItem(ZOffsetVariations);

	-- Shortcuts to updating UI elements
	local AddButton = MeshTool.UI.AddButton;
	local RemoveButton = MeshTool.UI.RemoveButton;
	local MeshTypeDropdown = MeshTool.UI.TypeOption.Dropdown;
	local MeshIdInput = MeshTool.UI.MeshIdOption.TextBox;
	local TextureIdInput = MeshTool.UI.TextureIdOption.TextBox;
	local VertexColorIndicator = MeshTool.UI.TintOption.Indicator;
	local XScaleInput = MeshTool.UI.ScaleOption.XInput.TextBox;
	local YScaleInput = MeshTool.UI.ScaleOption.YInput.TextBox;
	local ZScaleInput = MeshTool.UI.ScaleOption.ZInput.TextBox;
	local XOffsetInput = MeshTool.UI.OffsetOption.XInput.TextBox;
	local YOffsetInput = MeshTool.UI.OffsetOption.YInput.TextBox;
	local ZOffsetInput = MeshTool.UI.OffsetOption.ZInput.TextBox;

	-- Update the inputs
	UpdateDataInputs {
		[MeshIdInput] = MeshId and ParseAssetId(MeshId) or MeshId or '*';
		[TextureIdInput] = TextureId and ParseAssetId(TextureId) or TextureId or '*';
		[XScaleInput] = CommonXScale or '*';
		[YScaleInput] = CommonYScale or '*';
		[ZScaleInput] = CommonZScale or '*';
		[XOffsetInput] = CommonXOffset or '*';
		[YOffsetInput] = CommonYOffset or '*';
		[ZOffsetInput] = CommonZOffset or '*';
	};
	UpdateColorIndicator(VertexColorIndicator, VertexColor);

	local MeshTypeLabel = Support.FindTableOccurrence(MeshTypes, MeshType);
	TypeDropdown.SetOption(MeshTypeLabel and MeshTypeLabel or '*');

	AddButton.Visible = false;
	RemoveButton.Visible = false;
	MeshTool.UI.TypeOption.Visible = false;
	MeshIdInput.Parent.Visible = false;
	TextureIdInput.Parent.Visible = false;
	VertexColorIndicator.Parent.Visible = false;
	MeshTool.UI.ScaleOption.Visible = false;
	MeshTool.UI.OffsetOption.Visible = false;

	-- Update the UI to display options depending on the mesh type
	local DisplayedItems;
	if #Meshes == 0 then
		DisplayedItems = { AddButton };

	-- Each selected part has a mesh, including a file mesh
	elseif #Meshes == #Selection.Items and FileMeshInSelection then
		DisplayedItems = { MeshTool.UI.TypeOption, MeshTool.UI.ScaleOption, MeshTool.UI.OffsetOption, MeshIdInput.Parent, TextureIdInput.Parent, VertexColorIndicator.Parent, RemoveButton };

	-- Each selected part has a mesh
	elseif #Meshes == #Selection.Items and not FileMeshInSelection then
		DisplayedItems = { MeshTool.UI.TypeOption, MeshTool.UI.ScaleOption, MeshTool.UI.OffsetOption, RemoveButton };

	-- Only some selected parts have meshes, including a file mesh
	elseif #Meshes ~= #Selection.Items and FileMeshInSelection then
		DisplayedItems = { AddButton, MeshTool.UI.TypeOption, MeshTool.UI.ScaleOption, MeshTool.UI.OffsetOption, MeshIdInput.Parent, TextureIdInput.Parent, VertexColorIndicator.Parent, RemoveButton };

	-- Only some selected parts have meshes
	elseif #Meshes ~= #Selection.Items and not FileMeshInSelection then
		DisplayedItems = { AddButton, MeshTool.UI.TypeOption, MeshTool.UI.ScaleOption, MeshTool.UI.OffsetOption, RemoveButton };

	end;

	-- Display the relevant UI elements
	DisplayLinearLayout(DisplayedItems, MeshTool.UI, UDim2.new(0, 0, 0, 20), 10);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not MeshTool.UI then
		return;
	end;

	-- Hide the UI
	MeshTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function GetMeshes()
	-- Returns all the meshes in the selection

	local Meshes = {};

	-- Get any meshes from any selected parts
	for _, Part in pairs(Selection.Items) do
		table.insert(Meshes, Support.GetChildOfClass(Part, 'SpecialMesh'));
	end;

	-- Return the meshes
	return Meshes;
end;

function ParseAssetId(Input)
	-- Returns the intended asset ID for the given input

	-- Get the ID number from the input
	local Id = tonumber(Input)
		or tonumber(Input:lower():match('%?id=([0-9]+)'))
		or tonumber(Input:match('/([0-9]+)/'))
		or tonumber(Input:lower():match('rbxassetid://([0-9]+)'));

	-- Return the ID
	return Id;
end;

function VectorToColor(Vector)
	-- Returns the Color3 with the values in the given Vector3

	-- Make sure that the given Vector3 is valid
	if not Vector then return end;

	-- Return the Color3
	return Color3.new(Vector.X, Vector.Y, Vector.Z);
end;

function ColorToVector(Color)
	-- Returns the Vector3 with the values in the given Color3

	-- Make sure that the given Color3 is valid
	if not Color then return end;

	-- Return the Vector3
	return Vector3.new(Color.r, Color.g, Color.b);
end;

function UpdateDataInputs(Data)
	-- Updates the data in the given TextBoxes when the user isn't typing in them

	-- Go through the inputs and data
	for Input, UpdatedValue in pairs(Data) do

		-- Makwe sure the user isn't typing into the input
		if not Input:IsFocused() then

			-- Set the input's value
			Input.Text = tostring(UpdatedValue);

		end;

	end;

end;

function UpdateColorIndicator(Indicator, Color)
	-- Updates the given color indicator

	-- If there is a single color, just display it
	if Color then
		Indicator.BackgroundColor3 = Color;
		Indicator.Varies.Text = '';

	-- If the colors vary, display a * on a gray background
	else
		Indicator.BackgroundColor3 = Color3.new(222/255, 222/255, 222/255);
		Indicator.Varies.Text = '*';
	end;

end;

function DisplayLinearLayout(Items, Container, StartPosition, Padding)

	-- Keep track of the total vertical extents of all items
	local Sum = 0;

	-- Go through each item
	for ItemIndex, Item in ipairs(Items) do

		-- Make the item visible
		Item.Visible = true;

		-- Position this item underneath the past items
		Item.Position = StartPosition + UDim2.new(
			Item.Position.X.Scale,
			Item.Position.X.Offset,
			0,
			Sum + Padding
		);

		-- Update the sum of item heights
		Sum = Sum + Padding + Item.AbsoluteSize.Y;

	end;

	-- Resize the container to fit the new layout
	Container.Size = UDim2.new(0, 200, 0, 30 + Sum);

end;

function AddMeshes()

	-- Prepare the change request for the server
	local Changes = {};

	-- Go through the selection
	for _, Part in pairs(Selection.Items) do

		-- Make sure this part doesn't already have a mesh
		if not Support.GetChildOfClass(Part, 'SpecialMesh') then

			-- Queue a mesh to be created for this part
			table.insert(Changes, { Part = Part });

		end;

	end;

	-- Send the change request to the server
	local Meshes = Core.SyncAPI:Invoke('CreateMeshes', Changes);

	-- Put together the history record
	local HistoryRecord = {
		Meshes = Meshes;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Meshes, 'Parent'));

			-- Remove the meshes
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Meshes);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the meshes
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Meshes);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Meshes, 'Parent'));

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function RemoveMeshes()

	-- Get all the meshes in the selection
	local Meshes = GetMeshes();

	-- Create the history record
	local HistoryRecord = {
		Meshes = Meshes;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the meshes
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Meshes);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Meshes, 'Parent'));

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Meshes, 'Parent'));

			-- Remove the meshes
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Meshes);

		end;

	};

	-- Send the removal request
	Core.SyncAPI:Invoke('Remove', Meshes);

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function SetProperty(Property, Value)

	-- Make sure the given value is valid
	if not Value then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each mesh
	for _, Mesh in pairs(GetMeshes()) do

		-- Store the state of the mesh before modification
		table.insert(HistoryRecord.Before, { Part = Mesh.Parent, [Property] = Mesh[Property] });

		-- Create the change request for this mesh
		table.insert(HistoryRecord.After, { Part = Mesh.Parent, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetAxisScale(Axis, Scale)
	-- Sets the selection's scale on axis `Axis` to `Scale`

	-- Start a history record
	TrackChange();

	-- Go through each mesh
	for _, Mesh in pairs(GetMeshes()) do

		-- Store the state of the mesh before modification
		table.insert(HistoryRecord.Before, { Part = Mesh.Parent, Scale = Mesh.Scale });

		-- Put together the changed scale
		local Scale = Vector3.new(
			Axis == 'X' and Scale or Mesh.Scale.X,
			Axis == 'Y' and Scale or Mesh.Scale.Y,
			Axis == 'Z' and Scale or Mesh.Scale.Z
		);

		-- Create the change request for this mesh
		table.insert(HistoryRecord.After, { Part = Mesh.Parent, Scale = Scale });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetAxisOffset(Axis, Offset)
	-- Sets the selection's offset on axis `Axis` to `Offset`

	-- Start a history record
	TrackChange();

	-- Go through each mesh
	for _, Mesh in pairs(GetMeshes()) do

		-- Store the state of the mesh before modification
		table.insert(HistoryRecord.Before, { Part = Mesh.Parent, Offset = Mesh.Offset });

		-- Put together the changed scale
		local Offset = Vector3.new(
			Axis == 'X' and Offset or Mesh.Offset.X,
			Axis == 'Y' and Offset or Mesh.Offset.Y,
			Axis == 'Z' and Offset or Mesh.Offset.Z
		);

		-- Create the change request for this mesh
		table.insert(HistoryRecord.After, { Part = Mesh.Parent, Offset = Offset });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetMeshId(AssetId)
	-- Sets the meshes in the selection's mesh ID to the intended, given mesh asset

	-- Make sure the given asset ID is valid
	if not AssetId then
		return;
	end;

	-- Prepare the change request
	local Changes = {
		MeshId = 'rbxassetid://' .. AssetId;
	};

	-- Attempt a mesh extraction on the given asset
	Core.Try(Core.SyncAPI.Invoke, Core.SyncAPI, 'ExtractMeshFromAsset', AssetId)
		:Then(function (ExtractionData)

			-- Ensure extraction succeeded
			assert(ExtractionData.success, 'Extraction failed');

			-- Apply any mesh found
			local MeshId = ExtractionData.meshID;
			if MeshId then
				Changes.MeshId = 'rbxassetid://' .. MeshId;
			end;

			-- Apply any texture found
			local TextureId = ExtractionData.textureID;
			if TextureId then
				Changes.TextureId = 'rbxassetid://' .. TextureId;
			end;

			-- Apply any vertex color found
			local VertexColor = ExtractionData.tint;
			if VertexColor then
				Changes.VertexColor = Vector3.new(VertexColor.x, VertexColor.y, VertexColor.z);
			end;

			-- Apply any scale found
			local Scale = ExtractionData.scale;
			if Scale then
				Changes.Scale = Vector3.new(Scale.x, Scale.y, Scale.z);
			end;

		end);

	-- Start a history record
	TrackChange();

	-- Go through each mesh
	for _, Mesh in pairs(GetMeshes()) do

		-- Create the history change requests for this mesh
		local Before, After = { Part = Mesh.Parent }, { Part = Mesh.Parent };

		-- Gather change information to finish up the history change requests
		for Property, Value in pairs(Changes) do
			Before[Property] = Mesh[Property];
			After[Property] = Value;
		end;

		-- Store the state of the mesh before modification
		table.insert(HistoryRecord.Before, Before);

		-- Create the change request for this mesh
		table.insert(HistoryRecord.After, After);

	end;

	-- Register the changes
	RegisterChange();

end;

function SetTextureId(AssetId)
	-- Sets the meshes in the selection's texture ID to the intended, given image asset

	-- Make sure the given asset ID is valid
	if not AssetId then
		return;
	end;

	-- Prepare the change request
	local Changes = {
		TextureId = 'rbxassetid://' .. AssetId;
	};

	-- Attempt an image extraction on the given asset
	Core.Try(Core.SyncAPI.Invoke, Core.SyncAPI, 'ExtractImageFromDecal', AssetId)
		:Then(function (ExtractedImage)
			Changes.TextureId = 'rbxassetid://' .. ExtractedImage;
		end);

	-- Start a history record
	TrackChange();

	-- Go through each mesh
	for _, Mesh in pairs(GetMeshes()) do

		-- Create the history change requests for this mesh
		local Before, After = { Part = Mesh.Parent }, { Part = Mesh.Parent };

		-- Gather change information to finish up the history change requests
		for Property, Value in pairs(Changes) do
			Before[Property] = Mesh[Property];
			After[Property] = Value;
		end;

		-- Store the state of the mesh before modification
		table.insert(HistoryRecord.Before, Before);

		-- Create the change request for this mesh
		table.insert(HistoryRecord.After, After);

	end;

	-- Register the changes
	RegisterChange();

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMesh', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncMesh', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncMesh', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return MeshTool;
end;
};
G2L_MODULES[G2L["46"]] = {
Closure = function()
    local script = G2L["46"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local NewPartTool = {

	Name = 'New Part Tool';
	Color = BrickColor.new 'Really black';

	-- Default options
	Type = 'Normal';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function NewPartTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	EnableClickCreation();

	-- Set our current type
	SetType(NewPartTool.Type);

end;

function NewPartTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTNewPartToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- Creatable part types
	Types = { 'Normal', 'Truss', 'Wedge', 'Corner', 'Cylinder', 'Ball', 'Seat', 'Vehicle Seat', 'Spawn' };

	-- Create the type selection dropdown
	TypeDropdown = Core.Cheer(UI.TypeOption.Dropdown).Start(Types, '', function (Type)
		SetType(Type);
	end);

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

end;

function SetType(Type)

	-- Update the tool option
	NewPartTool.Type = Type;

	-- Update the UI
	TypeDropdown.SetOption(Type);

end;

function EnableClickCreation()
	-- Allows the user to click anywhere and create a new part

	-- Listen for clicks
	Connections.ClickCreationListener = UserInputService.InputBegan:connect(function (Input, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this was button 1 being released
		if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then
			return;
		end;

		-- Enable new part dragging
		DragNewParts = true;
		Core.Targeting.CancelSelecting();

		-- Create the part
		CreatePart(NewPartTool.Type);

	end);

	-- Listen for click releases
	Connections.ClickReleaseListener = Support.AddUserInputListener('Ended', 'MouseButton1', true, function ()

		-- Cancel dragging new parts if mouse button is released
		DragNewParts = false;

	end);

end;

function CreatePart(Type)

	-- Send the creation request to the server
	local Part = Core.SyncAPI:Invoke('CreatePart', Type, CFrame.new(Core.Mouse.Hit.p));

	-- Make sure the part creation succeeds
	if not Part then
		return;
	end;

	-- Put together the history record
	local HistoryRecord = {
		Part = Part;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Remove the part
			Core.SyncAPI:Invoke('Remove', { HistoryRecord.Part });

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the part
			Core.SyncAPI:Invoke('UndoRemove', { HistoryRecord.Part });

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

	-- Select the part
	Selection.Replace({ Part });

	-- Switch to the move tool
	local MoveTool = require(Core.Tool.Tools.MoveTool);
	Core.EquipTool(MoveTool);

	-- Enable dragging to allow easy positioning of the created part
	if DragNewParts then
		MoveTool.SetUpDragging(Part);
	end;

end;

-- Return the tool
return NewPartTool;
end;
};
G2L_MODULES[G2L["47"]] = {
Closure = function()
    local script = G2L["47"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local CollisionTool = {

	Name = 'Collision Tool';
	Color = BrickColor.new 'Really black';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function CollisionTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	BindShortcutKeys();

end;

function CollisionTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if UI then

		-- Reveal the UI
		UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	UI = Core.Tool.Interfaces.BTCollisionToolGUI:Clone();
	UI.Parent = Core.UI;
	UI.Visible = true;

	-- References to UI elements
	local OnButton = UI.Status.On.Button;
	local OffButton = UI.Status.Off.Button;

	-- Enable the collision status switch
	OnButton.MouseButton1Click:connect(function ()
		SetProperty('CanCollide', true);
	end);
	OffButton.MouseButton1Click:connect(function ()
		SetProperty('CanCollide', false);
	end);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not UI then
		return;
	end;

	-- Check the common collision status of selection
	local Collision = Support.IdentifyCommonProperty(Selection.Items, 'CanCollide');

	-- Update the collision option switch
	if Collision == true then
		Core.ToggleSwitch('On', UI.Status);

	-- If the selection has collision disabled
	elseif Collision == false then
		Core.ToggleSwitch('Off', UI.Status);

	-- If the collision status varies, don't select a current switch
	elseif Collision == nil then
		Core.ToggleSwitch(nil, UI.Status);
	end;

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not UI then
		return;
	end;

	-- Hide the UI
	UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function SetProperty(Property, Value)

	-- Make sure the given value is valid
	if Value == nil then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each part
	for _, Part in pairs(Selection.Items) do

		-- Store the state of the part before modification
		table.insert(HistoryRecord.Before, { Part = Part, [Property] = Part[Property] });

		-- Create the change request for this part
		table.insert(HistoryRecord.After, { Part = Part, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function BindShortcutKeys()
	-- Enables useful shortcut keys for this tool

	-- Track user input while this tool is equipped
	table.insert(Connections, UserInputService.InputBegan:connect(function (InputInfo, GameProcessedEvent)

		-- Make sure this is an intentional event
		if GameProcessedEvent then
			return;
		end;

		-- Make sure this input is a key press
		if InputInfo.UserInputType ~= Enum.UserInputType.Keyboard then
			return;
		end;

		-- Make sure it wasn't pressed while typing
		if UserInputService:GetFocusedTextBox() then
			return;
		end;

		-- Check if the enter key was pressed
		if InputInfo.KeyCode == Enum.KeyCode.Return or InputInfo.KeyCode == Enum.KeyCode.KeypadEnter then

			-- Toggle the selection's collision status
			ToggleCollision();

		end;

	end));

end;

function ToggleCollision()
	-- Toggles the collision status of the selection

	-- Change the collision status to the opposite of the common collision status
	SetProperty('CanCollide', not Support.IdentifyCommonProperty(Selection.Items, 'CanCollide'));

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncCollision', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncCollision', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncCollision', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

-- Return the tool
return CollisionTool;
end;
};
G2L_MODULES[G2L["48"]] = {
Closure = function()
    local script = G2L["48"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local LightingTool = {

	Name = 'Lighting Tool';
	Color = BrickColor.new 'Really black';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function LightingTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();
	EnableSurfaceClickSelection();

end;

function LightingTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if LightingTool.UI then

		-- Reveal the UI
		LightingTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	LightingTool.UI = Core.Tool.Interfaces.BTLightingToolGUI:Clone();
	LightingTool.UI.Parent = Core.UI;
	LightingTool.UI.Visible = true;

	-- Enable each light type UI
	EnableLightSettingsUI(LightingTool.UI.PointLight);
	EnableLightSettingsUI(LightingTool.UI.SpotLight);
	EnableLightSettingsUI(LightingTool.UI.SurfaceLight);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

function EnableSurfaceClickSelection(LightType)
	-- Allows for the setting of the face for the given light type by clicking

	-- Clear out any existing connection
	if Connections.SurfaceClickSelection then
		Connections.SurfaceClickSelection:disconnect();
		Connections.SurfaceClickSelection = nil;
	end;

	-- Add the new click connection
	Connections.SurfaceClickSelection = UserInputService.InputEnded:connect(function (Input, GameProcessedEvent)
		if not GameProcessedEvent and Input.UserInputType == Enum.UserInputType.MouseButton1 and Selection.IsSelected(Core.Mouse.Target) then
			SetSurface(LightType, Core.Mouse.TargetSurface);
		end;
	end);

end;

function EnableLightSettingsUI(LightSettingsUI)
	-- Sets up the UI for the given light type settings UI

	-- Get the type of light this settings UI is for
	local LightType = LightSettingsUI.Name;

	-- Option input references
	local Options = LightSettingsUI.Options;
	local RangeInput = Options.RangeOption.Input.TextBox;
	local BrightnessInput = Options.BrightnessOption.Input.TextBox;
	local ColorPicker = Options.ColorOption.HSVPicker;
	local ShadowsCheckbox = Options.ShadowsOption.Checkbox;

	-- Add/remove/show button references
	local AddButton = LightSettingsUI.AddButton;
	local RemoveButton = LightSettingsUI.RemoveButton;
	local ShowButton = LightSettingsUI.ArrowButton;

	-- Enable range input
	RangeInput.FocusLost:connect(function ()
		SetRange(LightType, tonumber(RangeInput.Text));
	end);

	-- Enable brightness input
	BrightnessInput.FocusLost:connect(function ()
		SetBrightness(LightType, tonumber(BrightnessInput.Text));
	end);

	-- Enable color input
	ColorPicker.MouseButton1Click:connect(function ()
		Core.Cheer(Core.Tool.Interfaces.BTHSVColorPicker, Core.UI).Start(
			Support.IdentifyCommonProperty(GetLights(LightType), 'Color') or Color3.new(1, 1, 1),
			function (Color) SetColor(LightType, Color) end,
			Core.Targeting.CancelSelecting
		);
	end);

	-- Enable shadows input
	ShadowsCheckbox.MouseButton1Click:connect(function ()
		ToggleShadows(LightType);
	end);

	-- Enable light addition button
	AddButton.MouseButton1Click:connect(function ()
		AddLights(LightType);
	end);

	-- Enable light removal button
	RemoveButton.MouseButton1Click:connect(function ()
		RemoveLights(LightType);
	end);

	-- Enable light options UI show button
	ShowButton.MouseButton1Click:connect(function ()
		OpenLightOptions(LightType);
	end);

	-- Enable light type-specific features
	if LightType == 'SpotLight' or LightType == 'SurfaceLight' then

		-- Create a surface selection dropdown
		Surfaces = { 'Top', 'Bottom', 'Front', 'Back', 'Left', 'Right' };
		local SurfaceDropdown = Core.Cheer(Options.SideOption.Dropdown).Start(Surfaces, '', function (Surface)
			SetSurface(LightType, Enum.NormalId[Surface]);
		end);

		-- Enable angle input
		local AngleInput = Options.AngleOption.Input.TextBox;
		AngleInput.FocusLost:connect(function ()
			SetAngle(LightType, tonumber(AngleInput.Text));
		end);

	end;

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not LightingTool.UI then
		return;
	end;

	-- Hide the UI
	LightingTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function GetLights(LightType)
	-- Returns all the lights of the given type in the selection

	local Lights = {};

	-- Get any lights from any selected parts
	for _, Part in pairs(Selection.Items) do
		table.insert(Lights, Support.GetChildOfClass(Part, LightType));
	end;

	-- Return the lights
	return Lights;

end;

-- List of creatable light types
local LightTypes = { 'SpotLight', 'PointLight', 'SurfaceLight' };

function OpenLightOptions(LightType)
	-- Opens the settings UI for the given light type

	-- Get the UI
	local UI = LightingTool.UI[LightType];
	local UITemplate = Core.Tool.Interfaces.BTLightingToolGUI[LightType];

	-- Close up all light option UIs
	CloseLightOptions(LightType);

	-- Calculate how much to expand this options UI by
	local HeightExpansion = UDim2.new(0, 0, 0, UITemplate.Options.Size.Y.Offset);

	-- Start the options UI size from 0
	UI.Options.Size = UDim2.new(UI.Options.Size.X.Scale, UI.Options.Size.X.Offset, UI.Options.Size.Y.Scale, 0);

	-- Allow the options UI to be seen
	UI.ClipsDescendants = false;

	-- Perform the options UI resize animation
	UI.Options:TweenSize(
		UITemplate.Options.Size + HeightExpansion,
		Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true,
		function ()

			-- Allow visibility of overflowing UIs within the options UI
			UI.Options.ClipsDescendants = false;

		end
	);

	-- Expand the main UI to accommodate the expanded options UI
	LightingTool.UI:TweenSize(
		Core.Tool.Interfaces.BTLightingToolGUI.Size + HeightExpansion,
		Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
	);

	-- Push any UIs below this one downwards
	local LightTypeIndex = Support.FindTableOccurrence(LightTypes, LightType);
	for LightTypeIndex = LightTypeIndex + 1, #LightTypes do

		-- Get the UI
		local LightType = LightTypes[LightTypeIndex];
		local UI = LightingTool.UI[LightType];

		-- Perform the position animation
		UI:TweenPosition(
			UDim2.new(
				UI.Position.X.Scale,
				UI.Position.X.Offset,
				UI.Position.Y.Scale,
				30 + 30 * (LightTypeIndex - 1) + HeightExpansion.Y.Offset
			),
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);

	end;

	-- Enable surface setting by clicking
	EnableSurfaceClickSelection(LightType);

end;

function CloseLightOptions(Exception)
	-- Closes all light options, except the one for the given light type

	-- Go through each light type
	for LightTypeIndex, LightType in pairs(LightTypes) do

		-- Get the UI for each light type
		local UI = LightingTool.UI[LightType];
		local UITemplate = Core.Tool.Interfaces.BTLightingToolGUI[LightType];

		-- Remember the initial size for each options UI
		local InitialSize = UITemplate.Options.Size;

		-- Move each light type UI to its starting position
		UI:TweenPosition(
			UDim2.new(
				UI.Position.X.Scale,
				UI.Position.X.Offset,
				UI.Position.Y.Scale,
				30 + 30 * (LightTypeIndex - 1)
			),
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);

		-- Make sure to not resize the exempt light type UI
		if not Exception or Exception and LightType ~= Exception then

			-- Allow the options UI to be resized
			UI.Options.ClipsDescendants = true;

			-- Perform the resize animation to close up
			UI.Options:TweenSize(
				UDim2.new(UI.Options.Size.X.Scale, UI.Options.Size.X.Offset, UI.Options.Size.Y.Scale, 0),
				Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true,
				function ()

					-- Hide the option UI
					UI.ClipsDescendants = true;

					-- Set the options UI's size to its initial size (for reexpansion)
					UI.Options.Size = InitialSize;

				end
			);

		end;

	end;

	-- Contract the main UI if no option UIs are being opened
	if not Exception then
		LightingTool.UI:TweenSize(
			Core.Tool.Interfaces.BTLightingToolGUI.Size,
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);
	end;

end;

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not LightingTool.UI then
		return;
	end;

	-- Go through each light type and update each options UI
	for _, LightType in pairs(LightTypes) do

		local Lights = GetLights(LightType);
		local LightSettingsUI = LightingTool.UI[LightType];

		-- Option input references
		local Options = LightSettingsUI.Options;
		local RangeInput = Options.RangeOption.Input.TextBox;
		local BrightnessInput = Options.BrightnessOption.Input.TextBox;
		local ColorPicker = Options.ColorOption.HSVPicker;
		local ColorIndicator = Options.ColorOption.Indicator;
		local ShadowsCheckbox = Options.ShadowsOption.Checkbox;

		-- Add/remove button references
		local AddButton = LightSettingsUI.AddButton;
		local RemoveButton = LightSettingsUI.RemoveButton;

		-- Hide option UIs for light types not present in the selection
		if #Lights == 0 and not LightSettingsUI.ClipsDescendants then
			CloseLightOptions();
		end;

		-------------------------------------------
		-- Show and hide "ADD" and "REMOVE" buttons
		-------------------------------------------

		-- If no selected parts have lights
		if #Lights == 0 then

			-- Show add button only
			AddButton.Visible = true;
			AddButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5, 0, 3);
			RemoveButton.Visible = false;

		-- If only some selected parts have lights
		elseif #Lights < #Selection.Items then

			-- Show both add and remove buttons
			AddButton.Visible = true;
			AddButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5, 0, 3);
			RemoveButton.Visible = true;
			RemoveButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5 - RemoveButton.AbsoluteSize.X - 2, 0, 3);

		-- If all selected parts have lights
		elseif #Lights == #Selection.Items then

			-- Show remove button
			RemoveButton.Visible = true;
			RemoveButton.Position = UDim2.new(1, -RemoveButton.AbsoluteSize.X - 5, 0, 3);
			AddButton.Visible = false;

		end;

		--------------------
		-- Update each input
		--------------------

		-- Update the standard inputs
		UpdateDataInputs {
			[RangeInput] = Support.Round(Support.IdentifyCommonProperty(Lights, 'Range'), 2) or '*';
			[BrightnessInput] = Support.Round(Support.IdentifyCommonProperty(Lights, 'Brightness'), 2) or '*';
		};

		-- Update type-specific inputs
		if LightType == 'SpotLight' or LightType == 'SurfaceLight' then

			-- Get the type-specific inputs
			local AngleInput = Options.AngleOption.Input.TextBox;
			local SideDropdown = Core.Cheer(Options.SideOption.Dropdown);

			-- Update the angle input
			UpdateDataInputs {
				[AngleInput] = Support.Round(Support.IdentifyCommonProperty(Lights, 'Angle'), 2) or '*';
			};

			-- Update the surface dropdown input
			local Face = Support.IdentifyCommonProperty(Lights, 'Face');
			SideDropdown.SetOption(Face and Face.Name or '*');

		end;

		-- Update special color input
		local Color = Support.IdentifyCommonProperty(Lights, 'Color');
		if Color then
			ColorIndicator.BackgroundColor3 = Color;
			ColorIndicator.Varies.Text = '';
		else
			ColorIndicator.BackgroundColor3 = Color3.new(222/255, 222/255, 222/255);
			ColorIndicator.Varies.Text = '*';
		end;

		-- Update the special shadows input
		local ShadowsEnabled = Support.IdentifyCommonProperty(Lights, 'Shadows');
		if ShadowsEnabled == true then
			ShadowsCheckbox.Image = Core.Assets.CheckedCheckbox;
		elseif ShadowsEnabled == false then
			ShadowsCheckbox.Image = Core.Assets.UncheckedCheckbox;
		elseif ShadowsEnabled == nil then
			ShadowsCheckbox.Image = Core.Assets.SemicheckedCheckbox;
		end;

	end;

end;

function UpdateDataInputs(Data)
	-- Updates the data in the given TextBoxes when the user isn't typing in them

	-- Go through the inputs and data
	for Input, UpdatedValue in pairs(Data) do

		-- Makwe sure the user isn't typing into the input
		if not Input:IsFocused() then

			-- Set the input's value
			Input.Text = tostring(UpdatedValue);

		end;

	end;

end;

function AddLights(LightType)

	-- Prepare the change request for the server
	local Changes = {};

	-- Go through the selection
	for _, Part in pairs(Selection.Items) do

		-- Make sure this part doesn't already have a light
		if not Support.GetChildOfClass(Part, LightType) then

			-- Queue a light to be created for this part
			table.insert(Changes, { Part = Part, LightType = LightType });

		end;

	end;

	-- Send the change request to the server
	local Lights = Core.SyncAPI:Invoke('CreateLights', Changes);

	-- Put together the history record
	local HistoryRecord = {
		Lights = Lights;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Lights, 'Parent'));

			-- Remove the lights
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Lights);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the lights
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Lights);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Lights, 'Parent'));

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

	-- Open the options UI for this light type
	OpenLightOptions(LightType);

end;

function RemoveLights(LightType)

	-- Get all the lights in the selection
	local Lights = GetLights(LightType);

	-- Create the history record
	local HistoryRecord = {
		Lights = Lights;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the lights
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Lights);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Lights, 'Parent'));

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Lights, 'Parent'));

			-- Remove the lights
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Lights);

		end;

	};

	-- Send the removal request
	Core.SyncAPI:Invoke('Remove', Lights);

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncLighting', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncLighting', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncLighting', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

function SetRange(LightType, Range)

	-- Make sure the given range is valid
	if not Range then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Range = Light.Range });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Range = Range });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetBrightness(LightType, Brightness)

	-- Make sure the given brightness is valid
	if not Brightness then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Brightness = Light.Brightness });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Brightness = Brightness });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetColor(LightType, Color)

	-- Make sure the given color is valid
	if not Color then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Color = Light.Color });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Color = Color });

	end;

	-- Register the changes
	RegisterChange();

end;

function ToggleShadows(LightType)

	-- Determine whether to turn shadows on or off
	local ShadowsEnabled = not Support.IdentifyCommonProperty(GetLights(LightType), 'Shadows');

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Shadows = Light.Shadows });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Shadows = ShadowsEnabled });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetSurface(LightType, Face)

	-- Make sure the given face is valid, and this is an applicable light type
	if not Face or not (LightType == 'SurfaceLight' or LightType == 'SpotLight') then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Face = Light.Face });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Face = Face });

	end;

	-- Register the changes
	RegisterChange();

end;

function SetAngle(LightType, Angle)

	-- Make sure the given angle is valid
	if not Angle then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each light
	for _, Light in pairs(GetLights(LightType)) do

		-- Store the state of the light before modification
		table.insert(HistoryRecord.Before, { Part = Light.Parent, LightType = LightType, Angle = Light.Angle });

		-- Create the change request for this light
		table.insert(HistoryRecord.After, { Part = Light.Parent, LightType = LightType, Angle = Angle });

	end;

	-- Register the changes
	RegisterChange();

end;

-- Return the tool
return LightingTool;
end;
};
G2L_MODULES[G2L["49"]] = {
Closure = function()
    local script = G2L["49"];Tool = script.Parent.Parent;
Core = require(Tool.Core);

-- Import relevant references
Selection = Core.Selection;
Create = Core.Create;
Support = Core.Support;
Security = Core.Security;
Support.ImportServices();

-- Initialize the tool
local DecorateTool = {

	Name = 'Decorate Tool';
	Color = BrickColor.new 'Really black';

};

-- Container for temporary connections (disconnected automatically)
local Connections = {};

function DecorateTool.Equip()
	-- Enables the tool's equipped functionality

	-- Start up our interface
	ShowUI();

end;

function DecorateTool.Unequip()
	-- Disables the tool's equipped functionality

	-- Clear unnecessary resources
	HideUI();
	ClearConnections();

end;

function ClearConnections()
	-- Clears out temporary connections

	for ConnectionKey, Connection in pairs(Connections) do
		Connection:disconnect();
		Connections[ConnectionKey] = nil;
	end;

end;

function ShowUI()
	-- Creates and reveals the UI

	-- Reveal UI if already created
	if DecorateTool.UI then

		-- Reveal the UI
		DecorateTool.UI.Visible = true;

		-- Update the UI every 0.1 seconds
		UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

		-- Skip UI creation
		return;

	end;

	-- Create the UI
	DecorateTool.UI = Core.Tool.Interfaces.BTDecorateToolGUI:Clone();
	DecorateTool.UI.Parent = Core.UI;
	DecorateTool.UI.Visible = true;

	-- Enable each decoration type UI
	EnableOptionsUI(DecorateTool.UI.Smoke);
	EnableOptionsUI(DecorateTool.UI.Fire);
	EnableOptionsUI(DecorateTool.UI.Sparkles);

	-- Update the UI every 0.1 seconds
	UIUpdater = Support.ScheduleRecurringTask(UpdateUI, 0.1);

end;

-- List of creatable decoration types
local DecorationTypes = { 'Smoke', 'Fire', 'Sparkles' };

function UpdateUI()
	-- Updates information on the UI

	-- Make sure the UI's on
	if not DecorateTool.UI then
		return;
	end;

	-- Go through each decoration type and update each options UI
	for _, DecorationType in pairs(DecorationTypes) do

		local Decorations = GetDecorations(DecorationType);
		local DecorationSettingsUI = DecorateTool.UI[DecorationType];

		-- Option input references
		local Options = DecorationSettingsUI.Options;

		-- Add/remove button references
		local AddButton = DecorationSettingsUI.AddButton;
		local RemoveButton = DecorationSettingsUI.RemoveButton;

		-- Hide option UIs for decoration types not present in the selection
		if #Decorations == 0 and not DecorationSettingsUI.ClipsDescendants then
			CloseOptions();
		end;

		-------------------------------------------
		-- Show and hide "ADD" and "REMOVE" buttons
		-------------------------------------------

		-- If no selected parts have decorations
		if #Decorations == 0 then

			-- Show add button only
			AddButton.Visible = true;
			AddButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5, 0, 3);
			RemoveButton.Visible = false;

		-- If only some selected parts have decorations
		elseif #Decorations < #Selection.Items then

			-- Show both add and remove buttons
			AddButton.Visible = true;
			AddButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5, 0, 3);
			RemoveButton.Visible = true;
			RemoveButton.Position = UDim2.new(1, -AddButton.AbsoluteSize.X - 5 - RemoveButton.AbsoluteSize.X - 2, 0, 3);

		-- If all selected parts have decorations
		elseif #Decorations == #Selection.Items then

			-- Show remove button
			RemoveButton.Visible = true;
			RemoveButton.Position = UDim2.new(1, -RemoveButton.AbsoluteSize.X - 5, 0, 3);
			AddButton.Visible = false;

		end;

		--------------------
		-- Update each input
		--------------------

		-- Update smoke inputs
		if DecorationType == 'Smoke' then

			-- Get the inputs
			local SizeInput = Options.SizeOption.Input.TextBox;
			local VelocityInput = Options.VelocityOption.Input.TextBox;
			local OpacityInput = Options.OpacityOption.Input.TextBox;
			local ColorIndicator = Options.ColorOption.Indicator;

			-- Update the inputs
			UpdateDataInputs {
				[SizeInput] = Support.Round(Support.IdentifyCommonProperty(Decorations, 'Size'), 2) or '*';
				[VelocityInput] = Support.Round(Support.IdentifyCommonProperty(Decorations, 'RiseVelocity'), 2) or '*';
				[OpacityInput] = Support.Round(Support.IdentifyCommonProperty(Decorations, 'Opacity'), 2) or '*';
			};
			UpdateColorIndicator(ColorIndicator, Support.IdentifyCommonProperty(Decorations, 'Color'));

		-- Update fire inputs
		elseif DecorationType == 'Fire' then

			-- Get the inputs
			local SizeInput = Options.SizeOption.Input.TextBox;
			local HeatInput = Options.HeatOption.Input.TextBox;
			local SecondaryColorIndicator = Options.SecondaryColorOption.Indicator;
			local ColorIndicator = Options.ColorOption.Indicator;

			-- Update the inputs
			UpdateColorIndicator(ColorIndicator, Support.IdentifyCommonProperty(Decorations, 'Color'));
			UpdateColorIndicator(SecondaryColorIndicator, Support.IdentifyCommonProperty(Decorations, 'SecondaryColor'));
			UpdateDataInputs {
				[HeatInput] = Support.Round(Support.IdentifyCommonProperty(Decorations, 'Heat'), 2) or '*';
				[SizeInput] = Support.Round(Support.IdentifyCommonProperty(Decorations, 'Size'), 2) or '*';
			};

		-- Update sparkle inputs
		elseif DecorationType == 'Sparkles' then

			-- Get the inputs
			local ColorIndicator = Options.ColorOption.Indicator;

			-- Update the inputs
			UpdateColorIndicator(ColorIndicator, Support.IdentifyCommonProperty(Decorations, 'SparkleColor'));

		end;

	end;

end;

function HideUI()
	-- Hides the tool UI

	-- Make sure there's a UI
	if not DecorateTool.UI then
		return;
	end;

	-- Hide the UI
	DecorateTool.UI.Visible = false;

	-- Stop updating the UI
	UIUpdater:Stop();

end;

function GetDecorations(DecorationType)
	-- Returns all the decorations of the given type in the selection

	local Decorations = {};

	-- Get any decorations from any selected parts
	for _, Part in pairs(Selection.Items) do
		table.insert(Decorations, Support.GetChildOfClass(Part, DecorationType));
	end;

	-- Return the decorations
	return Decorations;

end;

function UpdateColorIndicator(Indicator, Color)
	-- Updates the given color indicator

	-- If there is a single color, just display it
	if Color then
		Indicator.BackgroundColor3 = Color;
		Indicator.Varies.Text = '';

	-- If the colors vary, display a * on a gray background
	else
		Indicator.BackgroundColor3 = Color3.new(222/255, 222/255, 222/255);
		Indicator.Varies.Text = '*';
	end;

end;

function UpdateDataInputs(Data)
	-- Updates the data in the given TextBoxes when the user isn't typing in them

	-- Go through the inputs and data
	for Input, UpdatedValue in pairs(Data) do

		-- Make sure the user isn't typing into the input
		if not Input:IsFocused() then

			-- Set the input's value
			Input.Text = tostring(UpdatedValue);

		end;

	end;

end;

function TrackChange()

	-- Start the record
	HistoryRecord = {
		Before = {};
		After = {};

		Unapply = function (Record)
			-- Reverts this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.Before, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncDecorate', Record.Before);

		end;

		Apply = function (Record)
			-- Applies this change

			-- Select the changed parts
			Selection.Replace(Support.GetListMembers(Record.After, 'Part'));

			-- Send the change request
			Core.SyncAPI:Invoke('SyncDecorate', Record.After);

		end;

	};

end;

function RegisterChange()
	-- Finishes creating the history record and registers it

	-- Make sure there's an in-progress history record
	if not HistoryRecord then
		return;
	end;

	-- Send the change to the server
	Core.SyncAPI:Invoke('SyncDecorate', HistoryRecord.After);

	-- Register the record and clear the staging
	Core.History.Add(HistoryRecord);
	HistoryRecord = nil;

end;

function EnableOptionsUI(SettingsUI)
	-- Sets up the UI for the given decoration type settings UI

	-- Get the type of decoration this options UI is for
	local DecorationType = SettingsUI.Name;

	-- Option input references
	local Options = SettingsUI.Options;
	
	-- Add/remove/show button references
	local AddButton = SettingsUI.AddButton;
	local RemoveButton = SettingsUI.RemoveButton;
	local ShowButton = SettingsUI.ArrowButton;

	-- Enable options for smoke decorations
	if DecorationType == 'Smoke' then
		SyncInputToProperty('Color', DecorationType, 'Color', Options.ColorOption.HSVPicker);
		SyncInputToProperty('Size', DecorationType, 'Number', Options.SizeOption.Input.TextBox);
		SyncInputToProperty('RiseVelocity', DecorationType, 'Number', Options.VelocityOption.Input.TextBox);
		SyncInputToProperty('Opacity', DecorationType, 'Number', Options.OpacityOption.Input.TextBox);

	-- Enable options for fire decorations
	elseif DecorationType == 'Fire' then
		SyncInputToProperty('Color', DecorationType, 'Color', Options.ColorOption.HSVPicker);
		SyncInputToProperty('SecondaryColor', DecorationType, 'Color', Options.SecondaryColorOption.HSVPicker);
		SyncInputToProperty('Size', DecorationType, 'Number', Options.SizeOption.Input.TextBox);
		SyncInputToProperty('Heat', DecorationType, 'Number', Options.HeatOption.Input.TextBox);

	-- Enable options for sparkle decorations
	elseif DecorationType == 'Sparkles' then
		SyncInputToProperty('SparkleColor', DecorationType, 'Color', Options.ColorOption.HSVPicker);

	end;

	-- Enable decoration addition button
	AddButton.MouseButton1Click:connect(function ()
		AddDecorations(DecorationType);
	end);

	-- Enable decoration removal button
	RemoveButton.MouseButton1Click:connect(function ()
		RemoveDecorations(DecorationType);
	end);

	-- Enable decoration options UI show button
	ShowButton.MouseButton1Click:connect(function ()
		OpenOptions(DecorationType);
	end);

end;

function OpenOptions(DecorationType)
	-- Opens the options UI for the given decoration type

	-- Get the UI
	local UI = DecorateTool.UI[DecorationType];
	local UITemplate = Core.Tool.Interfaces.BTDecorateToolGUI[DecorationType];

	-- Close up all decoration option UIs
	CloseOptions(DecorationType);

	-- Calculate how much to expand this options UI by
	local HeightExpansion = UDim2.new(0, 0, 0, UITemplate.Options.Size.Y.Offset);

	-- Start the options UI size from 0
	UI.Options.Size = UDim2.new(UI.Options.Size.X.Scale, UI.Options.Size.X.Offset, UI.Options.Size.Y.Scale, 0);

	-- Allow the options UI to be seen
	UI.ClipsDescendants = false;

	-- Perform the options UI resize animation
	UI.Options:TweenSize(
		UITemplate.Options.Size + HeightExpansion,
		Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true,
		function ()

			-- Allow visibility of overflowing UIs within the options UI
			UI.Options.ClipsDescendants = false;

		end
	);

	-- Expand the main UI to accommodate the expanded options UI
	DecorateTool.UI:TweenSize(
		Core.Tool.Interfaces.BTDecorateToolGUI.Size + HeightExpansion,
		Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
	);

	-- Push any UIs below this one downwards
	local DecorationTypeIndex = Support.FindTableOccurrence(DecorationTypes, DecorationType);
	for DecorationTypeIndex = DecorationTypeIndex + 1, #DecorationTypes do

		-- Get the UI
		local DecorationType = DecorationTypes[DecorationTypeIndex];
		local UI = DecorateTool.UI[DecorationType];

		-- Perform the position animation
		UI:TweenPosition(
			UDim2.new(
				UI.Position.X.Scale,
				UI.Position.X.Offset,
				UI.Position.Y.Scale,
				30 + 30 * (DecorationTypeIndex - 1) + HeightExpansion.Y.Offset
			),
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);

	end;

end;

function CloseOptions(Exception)
	-- Closes all decoration options, except the one for the given decoration type

	-- Go through each decoration type
	for DecorationTypeIndex, DecorationType in pairs(DecorationTypes) do

		-- Get the UI for each decoration type
		local UI = DecorateTool.UI[DecorationType];
		local UITemplate = Core.Tool.Interfaces.BTDecorateToolGUI[DecorationType];

		-- Remember the initial size for each options UI
		local InitialSize = UITemplate.Options.Size;

		-- Move each decoration type UI to its starting position
		UI:TweenPosition(
			UDim2.new(
				UI.Position.X.Scale,
				UI.Position.X.Offset,
				UI.Position.Y.Scale,
				30 + 30 * (DecorationTypeIndex - 1)
			),
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);
		
		-- Make sure to not resize the exempt decoration type UI
		if not Exception or Exception and DecorationType ~= Exception then

			-- Allow the options UI to be resized
			UI.Options.ClipsDescendants = true;

			-- Perform the resize animation to close up
			UI.Options:TweenSize(
				UDim2.new(UI.Options.Size.X.Scale, UI.Options.Size.X.Offset, UI.Options.Size.Y.Scale, 0),
				Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true,
				function ()

					-- Hide the option UI
					UI.ClipsDescendants = true;

					-- Set the options UI's size to its initial size (for reexpansion)
					UI.Options.Size = InitialSize;

				end
			);

		end;

	end;

	-- Contract the main UI if no option UIs are being opened
	if not Exception then
		DecorateTool.UI:TweenSize(
			Core.Tool.Interfaces.BTDecorateToolGUI.Size,
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true
		);
	end;

end;

function SyncInputToProperty(Property, DecorationType, InputType, Input)
	-- Enables `Input` to change the given property

	-- Enable inputs
	if InputType == 'Color' then
		Input.MouseButton1Click:connect(function ()
			Core.Cheer(Core.Tool.Interfaces.BTHSVColorPicker, Core.UI).Start(
				Support.IdentifyCommonProperty(GetDecorations(DecorationType), Property) or Color3.new(0, 0, 1),
				function (Color) SetProperty(DecorationType, Property, Color) end,
				Core.Targeting.CancelSelecting
			);
		end);

	-- Enable number inputs
	elseif InputType == 'Number' then
		Input.FocusLost:connect(function ()
			SetProperty(DecorationType, Property, tonumber(Input.Text));
		end);

	end;

end;

function SetProperty(DecorationType, Property, Value)

	-- Make sure the given value is valid
	if not Value then
		return;
	end;

	-- Start a history record
	TrackChange();

	-- Go through each decoration
	for _, Decoration in pairs(GetDecorations(DecorationType)) do

		-- Store the state of the decoration before modification
		table.insert(HistoryRecord.Before, { Part = Decoration.Parent, DecorationType = DecorationType, [Property] = Decoration[Property] });

		-- Create the change request for this decoration
		table.insert(HistoryRecord.After, { Part = Decoration.Parent, DecorationType = DecorationType, [Property] = Value });

	end;

	-- Register the changes
	RegisterChange();

end;

function AddDecorations(DecorationType)

	-- Prepare the change request for the server
	local Changes = {};

	-- Go through the selection
	for _, Part in pairs(Selection.Items) do

		-- Make sure this part doesn't already have a decoration
		if not Support.GetChildOfClass(Part, DecorationType) then

			-- Queue a decoration to be created for this part
			table.insert(Changes, { Part = Part, DecorationType = DecorationType });

		end;

	end;

	-- Send the change request to the server
	local Decorations = Core.SyncAPI:Invoke('CreateDecorations', Changes);

	-- Put together the history record
	local HistoryRecord = {
		Decorations = Decorations;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Decorations, 'Parent'));

			-- Remove the decorations
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Decorations);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the decorations
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Decorations);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Decorations, 'Parent'));

		end;

	};

	-- Register the history record
	Core.History.Add(HistoryRecord);

	-- Open the options UI for this decoration type
	OpenOptions(DecorationType);

end;

function RemoveDecorations(DecorationType)

	-- Get all the decorations in the selection
	local Decorations = GetDecorations(DecorationType);

	-- Create the history record
	local HistoryRecord = {
		Decorations = Decorations;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the decorations
			Core.SyncAPI:Invoke('UndoRemove', HistoryRecord.Decorations);

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Decorations, 'Parent'));

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Select changed parts
			Selection.Replace(Support.GetListMembers(HistoryRecord.Decorations, 'Parent'));

			-- Remove the decorations
			Core.SyncAPI:Invoke('Remove', HistoryRecord.Decorations);

		end;

	};

	-- Send the removal request
	Core.SyncAPI:Invoke('Remove', Decorations);

	-- Register the history record
	Core.History.Add(HistoryRecord);

end;

-- Return the tool
return DecorateTool;
end;
};
G2L_MODULES[G2L["4a"]] = {
Closure = function()
    local script = G2L["4a"];local CoreTools = script.Parent;
local Tool = CoreTools.Parent;
local Core = require(Tool.Core);

-- Initialize move tool
local MoveTool = require(CoreTools.MoveTool);
Core.AssignHotkey('Z', Core.Support.Call(Core.EquipTool, MoveTool));
Core.Dock.AddToolButton(Core.Assets.MoveIcon, 'Z', MoveTool, 'MoveInfo');

-- Initialize resize tool
local ResizeTool = require(CoreTools.ResizeTool)
Core.AssignHotkey('X', Core.Support.Call(Core.EquipTool, ResizeTool));
Core.Dock.AddToolButton(Core.Assets.ResizeIcon, 'X', ResizeTool, 'ResizeInfo');

-- Initialize rotate tool
local RotateTool = require(CoreTools.RotateTool)
Core.AssignHotkey('C', Core.Support.Call(Core.EquipTool, RotateTool));
Core.Dock.AddToolButton(Core.Assets.RotateIcon, 'C', RotateTool, 'RotateInfo');

-- Initialize paint tool
local PaintTool = require(CoreTools.PaintTool)
Core.AssignHotkey('V', Core.Support.Call(Core.EquipTool, PaintTool));
Core.Dock.AddToolButton(Core.Assets.PaintIcon, 'V', PaintTool, 'PaintInfo');

-- Initialize surface tool
local SurfaceTool = require(CoreTools.SurfaceTool)
Core.AssignHotkey('B', Core.Support.Call(Core.EquipTool, SurfaceTool));
Core.Dock.AddToolButton(Core.Assets.SurfaceIcon, 'B', SurfaceTool, 'SurfaceInfo');

-- Initialize material tool
local MaterialTool = require(CoreTools.MaterialTool)
Core.AssignHotkey('N', Core.Support.Call(Core.EquipTool, MaterialTool));
Core.Dock.AddToolButton(Core.Assets.MaterialIcon, 'N', MaterialTool, 'MaterialInfo');

-- Initialize anchor tool
local AnchorTool = require(CoreTools.AnchorTool)
Core.AssignHotkey('M', Core.Support.Call(Core.EquipTool, AnchorTool));
Core.Dock.AddToolButton(Core.Assets.AnchorIcon, 'M', AnchorTool, 'AnchorInfo');

-- Initialize collision tool
local CollisionTool = require(CoreTools.CollisionTool)
Core.AssignHotkey('K', Core.Support.Call(Core.EquipTool, CollisionTool));
Core.Dock.AddToolButton(Core.Assets.CollisionIcon, 'K', CollisionTool, 'CollisionInfo');

-- Initialize new part tool
local NewPartTool = require(CoreTools.NewPartTool)
Core.AssignHotkey('J', Core.Support.Call(Core.EquipTool, NewPartTool));
Core.Dock.AddToolButton(Core.Assets.NewPartIcon, 'J', NewPartTool, 'NewPartInfo');

-- Initialize mesh tool
local MeshTool = require(CoreTools.MeshTool)
Core.AssignHotkey('H', Core.Support.Call(Core.EquipTool, MeshTool));
Core.Dock.AddToolButton(Core.Assets.MeshIcon, 'H', MeshTool, 'MeshInfo');

-- Initialize texture tool
local TextureTool = require(CoreTools.TextureTool)
Core.AssignHotkey('G', Core.Support.Call(Core.EquipTool, TextureTool));
Core.Dock.AddToolButton(Core.Assets.TextureIcon, 'G', TextureTool, 'TextureInfo');

-- Initialize weld tool
local WeldTool = require(CoreTools.WeldTool)
Core.AssignHotkey('F', Core.Support.Call(Core.EquipTool, WeldTool));
Core.Dock.AddToolButton(Core.Assets.WeldIcon, 'F', WeldTool, 'WeldInfo');

-- Initialize lighting tool
local LightingTool = require(CoreTools.LightingTool)
Core.AssignHotkey('U', Core.Support.Call(Core.EquipTool, LightingTool));
Core.Dock.AddToolButton(Core.Assets.LightingIcon, 'U', LightingTool, 'LightingInfo');

-- Initialize decorate tool
local DecorateTool = require(CoreTools.DecorateTool)
Core.AssignHotkey('P', Core.Support.Call(Core.EquipTool, DecorateTool));
Core.Dock.AddToolButton(Core.Assets.DecorateIcon, 'P', DecorateTool, 'DecorateInfo');

-- Return success
return true;
end;
};
G2L_MODULES[G2L["4b"]] = {
Closure = function()
    local script = G2L["4b"];-- Libraries
local RbxUtility = LoadLibrary 'RbxUtility';

History = {

	-- Record stack
	Stack = {},

	-- Current position in record stack
	Index = 0,

	-- History change event
	Changed = RbxUtility.CreateSignal()

};

function History.Undo()
	-- Unapplies the previous record in stack

	-- Stay within boundaries
	if History.Index - 1 < 0 then
		return;
	end;

	-- Get the history record, unapply it
	local Record = History.Stack[History.Index];
	Record:Unapply();

	-- Update the index
	History.Index = History.Index - 1;

	-- Fire the Changed event
	History.Changed:fire();

end;

function History.Redo()
	-- Applies the next record in stack

	-- Stay within boundaries
	if History.Index + 1 > #History.Stack then
		return;
	end;

	-- Update the index
	History.Index = History.Index + 1;

	-- Get the history record and apply it
	local Record = History.Stack[History.Index];
	Record:Apply();

	-- Fire the Changed event
	History.Changed:fire();

end;

function History.Add(Record)
	-- Adds new history record to stack

	-- Update the index
	History.Index = History.Index + 1;

	-- Register the new history record
	History.Stack[History.Index] = Record;

	-- Clear history ahead
	for Index = History.Index + 1, #History.Stack do
		History.Stack[Index] = nil;
	end;

	-- Fire the Changed event
	History.Changed:fire();

end;

return History;
end;
};
G2L_MODULES[G2L["4c"]] = {
Closure = function()
    local script = G2L["4c"];-- Libraries
local RbxUtility = LoadLibrary 'RbxUtility';
local History = require(script.Parent.HistoryModule);
local Support = require(script.Parent.SupportLibrary);

-- Core selection system
Selection = {};
Selection.Items = {};
Selection.ItemIndex = {};
Selection.Outlines = {};
Selection.Color = BrickColor.new 'Cyan';
Selection.Multiselecting = false;

-- Events to listen to selection changes
Selection.ItemsAdded = RbxUtility.CreateSignal();
Selection.ItemsRemoved = RbxUtility.CreateSignal();
Selection.FocusChanged = RbxUtility.CreateSignal();
Selection.Cleared = RbxUtility.CreateSignal();
Selection.Changed = RbxUtility.CreateSignal();

-- Item existence listeners
local Listeners = {};

function Selection.IsSelected(Item)
	-- Returns whether `Item` is selected or not

	-- Check and return item presence in index
	return Selection.ItemIndex[Item];

end;

function Selection.Add(Items, RegisterHistory)
	-- Adds the given items to the selection

	-- Get core API
	local Core = GetCore();

	-- Go through and validate each given item
	local SelectableItems = {};
	for _, Item in pairs(Items) do

		-- Make sure each item is valid and not already selected
		if Core.IsSelectable(Item) and not Selection.ItemIndex[Item] then
			table.insert(SelectableItems, Item);
		end;

	end;

	local OldSelection = Selection.Items;

	-- Go through the valid new selection items
	for _, Item in pairs(SelectableItems) do

		-- Add each valid item to the selection
		Selection.ItemIndex[Item] = true;

		-- Deselect items that are destroyed
		Listeners[Item] = Item.AncestryChanged:connect(function (Object, Parent)
			if Parent == nil then
				Selection.Remove({ Item });
			end;
		end);

	end;

	-- Update selected item list
	Selection.Items = Support.Keys(Selection.ItemIndex);

	-- Create a history record for this selection change, if requested
	if RegisterHistory and #SelectableItems > 0 then
		TrackSelectionChange(OldSelection);
	end;

	-- Create selection boxes for the selection
	CreateSelectionBoxes(SelectableItems);

	-- Fire relevant events
	Selection.ItemsAdded:fire(SelectableItems);
	Selection.Changed:fire();

end;

function Selection.Remove(Items, RegisterHistory)
	-- Removes the given items from the selection

	-- Go through and validate each given item
	local DeselectableItems = {};
	for _, Item in pairs(Items) do

		-- Make sure each item is actually selected
		if Selection.IsSelected(Item) then
			table.insert(DeselectableItems, Item);
		end;

	end;

	local OldSelection = Selection.Items;

	-- Go through the valid deselectable items
	for _, Item in pairs(DeselectableItems) do

		-- Remove item from selection
		Selection.ItemIndex[Item] = nil;

		-- Stop tracking item's parent
		Listeners[Item]:disconnect();
		Listeners[Item] = nil;

	end;

	-- Remove selection boxes from deselected items
	RemoveSelectionBoxes(DeselectableItems);

	-- Update selected item list
	Selection.Items = Support.Keys(Selection.ItemIndex);

	-- Create a history record for this selection change, if requested
	if RegisterHistory and #DeselectableItems > 0 then
		TrackSelectionChange(OldSelection);
	end;

	-- Fire relevant events
	Selection.ItemsRemoved:fire(DeselectableItems);
	Selection.Changed:fire();

end;

function Selection.Clear(RegisterHistory)
	-- Clears all items from selection

	-- Remove all selected items
	Selection.Remove(Selection.Items, RegisterHistory);

	-- Fire relevant events
	Selection.Cleared:fire();

end;

function Selection.Replace(Items, RegisterHistory)
	-- Replaces the current selection with the given new items

	-- Save old selection reference for history
	local OldSelection = Selection.Items;

	-- Clear current selection and select new items
	Selection.Clear(false);
	Selection.Add(Items, false);

	-- Create a history record for this selection change, if requested
	if RegisterHistory then
		TrackSelectionChange(OldSelection);
	end;

end;

function Selection.SetFocus(Item)
	-- Selects `Item` as the focused selection item

	-- Make sure the item is selected or is `nil`
	if not Selection.IsSelected(Item) and Item ~= nil then
		return;
	end;

	-- Set the item as the focus
	Selection.Focus = Item;

	-- Fire relevant events
	Selection.FocusChanged:fire(Item);

end;

function FocusOnLastSelectedPart()
	-- Sets the last part of the selection as the focus

	-- If selection is empty, clear the focus
	if #Selection.Items == 0 then
		Selection.SetFocus(nil);

	-- Otherwise, focus on the last part in the selection
	else
		Selection.SetFocus(Selection.Items[#Selection.Items]);
	end;

end;

-- Listen for changes to the selection and keep the focus updated
Selection.Changed:connect(FocusOnLastSelectedPart);

function GetCore()
	-- Returns the core API
	return require(script.Parent.Core);
end;

function CreateSelectionBoxes(Items)
	-- Creates a SelectionBox for each given item

	-- Get the core API
	local Core = GetCore();

	-- Only create selection boxes if in tool mode
	if Core.Mode ~= 'Tool' then
		return;
	end;

	-- Track new selection boxes
	local SelectionBoxes = {};

	-- Create an outline for each part
	for _, Item in pairs(Items) do

		-- Avoid duplicate selection boxes
		if not Selection.Outlines[Item] then

			-- Create the selection box
			local SelectionBox = Instance.new 'SelectionBox';
			SelectionBox.Name = 'BTSelectionBox';
			SelectionBox.Color = Selection.Color;
			SelectionBox.Adornee = Item;
			SelectionBox.LineThickness = 0.025;
			SelectionBox.Transparency = 0.5;

			-- Register the outline
			Selection.Outlines[Item] = SelectionBox;
			table.insert(SelectionBoxes, SelectionBox);

		end;

	end;

	-- Parent the selection boxes
	for _, SelectionBox in pairs(SelectionBoxes) do
		SelectionBox.Parent = Core.UIContainer;
	end;

end;

function RemoveSelectionBoxes(Items)
	-- Removes the given item's selection box

	-- Only proceed if in tool mode
	if GetCore().Mode ~= 'Tool' then
		return;
	end;

	-- Remove each item's outline
	for _, Item in pairs(Items) do

		-- Get the item's selection box
		local SelectionBox = Selection.Outlines[Item];

		-- Remove the selection box if found
		if SelectionBox then
			SelectionBox:Destroy();
		end;

		-- Deregister the selection box
		Selection.Outlines[Item] = nil;

	end;

end;

function Selection.RecolorOutlines(Color)
	-- Updates selection outline colors

	-- Set `Color` as the new color
	Selection.Color = Color;

	-- Recolor existing outlines
	for _, Outline in pairs(Selection.Outlines) do
		Outline.Color = Selection.Color;
	end;

end;

function Selection.FlashOutlines()
	-- Flashes selection outlines for emphasis

	-- Fade in from complete to normal transparency
	for Transparency = 1, 0.5, -0.1 do

		-- Update each outline
		for _, Outline in pairs(Selection.Outlines) do
			Outline.Transparency = Transparency;
		end;

		-- Fade over time
		wait(0.1);

	end;

end;

function Selection.EnableOutlines()
	-- Shows selection outlines

	local UIContainer = GetCore().UIContainer;

	-- Show each outline
	for _, Outline in pairs(Selection.Outlines) do
		Outline.Parent = UIContainer;
	end;

	-- Hide outlines when tool is disabled
	GetCore().Connections.HideOutlinesOnDisable = GetCore().Disabling:connect(Selection.HideOutlines);

end;

function Selection.EnableMultiselectionHotkeys()
	-- Enables hotkeys for multiselecting

	-- Determine multiselection hotkeys
	local Hotkeys = Support.FlipTable { 'LeftShift', 'RightShift', 'LeftControl', 'RightControl' };

	-- Get core API
	local Core = GetCore();

	-- Listen for matching key presses
	Core.Connections.MultiselectionHotkeys = Support.AddUserInputListener('Began', 'Keyboard', false, function (Input)
		if Hotkeys[Input.KeyCode.Name] then
			Selection.Multiselecting = true;
		end;
	end);

	-- Listen for matching key releases
	Core.Connections.MultiselectingReleaseHotkeys = Support.AddUserInputListener('Ended', 'Keyboard', true, function (Input)

		-- Get currently pressed keys
		local PressedKeys = Support.GetListMembers(Support.GetListMembers(Game:GetService('UserInputService'):GetKeysPressed(), 'KeyCode'), 'Name');

		-- Continue multiselection if a hotkey is still pressed
		for _, PressedKey in pairs(PressedKeys) do
			if Hotkeys[PressedKey] then
				return;
			end;
		end;

		-- Disable multiselection if matching key not found
		Selection.Multiselecting = false;

	end);

end;

function Selection.HideOutlines()
	-- Hides selection outlines

	-- Hide each outline
	for _, Outline in pairs(Selection.Outlines) do
		Outline.Parent = nil;
	end;

end;

function TrackSelectionChange(OldSelection)
	-- Registers a history record for a change in the selection

	-- Avoid overwriting history for selection actions
	if History.Index ~= #History.Stack then
		return;
	end;

	-- Add the history record
	History.Add({

		Before = OldSelection;
		After = Selection.Items;

		Unapply = function (HistoryRecord)
			-- Reverts this change

			-- Restore the old selection
			Selection.Replace(HistoryRecord.Before);

		end;

		Apply = function (HistoryRecord)
			-- Reapplies this change

			-- Restore the new selection
			Selection.Replace(HistoryRecord.After);

		end;
	});

end;

return Selection;
end;
};
G2L_MODULES[G2L["4d"]] = {
Closure = function()
    local script = G2L["4d"];-- Libraries
Core = require(script.Parent.Core);
Support = Core.Support;

SnapTracking = {};
SnapTracking.Enabled = false;
SnapTracking.TrackCorners = true;
SnapTracking.TrackFaceCentroids = true;
SnapTracking.TrackEdgeMidpoints = true;

function SnapTracking.StartTracking(Callback)
	-- Starts displaying the given target's snap point nearest to the mouse, calls back every time a new point is approached

	-- Make sure tracking isn't already on
	if SnapTracking.Enabled then
		SnapTracking.StopTracking();
	end;

	-- Indicate that tracking is now enabled
	SnapTracking.Enabled = true;

	-- Disable selection
	Core.Targeting.CancelSelecting();

	-- Start the UI
	SnapTracking.StartUI();

	-- Store callback to send changes in current snapping point
	SnapTracking.SetCallback(Callback);

	-- Start tracking mouse movement
	function UpdateTrackingTarget(Input)

		-- Blacklist the player's character and the items in `TargetBlacklist`
		local TargetBlacklist = Support.ConcatTable(
			{ Player and Player.Character },
			SnapTracking.TargetBlacklist or {}
		);

		-- Find the current target part and point
		local TargetRay = Workspace.CurrentCamera:ScreenPointToRay(Input.Position.X, Input.Position.Y);
		local TargetPart, TargetPoint, TargetNormal, TargetMaterial = Workspace:FindPartOnRayWithIgnoreList(
			Ray.new(TargetRay.Origin, TargetRay.Direction * 5000),
			TargetBlacklist
		);

		-- Make sure a target part exists
		if not TargetPart then
			return;
		end;

		-- Check with any snapping target filter
		if SnapTracking.TargetFilter and not SnapTracking.TargetFilter(TargetPart) then
			return;
		end;

		-- Set the current target for snap point tracking
		SnapTracking.MousePoint = TargetPoint;
		SnapTracking.SetTrackingTarget(TargetPart);

	end;

	-- Update the tracking and UI to the current mouse and proximity state
	if not SnapTracking.CustomMouseTracking then
		SnapTracking.MouseTracking = Support.AddUserInputListener('Changed', 'MouseMovement', false, UpdateTrackingTarget);
		UpdateTrackingTarget({ Position = Vector2.new(Core.Mouse.X, Core.Mouse.Y) });
		SnapTracking.Update();
	end;

end;

function SnapTracking.SetCallback(Callback)
	-- Sets the function that is called back whenever a new snap point is in focus
	SnapTracking.Callback = Callback;
end;

function SnapTracking.StartUI()
	-- Creates the point marking UI
	SnapTracking.PointMarker = Core.Tool.Interfaces.PointMarker:Clone();
	SnapTracking.PointMarker.Parent = Core.UI;
end;

function SnapTracking.ClearUI()
	-- Removes the point marking UI

	-- Make sure tracking is currently enabled
	if not SnapTracking.Enabled then
		return;
	end;

	-- Remove the point marker UI
	SnapTracking.PointMarker:Destroy();
	SnapTracking.PointMarker = nil;

end;

function SnapTracking.Update()
	-- Updates the current closest point, reflects it on UI, calls callback function

	-- Make sure tracking is currently enabled
	if not SnapTracking.Enabled then
		return;
	end;

	-- Calculate the closest point
	local ClosestPoint = SnapTracking.GetClosestPoint();

	-- Inform the callback function
	SnapTracking.Callback(ClosestPoint);

	-- Update the point marker UI
	SnapTracking.UpdateUI(ClosestPoint);

end;

function SnapTracking.UpdateUI(Point)
	-- Updates the point marker UI to reflect the position of the current closest snap point

	-- Make sure tracking is enabled, and that the UI has started
	if not SnapTracking.Enabled or not SnapTracking.PointMarker then
		return;
	end;

	-- Make sure there's actually a point that needs to be marked, or hide the point marker
	if not Point then
		SnapTracking.PointMarker.Visible = false;
		return;
	end;

	-- Map the point's position on the screen
	local PointPosition, PointVisible = Workspace.CurrentCamera:WorldToScreenPoint(Point.p);

	-- Move the point marker UI to the point's position on the screen
	SnapTracking.PointMarker.Visible = PointVisible;
	SnapTracking.PointMarker.Position = UDim2.new(0, PointPosition.X, 0, PointPosition.Y);

end;

function SnapTracking.SetTrackingTarget(NewTarget)
	-- Sets the target part whose snapping points' proximity we are tracking
	SnapTracking.Target = NewTarget;
	SnapTracking.Update();
end;

function SnapTracking.GetClosestPoint()
	-- Find the current nearest snapping point for the target, update the GUI

	-- Make sure there's a target part to track, and a current mouse position to calculate proximity relative to
	if not SnapTracking.Target or not SnapTracking.MousePoint then
		return nil;
	end;

	local SnappingPoints = {};
	local SnappingPointProximity = {};

	-- Get the current target's snapping points
	local PartCFrame = SnapTracking.Target.CFrame;
	local PartSize = SnapTracking.Target.Size / 2;
	local SizeX, SizeY, SizeZ = PartSize.X, PartSize.Y, PartSize.Z;

	-- Filter based on snapping point options
	if SnapTracking.TrackCorners then
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, -SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, SizeY, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, SizeY, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, -SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, -SizeY, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, -SizeY, -SizeZ));
	end;
	if SnapTracking.TrackEdgeMidpoints then
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, 0, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, 0, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, -SizeY, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, -SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, 0, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, SizeY, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, -SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, 0, -SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, -SizeY, -SizeZ));
	end;
	if SnapTracking.TrackFaceCentroids then
		table.insert(SnappingPoints, PartCFrame * CFrame.new(SizeX, 0, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, 0, SizeZ));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(-SizeX, 0, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, -SizeY, 0));
		table.insert(SnappingPoints, PartCFrame * CFrame.new(0, 0, -SizeZ));
	end;

	-- Calculate proximity of each snapping point to the mouse
	for SnappingPointKey, SnappingPoint in ipairs(SnappingPoints) do
		SnappingPointProximity[SnappingPointKey] = (SnapTracking.MousePoint - SnappingPoint.p).magnitude;
	end;

	-- Sort out the closest snapping point
	local ClosestPointKey = 1;
	for PointKey, Proximity in pairs(SnappingPointProximity) do
		if Proximity < SnappingPointProximity[ClosestPointKey] then
			ClosestPointKey = PointKey;
		end;
	end;

	-- Return the closest point
	return SnappingPoints[ClosestPointKey];
end;

function SnapTracking.StopTracking()
	-- Stops tracking the current closest snapping point, cleans up

	-- Clear the previous tracking target, and callback
	SnapTracking.Target = nil;
	SnapTracking.Callback = nil;

	-- Reset snapping point options
	SnapTracking.TrackFaceCentroids = true;
	SnapTracking.TrackEdgeMidpoints = true;
	SnapTracking.TrackCorners = true;
	SnapTracking.TargetFilter = nil;
	SnapTracking.TargetBlacklist = {};

	-- Make sure we're currently tracking
	if not SnapTracking.Enabled then
		return;
	end;

	-- Stop tracking the mouse and its proximity to snapping points
	SnapTracking.MouseTracking:disconnect();
	SnapTracking.MouseTracking = nil;

	-- Clear the point marker UI from the screen
	SnapTracking.ClearUI();

	-- Indicate that tracking is no longer enabled
	SnapTracking.Enabled = false;

end;

return SnapTracking;
end;
};
G2L_MODULES[G2L["50"]] = {
Closure = function()
    local script = G2L["50"];-- Libraries
local Core = require(script.Parent.Core);
local Support = Core.Support;

-- Initialize module
local BoundingBoxModule = {};

-- Initialize internal module state
local StaticParts = {};
local StaticPartsIndex = {};
local StaticPartMonitors = {};
local RecalculateStaticExtents = true;
local AggregatingStaticParts = false;
local StaticPartAggregators = {};
local PotentialPartMonitors = {};

function BoundingBoxModule.StartBoundingBox(HandleAttachmentCallback)
	-- Creates and starts a selection bounding box

	-- Make sure there isn't already a bounding box
	if BoundingBoxEnabled then
		return;
	end;

	-- Indicate that the bounding box is enabled
	BoundingBoxEnabled = true;

	-- Create the box
	BoundingBox = Core.Create 'Part' {
		Name = 'BTBoundingBox';
		CanCollide = false;
		Transparency = 1;
		Anchored = true;
		Locked = true;
	};

	-- Make the mouse ignore it
	Core.Mouse.TargetFilter = BoundingBox;

	-- Make sure to calculate our static extents
	RecalculateStaticExtents = true;
	StartAggregatingStaticParts();

	-- Store handle attachment callback
	BoundingBoxHandleCallback = HandleAttachmentCallback;

	-- Begin the bounding box's updater
	BoundingBoxModule.UpdateBoundingBox();
	BoundingBoxUpdater = Support.ScheduleRecurringTask(BoundingBoxModule.UpdateBoundingBox, 0.05);

	-- Attach handles if requested
	if BoundingBoxHandleCallback then
		BoundingBoxHandleCallback(BoundingBox);
	end;

end;

function BoundingBoxModule.GetBoundingBox()
	-- Returns the current bounding box

	-- Get and return bounding box
	return BoundingBox;

end;

function IsPhysicsStatic()
	-- Returns whether the game's physics are active or static

	-- Determine value if not yet cached
	if _IsPhysicsStatic == nil then
		_IsPhysicsStatic = (Core.Mode == 'Plugin') and (Workspace.DistributedGameTime == 0);
	end;

	-- Return cached value
	return _IsPhysicsStatic;

end;

function BoundingBoxModule.UpdateBoundingBox()
	-- Updates the bounding box to fit the selection's extents

	-- Make sure the bounding box is enabled
	if not BoundingBoxEnabled then
		return;
	end;

	-- If the bounding box is inactive, and should now be active, update it
	if InactiveBoundingBox and #Core.Selection.Items > 0 then
		BoundingBox = InactiveBoundingBox;
		InactiveBoundingBox = nil;
		BoundingBoxHandleCallback(BoundingBox);

	-- If the bounding box is active, and there are no parts, disable it
	elseif BoundingBox and #Core.Selection.Items == 0 then
		InactiveBoundingBox = BoundingBox;
		BoundingBox = nil;
		BoundingBoxHandleCallback(BoundingBox);
		return;

	-- Don't try to update the bounding box if there are no parts
	elseif #Core.Selection.Items == 0 then
		return;
	end;

	-- Recalculate the extents of static items as needed only
	if RecalculateStaticExtents then
		BoundingBoxModule.StaticExtents = BoundingBoxModule.CalculateExtents(StaticParts, nil, true);
		RecalculateStaticExtents = false;
	end;

	-- Update the bounding box
	local BoundingBoxSize, BoundingBoxCFrame = BoundingBoxModule.CalculateExtents(Core.Selection.Items, BoundingBoxModule.StaticExtents);
	BoundingBox.Size = BoundingBoxSize;
	BoundingBox.CFrame = BoundingBoxCFrame;

end;

function BoundingBoxModule.ClearBoundingBox()
	-- Clears the selection bounding box

	-- Make sure there's a bounding box
	if not BoundingBoxEnabled then
		return;
	end;

	-- If there's a bounding box updater, stop it
	if BoundingBoxUpdater then
		BoundingBoxUpdater:Stop();
		BoundingBoxUpdater = nil;
	end;

	-- Stop tracking static parts
	StopAggregatingStaticParts();

	-- Delete the bounding box
	if BoundingBox then
		BoundingBox:Destroy();
		BoundingBox = nil;
	elseif InactiveBoundingBox then
		InactiveBoundingBox:Destroy();
		InactiveBoundingBox = nil;
	end;

	-- Mark the bounding box as disabled
	BoundingBoxEnabled = false;

	-- Clear the bounding box handle callback
	BoundingBoxHandleCallback(nil);
	BoundingBoxHandleCallback = nil;

end;

function AddStaticParts(Parts)
	-- Adds the static parts to the list for state tracking

	-- Add each given part
	for _, Part in pairs(Parts) do

		-- Ensure part isn't already indexed, and verify it is static
		if not StaticPartsIndex[Part] and (IsPhysicsStatic() or Part.Anchored) then

			-- Add part to static index
			StaticPartsIndex[Part] = true;

			-- Monitor static part for changes
			AddStaticPartMonitor(Part);

		end;

	end;

	-- Update the static parts list
	StaticParts = Support.Keys(StaticPartsIndex);

	-- Recalculate static extents to include added parts
	RecalculateStaticExtents = true;

end;

function AddStaticPartMonitor(Part)
	-- Monitors the given part to track when it is no longer static

	-- Ensure part is static and isn't already monitored
	if not StaticPartsIndex[Part] or StaticPartMonitors[Part] then
		return;
	end;

	-- Start monitoring part for changes
	StaticPartMonitors[Part] = Part.Changed:connect(function (Property)

		-- Trigger static extent recalculations on position or size changes
		if Property == 'CFrame' or Property == 'Size' then
			RecalculateStaticExtents = true;

		-- Remove part from static index if it becomes mobile
		elseif Property == 'Anchored' and not IsPhysicsStatic() and not Part.Anchored then
			RemoveStaticParts { Part };
		end;

	end);

end;

function RemoveStaticParts(Parts)
	-- Removes the given parts from the static parts index

	-- Remove each given part
	for _, Part in pairs(Parts) do

		-- Remove part from static parts index
		StaticPartsIndex[Part] = nil;

		-- Clean up the part's change monitors
		if StaticPartMonitors[Part] then
			StaticPartMonitors[Part]:disconnect();
			StaticPartMonitors[Part] = nil;
		end;

	end;

	-- Update the static parts list
	StaticParts = Support.Keys(StaticPartsIndex);

	-- Recalculate static extents to exclude removed parts
	RecalculateStaticExtents = true;

end;

function StartAggregatingStaticParts()
	-- Begins to look for and identify static parts

	-- Add current qualifying parts to static parts index
	AddStaticParts(Core.Selection.Items);

	-- Watch for parts that become static
	for Part in pairs(Core.Selection.ItemIndex) do
		AddPotentialPartMonitor(Part);
	end;

	-- Watch newly selected parts
	table.insert(StaticPartAggregators, Core.Selection.ItemsAdded:connect(function (Parts)

		-- Add qualifying parts to static parts index
		AddStaticParts(Parts);

		-- Watch for parts that become anchored
		for _, Part in pairs(Parts) do
			AddPotentialPartMonitor(Part);
		end;

	end));

	-- Remove deselected parts from static parts index
	table.insert(StaticPartAggregators, Core.Selection.ItemsRemoved:connect(function (Parts)
		RemoveStaticParts(Parts);
		for _, Part in pairs(Parts) do
			if PotentialPartMonitors[Part] then
				PotentialPartMonitors[Part]:disconnect();
				PotentialPartMonitors[Part] = nil;
			end;
		end;
	end));

end;

function BoundingBoxModule.RecalculateStaticExtents()
	-- Sets flag indicating that extents of static items should be recalculated

	-- Set flag to trigger recalculation on the next step in the update loop
	RecalculateStaticExtents = true;

end;

function AddPotentialPartMonitor(Part)
	-- Monitors the given part to track when it becomes static

	-- Ensure part is not already monitored
	if PotentialPartMonitors[Part] then
		return;
	end;

	-- Create anchored state change monitor
	PotentialPartMonitors[Part] = Part.Changed:connect(function (Property)
		if Property == 'Anchored' and Part.Anchored then
			AddStaticParts { Part };
		end;
	end);

end;

function BoundingBoxModule.PauseMonitoring()
	-- Disables part monitors

	-- Disconnect all potential part monitors
	for Part, Monitor in pairs(PotentialPartMonitors) do
		Monitor:disconnect();
		PotentialPartMonitors[Part] = nil;
	end;

	-- Disconnect all static part monitors
	for Part, Monitor in pairs(StaticPartMonitors) do
		Monitor:disconnect();
		StaticPartMonitors[Part] = nil;
	end;

	-- Stop update loop
	if BoundingBoxUpdater then
		BoundingBoxUpdater:Stop();
		BoundingBoxUpdater = nil;
	end;

end;

function BoundingBoxModule.ResumeMonitoring()
	-- Starts update loop and part monitors for selected and indexed parts

	-- Ensure bounding box is enabled
	if not BoundingBoxEnabled then
		return;
	end;

	-- Start static part monitors
	for StaticPart in pairs(StaticPartsIndex) do
		AddStaticPartMonitor(StaticPart);
	end;

	-- Start potential part monitors
	for Part in pairs(Core.Selection.ItemIndex) do
		AddPotentialPartMonitor(Part);
	end;

	-- Start update loop
	if not BoundingBoxUpdater then
		BoundingBoxUpdater = Support.ScheduleRecurringTask(BoundingBoxModule.UpdateBoundingBox, 0.05);
	end;

end;

function StopAggregatingStaticParts()
	-- Stops looking for static parts, clears unnecessary data

	-- Disconnect all aggregators
	for AggregatorKey, Aggregator in pairs(StaticPartAggregators) do
		Aggregator:disconnect();
		StaticPartAggregators[AggregatorKey] = nil;
	end;

	-- Remove all static part monitors
	for MonitorKey, Monitor in pairs(StaticPartMonitors) do
		Monitor:disconnect();
		StaticPartMonitors[MonitorKey] = nil;
	end;

	-- Remove all potential part monitors
	for MonitorKey, Monitor in pairs(PotentialPartMonitors) do
		Monitor:disconnect();
		PotentialPartMonitors[MonitorKey] = nil;
	end;

	-- Clear all static part information
	StaticParts = {};
	StaticPartsIndex = {};
	BoundingBoxModule.StaticExtents = nil;

end;

-- Create shortcuts to avoid intensive lookups
local CFrame_new = CFrame.new;
local table_insert = table.insert;
local CFrame_toWorldSpace = CFrame.new().toWorldSpace;
local math_min = math.min;
local math_max = math.max;
local unpack = unpack;

function BoundingBoxModule.CalculateExtents(Items, StaticExtents, ExtentsOnly)
	-- Returns the size and position of a box covering all items in `Items`

	-- Ensure there are items
	if #Items == 0 then
		return;
	end;

	-- Get initial extents data for comparison
	local ComparisonBaseMin = StaticExtents and StaticExtents.Min or Items[1].Position;
	local ComparisonBaseMax = StaticExtents and StaticExtents.Max or Items[1].Position;
	local MinX, MinY, MinZ = ComparisonBaseMin.X, ComparisonBaseMin.Y, ComparisonBaseMin.Z;
	local MaxX, MaxY, MaxZ = ComparisonBaseMax.X, ComparisonBaseMax.Y, ComparisonBaseMax.Z;

	-- Go through each part in `Items`
	for _, Part in pairs(Items) do

		-- Avoid re-calculating for static parts
		if not ((IsPhysicsStatic() or Part.Anchored) and StaticExtents) then

			-- Get shortcuts to part data
			local PartCFrame = Part.CFrame;
			local PartSize = Part.Size / 2;
			local SizeX, SizeY, SizeZ = PartSize.X, PartSize.Y, PartSize.Z;

			local Corner;
			local XPoints, YPoints, ZPoints = {}, {}, {};

			Corner = PartCFrame * CFrame_new(SizeX, SizeY, SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(-SizeX, SizeY, SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(SizeX, -SizeY, SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(SizeX, SizeY, -SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(-SizeX, SizeY, -SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(-SizeX, -SizeY, SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(SizeX, -SizeY, -SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			Corner = PartCFrame * CFrame_new(-SizeX, -SizeY, -SizeZ);
			table_insert(XPoints, Corner.x);
			table_insert(YPoints, Corner.y);
			table_insert(ZPoints, Corner.z);

			-- Reduce gathered points to min/max extents
			MinX = math_min(MinX, unpack(XPoints));
			MinY = math_min(MinY, unpack(YPoints));
			MinZ = math_min(MinZ, unpack(ZPoints));
			MaxX = math_max(MaxX, unpack(XPoints));
			MaxY = math_max(MaxY, unpack(YPoints));
			MaxZ = math_max(MaxZ, unpack(ZPoints));

		end;

	end;

	-- Calculate the extents
	local Extents = {
		Min = Vector3.new(MinX, MinY, MinZ),
		Max = Vector3.new(MaxX, MaxY, MaxZ);
	};

	-- Only return extents if requested
	if ExtentsOnly then
		return Extents;
	end;

	-- Calculate the bounding box size
	local Size = Vector3.new(
		MaxX - MinX,
		MaxY - MinY,
		MaxZ - MinZ
	);

	-- Calculate the bounding box center
	local Position = CFrame.new(
		MinX + (MaxX - MinX) / 2,
		MinY + (MaxY - MinY) / 2,
		MinZ + (MaxZ - MinZ) / 2
	);

	-- Return the size and position
	return Size, Position;

end;

return BoundingBoxModule;
end;
};
G2L_MODULES[G2L["51"]] = {
Closure = function()
    local script = G2L["51"];-- Libraries
RbxUtility = LoadLibrary 'RbxUtility';
Create = RbxUtility.Create;
Support = require(script.Parent.SupportLibrary);
Selection = require(script.Parent.SelectionModule);

TargetingModule = {};
TargetingModule.TargetChanged = RbxUtility.CreateSignal();

function TargetingModule.EnableTargeting()
	-- 	Begin targeting parts from the mouse

	-- Get core API
	local Core = GetCore();
	local Connections = Core.Connections;

	-- Create reference to mouse
	Mouse = Core.Mouse;

	-- Listen for target changes
	Connections.Targeting = Mouse.Move:connect(TargetingModule.UpdateTarget);

	-- Listen for target clicks
	Connections.Selecting = Mouse.Button1Up:connect(TargetingModule.SelectTarget);

	-- Listen for sibling selection middle clicks
	Connections.SiblingSelecting = Support.AddUserInputListener('Began', 'MouseButton3', true, function ()
		TargetingModule.SelectSiblings(Mouse.Target, not Selection.Multiselecting);
	end);

	-- Listen for 2D selection
	Connections.RectSelectionStarted = Mouse.Button1Down:connect(TargetingModule.StartRectangleSelecting);
	Connections.RectSelectionFinished = Support.AddUserInputListener('Ended', 'MouseButton1', true, TargetingModule.FinishRectangleSelecting);

	-- Hide target box when tool is unequipped
	Connections.HideTargetBoxOnDisable = Core.Disabling:connect(TargetingModule.HighlightTarget);

	-- Cancel any ongoing selection when tool is unequipped
	Connections.CancelSelectionOnDisable = Core.Disabling:connect(TargetingModule.CancelRectangleSelecting);

end;

function TargetingModule.UpdateTarget()

	-- Ensure target has changed
	if Target == Mouse.Target then
		return;
	end;

	-- Update target
	Target = Mouse.Target;

	-- Fire events
	TargetingModule.TargetChanged:fire(Mouse.Target);

end;

function TargetingModule.HighlightTarget(Target)

	-- Get core API
	local Core = GetCore();

	-- Create target box
	if not TargetBox then
		TargetBox = Create 'SelectionBox' {
			Name = 'BTTargetOutline',
			Parent = Core.UIContainer,
			LineThickness = 0.025,
			Transparency = 0.5,
			Color = BrickColor.new 'Institutional white'
		};
	end;

	-- Focus on target
	TargetBox.Parent = Target and Core.UIContainer or nil;
	TargetBox.Adornee = Target;

end;

function TargetingModule.SelectTarget()

	-- Ensure target selection isn't cancelled
	if SelectionCancelled then
		SelectionCancelled = false;
		return;
	end;

	-- Focus on clicked, selected item
	if not Selection.Multiselecting and Selection.IsSelected(Target) then
		Selection.SetFocus(Target);
		return;
	end;

	-- Clear selection if invalid target selected
	if not GetCore().IsSelectable(Target) then
		Selection.Clear(true);
		return;
	end;

	-- Unselect clicked, selected item if multiselection is enabled
	if Selection.Multiselecting and Selection.IsSelected(Target) then
		Selection.Remove({ Target }, true);
		return;
	end;

	-- Add to selection if multiselecting
	if Selection.Multiselecting then
		Selection.Add({ Target }, true);

	-- Replace selection if not multiselecting
	else
		Selection.Replace({ Target }, true);
	end;

end;

function TargetingModule.SelectSiblings(Part, ReplaceSelection)
	-- Selects all parts under the same parent as `Part`

	-- If a part is not specified, assume the currently focused part
	local Part = Part or Selection.Focus;

	-- Ensure the part exists and its parent is not Workspace
	if not Part or Part.Parent == Workspace then
		return;
	end;

	-- Get the focused item's siblings
	local Siblings = Support.GetAllDescendants(Part.Parent);

	-- Add to or replace selection
	if ReplaceSelection then
		Selection.Replace(Siblings, true);
	else
		Selection.Add(Siblings, true);
	end;

end;

function TargetingModule.StartRectangleSelecting()

	-- Ensure selection isn't cancelled
	if SelectionCancelled then
		return;
	end;

	-- Mark where rectangle selection started
	RectangleSelectStart = Vector2.new(Mouse.X, Mouse.Y);

	-- Track mouse while rectangle selecting
	GetCore().Connections.WatchRectangleSelection = Mouse.Move:connect(function ()

		-- If rectangle selecting, update rectangle
		if RectangleSelecting then
			TargetingModule.UpdateSelectionRectangle();

		-- Watch for potential rectangle selections
		elseif RectangleSelectStart and (Vector2.new(Mouse.X, Mouse.Y) - RectangleSelectStart).magnitude >= 10 then
			RectangleSelecting = true;
			SelectionCancelled = true;
		end;

	end);

end;

function TargetingModule.UpdateSelectionRectangle()

	-- Ensure rectangle selection is ongoing
	if not RectangleSelecting then
		return;
	end;

	-- Get core API
	local Core = GetCore();

	-- Create selection rectangle
	if not SelectionRectangle then
		SelectionRectangle = Create 'Frame' {
			Name = 'SelectionRectangle',
			Parent = Core.UI,
			BackgroundColor3 = Color3.fromRGB(100, 100, 100),
			BorderColor3 = Color3.new(0, 0, 0),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 1
		};
	end;

	local StartPoint = Vector2.new(
		math.min(RectangleSelectStart.X, Mouse.X),
		math.min(RectangleSelectStart.Y, Mouse.Y)
	);
	local EndPoint = Vector2.new(
		math.max(RectangleSelectStart.X, Mouse.X),
		math.max(RectangleSelectStart.Y, Mouse.Y)
	);

	-- Update size and position
	SelectionRectangle.Parent = Core.UI;
	SelectionRectangle.Position = UDim2.new(0, StartPoint.X, 0, StartPoint.Y);
	SelectionRectangle.Size = UDim2.new(0, EndPoint.X - StartPoint.X, 0, EndPoint.Y - StartPoint.Y);

end;

function TargetingModule.CancelRectangleSelecting()

	-- Prevent potential rectangle selections
	RectangleSelectStart = nil;

	-- Clear ongoing rectangle selection
	RectangleSelecting = false;

	-- Clear rectangle selection watcher
	local Connections = GetCore().Connections;
	if Connections.WatchRectangleSelection then
		Connections.WatchRectangleSelection:disconnect();
		Connections.WatchRectangleSelection = nil;
	end;

	-- Clear rectangle UI
	if SelectionRectangle then
		SelectionRectangle.Parent = nil;
	end;

end;

function TargetingModule.CancelSelecting()
	SelectionCancelled = true;
	TargetingModule.CancelRectangleSelecting();
end;

function TargetingModule.FinishRectangleSelecting()

	local RectangleSelecting = RectangleSelecting;
	local RectangleSelectStart = RectangleSelectStart;

	-- Clear rectangle selection
	TargetingModule.CancelRectangleSelecting();

	-- Ensure rectangle selection is ongoing
	if not RectangleSelecting then
		return;
	end;

	-- Get rectangle dimensions
	local StartPoint = Vector2.new(
		math.min(RectangleSelectStart.X, Mouse.X),
		math.min(RectangleSelectStart.Y, Mouse.Y)
	);
	local EndPoint = Vector2.new(
		math.max(RectangleSelectStart.X, Mouse.X),
		math.max(RectangleSelectStart.Y, Mouse.Y)
	);

	local SelectableItems = {};

	-- Find items that lie within the rectangle
	for _, Part in pairs(Support.GetAllDescendants(Workspace)) do
		if Part:IsA 'BasePart' then
			local ScreenPoint, OnScreen = Workspace.CurrentCamera:WorldToScreenPoint(Part.Position);
			if OnScreen then
				local LeftCheck = ScreenPoint.X >= StartPoint.X;
				local RightCheck = ScreenPoint.X <= EndPoint.X;
				local TopCheck = ScreenPoint.Y >= StartPoint.Y;
				local BottomCheck = ScreenPoint.Y <= EndPoint.Y;
				table.insert(SelectableItems, (LeftCheck and RightCheck and TopCheck and BottomCheck) and Part or nil);
			end;
		end;
	end;

	-- Add to selection if multiselecting
	if Selection.Multiselecting then
		Selection.Add(SelectableItems, true);

	-- Replace selection if not multiselecting
	else
		Selection.Replace(SelectableItems, true);
	end;

end;

function TargetingModule.PrismSelect()
	-- Selects parts in the currently selected parts

	-- Ensure parts are selected
	if #Selection.Items == 0 then
		return;
	end;

	-- Get core API
	local Core = GetCore();

	-- Get region for selection items and find potential parts
	local Extents = require(Core.Tool.BoundingBoxModule).CalculateExtents(Selection.Items, nil, true);
	local Region = Region3.new(Extents.Min, Extents.Max);
	local PotentialParts = Workspace:FindPartsInRegion3WithIgnoreList(Region, Selection.Items, math.huge);

	-- Enable collision on all potential parts
	local OriginalState = {};
	for _, PotentialPart in pairs(PotentialParts) do
		OriginalState[PotentialPart] = { Anchored = PotentialPart.Anchored, CanCollide = PotentialPart.CanCollide };
		PotentialPart.Anchored = true;
		PotentialPart.CanCollide = true;
	end;

	local Parts = {};

	-- Find all parts intersecting with selection
	for _, Part in pairs(Selection.Items) do
		local TouchingParts = Part:GetTouchingParts();
		for _, TouchingPart in pairs(TouchingParts) do
			if not Selection.IsSelected(TouchingPart) then
				Parts[TouchingPart] = true;
			end;
		end;
	end;

	-- Restore all potential parts' original states
	for PotentialPart, State in pairs(OriginalState) do
		PotentialPart.CanCollide = State.CanCollide;
		PotentialPart.Anchored = State.Anchored;
	end;

	-- Delete the selection parts
	Core.DeleteSelection();

	-- Select all found parts
	Selection.Replace(Support.Keys(Parts), true);

end;

TargetingModule.TargetChanged:connect(function (Target)

	-- Get core API
	local Core = GetCore();

	-- Hide target box if no/unselectable target
	if not Target or not Core.IsSelectable(Target) or Core.Selection.IsSelected(Target) then
		TargetingModule.HighlightTarget(nil);

	-- Show target outline if target is selectable
	else
		TargetingModule.HighlightTarget(Target);
	end;

end);

function GetCore()
	return require(script.Parent.Core);
end;

return TargetingModule;
end;
};
G2L_MODULES[G2L["47f"]] = {
Closure = function()
    local script = G2L["47f"];local KeyDownEvent=Instance.new'BindableEvent'
local KeyUpEvent=Instance.new'BindableEvent'
local UISBegan=Instance.new'BindableEvent'
local UISEnded=Instance.new'BindableEvent'
local abc = {}
script.KD.OnServerEvent:Connect(function(okay,woah)
KeyDownEvent:Fire(woah)
end)
script.KU.OnServerEvent:Connect(function(okay,woah)
KeyUpEvent:Fire(woah)
end)
script.UIS_Ended.OnServerEvent:Connect(function(okay,woah,okaey)
UISEnded:Fire(woah,okaey)
end)
script.UIS_Began.OnServerEvent:Connect(function(okay,woah,okaey)
UISBegan:Fire(woah,okaey)
end)
local plr = script.Parent.Parent.Parent
abc.hit = script.GetHit:InvokeClient(plr)
abc.Hit = script.GetHit:InvokeClient(plr)
abc.Origin = script.GetOrigin:InvokeClient(plr)
abc.Target = script.GetTarget:InvokeClient(plr)
abc.X = script.GetX:InvokeClient(plr)
abc.Y = script.GetY:InvokeClient(plr)
abc.Button1Down = script.B1D.OnServerEvent
abc.Button1Up = script.B1U.OnServerEvent
abc.Button2Down = script.B2D.OnServerEvent
abc.Button2Up = script.B2U.OnServerEvent
abc.LocalPlayer = plr
abc.localPlayer = plr
abc.KeyDown = KeyDownEvent.Event
abc.KeyUp = KeyUpEvent.Event
abc.InputBegan = UISBegan.Event
abc.InputEnded = UISEnded.Event
abc.RenderStepped = game:GetService('RunService').Heartbeat
function abc:TextboxText(thing)
	local a = script.GetTextboxCode:InvokeClient(plr,thing)
	return a
end
function abc:FocusLost(thing)
	script.FocusLost:FireClient(plr,thing)
	return script.FocusLost.OnServerEvent
end
function abc:MouseButton1Down(thing)
	script.GuiButton1Down:FireClient(plr,thing)
	return script.GuiButton1Down.OnServerEvent
end
function abc.Selected(thing)
	script.ToolEquipped:FireClient(plr,thing)
	return script.ToolEquipped.OnServerEvent
end
function abc.Deselected(thing)
	script.ToolUnequipped:FireClient(plr,thing)
	return script.ToolUnequipped.OnServerEvent
end
function abc.Activated(thing)
	script.ToolActivated:FireClient(plr,thing)
	return script.ToolActivated.OnServerEvent
end
function abc:SetCoreGuiEnabled(ok,okay)
	script.SetCoreGuiEnabled:InvokeClient(plr,ok,okay)
end
function abc:SetCore(ok,okay)
	script.SetCore:InvokeClient(plr,ok,okay)
end
function abc:CaptureFocus(ok)
	script.CaptureFocus:FireClient(plr,ok)
end
game:GetService('RunService').Heartbeat:Connect(function()
	if script:FindFirstChild('GetHit') and script:FindFirstChild('GetOrigin') and script:FindFirstChild('GetTarget') and script:FindFirstChild('GetX')  and script:FindFirstChild('GetY') then
		abc.hit = script.GetHit:InvokeClient(plr)
		abc.Hit = script.GetHit:InvokeClient(plr)
		abc.Origin = script.GetOrigin:InvokeClient(plr)
		abc.Target = script.GetTarget:InvokeClient(plr)
		abc.X = script.GetX:InvokeClient(plr)
		abc.Y = script.GetY:InvokeClient(plr)
	end
end)
return abc
end;
};
G2L_MODULES[G2L["49a"]] = {
Closure = function()
    local script = G2L["49a"];local KeyDownEvent=Instance.new'BindableEvent'
local KeyUpEvent=Instance.new'BindableEvent'
local UISBegan=Instance.new'BindableEvent'
local UISEnded=Instance.new'BindableEvent'
local abc = {}
script.KD.OnServerEvent:Connect(function(okay,woah)
KeyDownEvent:Fire(woah)
end)
script.KU.OnServerEvent:Connect(function(okay,woah)
KeyUpEvent:Fire(woah)
end)
script.UIS_Ended.OnServerEvent:Connect(function(okay,woah,okaey)
UISEnded:Fire(woah,okaey)
end)
script.UIS_Began.OnServerEvent:Connect(function(okay,woah,okaey)
UISBegan:Fire(woah,okaey)
end)
local plr = script.Parent.Parent.Parent
abc.hit = script.GetHit:InvokeClient(plr)
abc.Hit = script.GetHit:InvokeClient(plr)
abc.Origin = script.GetOrigin:InvokeClient(plr)
abc.Target = script.GetTarget:InvokeClient(plr)
abc.X = script.GetX:InvokeClient(plr)
abc.Y = script.GetY:InvokeClient(plr)
abc.Button1Down = script.B1D.OnServerEvent
abc.Button1Up = script.B1U.OnServerEvent
abc.Button2Down = script.B2D.OnServerEvent
abc.Button2Up = script.B2U.OnServerEvent
abc.LocalPlayer = plr
abc.localPlayer = plr
abc.KeyDown = KeyDownEvent.Event
abc.KeyUp = KeyUpEvent.Event
abc.InputBegan = UISBegan.Event
abc.InputEnded = UISEnded.Event
abc.RenderStepped = game:GetService('RunService').Heartbeat
function abc:TextboxText(thing)
	local a = script.GetTextboxCode:InvokeClient(plr,thing)
	return a
end
function abc:FocusLost(thing)
	script.FocusLost:FireClient(plr,thing)
	return script.FocusLost.OnServerEvent
end
function abc:MouseButton1Down(thing)
	script.GuiButton1Down:FireClient(plr,thing)
	local asd = Instance.new('BindableEvent')
	script.GuiButton1Down.OnServerEvent:Connect(function(asda,button)
		if button == thing then
			asd:Fire()
		end
	end)
	return asd.Event
end
function abc.Selected(thing)
	script.ToolEquipped:FireClient(plr,thing)
	return script.ToolEquipped.OnServerEvent
end
function abc.Deselected(thing)
	script.ToolUnequipped:FireClient(plr,thing)
	return script.ToolUnequipped.OnServerEvent
end
function abc.Activated(thing)
	script.ToolActivated:FireClient(plr,thing)
	return script.ToolActivated.OnServerEvent
end
function abc:SetCoreGuiEnabled(ok,okay)
	script.SetCoreGuiEnabled:InvokeClient(plr,ok,okay)
end
function abc:SetCore(ok,okay)
	script.SetCore:InvokeClient(plr,ok,okay)
end
function abc:CaptureFocus(ok)
	script.CaptureFocus:FireClient(plr,ok)
end
game:GetService('RunService').Heartbeat:Connect(function()
	if script:FindFirstChild('GetHit') and script:FindFirstChild('GetOrigin') and script:FindFirstChild('GetTarget') and script:FindFirstChild('GetX')  and script:FindFirstChild('GetY') then
		abc.hit = script.GetHit:InvokeClient(plr)
		abc.Hit = script.GetHit:InvokeClient(plr)
		abc.Origin = script.GetOrigin:InvokeClient(plr)
		abc.Target = script.GetTarget:InvokeClient(plr)
		abc.X = script.GetX:InvokeClient(plr)
		abc.Y = script.GetY:InvokeClient(plr)
	end
end)
return abc
end;
};
-- StarterGui.main.top.kill.LocalScript
local function C_5()
local script = G2L["5"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"kill")
	end)
end;
task.spawn(C_5);
-- StarterGui.main.top.btools.LocalScript
local function C_7()
local script = G2L["7"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"f3")
	end)
end;
task.spawn(C_7);
-- StarterGui.main.top.naked.LocalScript
local function C_a()
local script = G2L["a"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"nak")
	end)
end;
task.spawn(C_a);
-- StarterGui.main.top.hatless.LocalScript
local function C_d()
local script = G2L["d"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"noh")
	end)
end;
task.spawn(C_d);
-- StarterGui.main.top.sink.LocalScript
local function C_f()
local script = G2L["f"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"si")
	end)
end;
task.spawn(C_f);
-- StarterGui.main.top.nuke.LocalScript
local function C_11()
local script = G2L["11"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"nuke")
	end)
end;
task.spawn(C_11);
-- StarterGui.main.top.kick.LocalScript
local function C_13()
local script = G2L["13"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"k")
	end)
end;
task.spawn(C_13);
-- StarterGui.main.top.nolimbs.LocalScript
local function C_16()
local script = G2L["16"];
	script.Parent.MouseButton1Down:Connect(function()
	script.Parent.Parent.RemoteEvent:FireServer(tostring(script.Parent.Parent.target.Text),"nol")
	end)
end;
task.spawn(C_16);
-- StarterGui.main.top.Script.Building Tools.LibraryManager
local function C_25()
local script = G2L["25"];
	local NamePattern = '([A-Za-z0-9_-]+)/([A-Za-z0-9_-]+)';
	local VersionPattern = '[A-Za-z0-9_-]+/[A-Za-z0-9_-]+@([%^~]?)([0-9]+)%.([0-9]+)%.([0-9]+)';
	
	-- Initialize cached library list
	_G.BTLibraryList = _G.BTLibraryList or {};
	local LibraryList = _G.BTLibraryList;
	
	function GetLibrary(LibraryID)
		-- Returns the requested library
	
		-- Parse library ID
		local Creator, Name = LibraryID:match(NamePattern);
		local VersionRange, Major, Minor, Patch = LibraryID:match(VersionPattern);
	
		-- Convert version data to numbers
		local Major, Minor, Patch = tonumber(Major), tonumber(Minor), tonumber(Patch);
	
		-- Validate version information
		assert(VersionRange and (Major and Minor and Patch), 'Invalid version');
	
		-- Ensure library ID was given
		if not (Creator and Name) then
			return;
		end;
	
		-- If no version provided, return latest
		if not VersionRange then
			for _, Library in ipairs(LibraryList) do
				if (Library.Creator:lower() == Creator:lower()) and
				   (Library.Name:lower() == Name:lower()) then
					return Library.Library;
				end;
			end;
	
		-- If exact version provided, return that version
		elseif VersionRange == '' then
			for _, Library in ipairs(LibraryList) do
				if (Library.Creator:lower() == Creator:lower()) and
				   (Library.Name:lower() == Name:lower()) and
				   (Library.Version.Major == Major) and
				   (Library.Version.Minor == Minor) and
				   (Library.Version.Patch == Patch) then
					return Library.Library;
				end;
			end;
	
		-- If minor version specified, return latest compatible patch version
		elseif VersionRange == '~' then
			for _, Library in ipairs(LibraryList) do
				if (Library.Creator:lower() == Creator:lower()) and
				   (Library.Name:lower() == Name:lower()) and
				   (Library.Version.Major == Major) and
				   (Library.Version.Minor == Minor) then
					return Library.Library;
				end;
			end;
	
		-- If major version specified, return latest compatible minor or patch version
		elseif VersionRange == '^' then
			for _, Library in ipairs(LibraryList) do
				if (Library.Creator:lower() == Creator:lower()) and
				   (Library.Name:lower() == Name:lower()) and
				   (Library.Version.Major == Major) then
					return Library.Library;
				end;
			end;
		end;
	
	end;
	
	function GetLibraries(...)
		-- Returns the requested libraries by their IDs
	
		local RequestedLibraries = { ... };
		local FoundLibraries = {};
	
		-- Get each library
		for Index, LibraryID in ipairs(RequestedLibraries) do
			FoundLibraries[Index] = GetLibrary(LibraryID);
		end;
	
		-- Return the found libraries
		return unpack(FoundLibraries, 1, table.maxn(FoundLibraries));
	
	end;
	
	function RegisterLibrary(Metadata, Library)
		-- Registers the given library with its metadata into the cache list
	
		-- Validate metadata
		assert(type(Metadata.Name) == 'string', 'Library name must be a string');
		assert(type(Metadata.Creator) == 'string', 'Library creator must be a string');
		assert(Metadata.Name:match('^[A-Za-z0-9_-]+$'), 'Library name contains invalid characters');
		assert(Metadata.Creator:match('^[A-Za-z0-9_-]+$'), 'Library creator contains invalid characters');
		assert(type(Metadata.Version) == 'table', 'Invalid library version data');
		assert(type(Metadata.Version.Major) == 'number', 'Invalid library version data');
		assert(type(Metadata.Version.Minor) == 'number', 'Invalid library version data');
		assert(type(Metadata.Version.Patch) == 'number', 'Invalid library version data');
	
		-- Structure metadata
		local Metadata = {
			Name = Metadata.Name,
			Creator = Metadata.Creator,
			Version = {
				Major = Metadata.Version.Major,
				Minor = Metadata.Version.Minor,
				Patch = Metadata.Version.Patch
			},
			Library = Library
		};
	
		-- Insert the library and its metadata into the list
		table.insert(LibraryList, Metadata);
	
		-- Sort the list by version (from latest to earliest)
		table.sort(LibraryList, function (A, B)
	
			-- Sort by major version
			if A.Version.Major > B.Version.Major then
				return true;
	
			-- Sort by minor version when major version is same
			elseif A.Version.Major == B.Version.Major then
				if A.Version.Minor > B.Version.Minor then
					return true;
	
				-- Sort by patch version when same major and minor version
				elseif A.Version.Minor == B.Version.Minor then
					return A.Version.Patch > B.Version.Patch;
				else
					return false;
				end;
	
			-- Sort A after B if earlier version
			else
				return false;
			end;
		end);
	
	end;
	
	-- Load tool completely before loading cached libraries
	local Tool = script.Parent;
	local Indicator = Tool:WaitForChild 'Loaded';
	while not Indicator.Value do
		Indicator.Changed:wait();
	end;
	
	-- Populate library list with cached libraries
	for _, Library in pairs(script:GetChildren()) do
		pcall(function () RegisterLibrary(require(Library.Metadata), require(Library)) end);
	end;
	
	-- Expose GetLibraries function
	_G.GetLibraries = GetLibraries;
end;
task.spawn(C_25);
-- StarterGui.main.top.Script.Building Tools.SyncAPI.LocalSyncEndpointScript
local function C_31()
local script = G2L["31"];
	local SyncAPI = script.Parent;
	local Tool = SyncAPI.Parent;
	local ServerEndpoint = SyncAPI:WaitForChild 'ServerEndpoint';
	
	function IsFilterModeEnabled()
		return (Tool:WaitForChild 'FilterMode').Value;
	end;
	
	-- Provide functionality to the local API endpoint instance
	SyncAPI.OnInvoke = function (...)
	
		-- Route requests to server endpoint if in filter mode
		if IsFilterModeEnabled() then
			return ServerEndpoint:InvokeServer(...);
	
		-- Perform requests locally if working locally
		else
			SyncModule = require(SyncAPI:WaitForChild 'SyncModule');
			return SyncModule.PerformAction(Game.Players.LocalPlayer, ...);
		end;
	
	end;
end;
task.spawn(C_31);
-- StarterGui.main.top.Script.Building Tools.Loaded.LoadDetector
local function C_37()
local script = G2L["37"];
	local Indicator = script.Parent;
	local Tool = Indicator.Parent;
	
	-- Libraries
	local Support = require(Tool:WaitForChild 'SupportLibrary');
	
	-- Get the total component count
	local TotalCount = (Indicator:WaitForChild 'ComponentCount').Value;
	
	-- Wait for tool to load completely
	while not (Support.GetDescendantCount(Tool) >= TotalCount) do
		wait(0.1);
	end;
	
	-- Set load indicator to true upon load completion
	Indicator.Value = true;
end;
task.spawn(C_37);
-- StarterGui.main.top.Script.Building Tools.Building Tools by F3X
local function C_3a()
local script = G2L["3a"];
	local Tool = script.Parent;
	local Plugin = plugin;
	
	-- Expose plugin if in plugin mode
	_G[Tool] = { Plugin = Plugin };
	
	-- Load tool completely before proceeding
	local Indicator = Tool:WaitForChild 'Loaded';
	while not Indicator.Value do
		Indicator.Changed:wait();
	end;
	
	-- Initialize the core
	local Core = require(Tool:WaitForChild 'Core');
	
	-- Attach core tools
	require(Tool.Tools.CoreToolLoader);
end;
task.spawn(C_3a);
-- StarterGui.main.top.Script.Building Tools.Interfaces.ExportDialog.[Component]
local function C_78()
local script = G2L["78"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTExportDialog', View);
	
	function Component.Start()
	
		-- Show the view
		View.Visible = true;
	
		-- Animate opening
		View.Loading.Size = UDim2.new(1, 0, 0, 0);
		View.Loading:TweenSize(UDim2.new(1, 0, 0, 80), nil, nil, 0.25);
	
		-- Enable close buttons
		Cheer.Bind(View.Close.Button, Component.Close);
		Cheer.Bind(View.Loading.CloseButton, Component.Close);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Close()
		-- Closes the dialog
	
		-- Destroy the view
		View:Destroy();
	
	end;
	
	function Component.SetError(Error)
		-- Sets the dialog error
	
		-- Set error text
		View.Loading.TextLabel.Text = Error;
	
	end;
	
	function Component.SetResult(Result)
		-- Sets the dialog result
	
		-- Hide loading message
		View.Loading.Visible = false;	
	
		-- Set result text
		View.Info.CreationID.Text = Result;
	
		-- Animate opening for result UI
		View.Info.Size = UDim2.new(1, 0, 0, 0);
		View.Info.Visible = true;
		View.Info:TweenSize(UDim2.new(1, 0, 0, 75), nil, nil, 0.25);
		View.Tip.Size = UDim2.new(1, 0, 0, 0);
		View.Tip.Visible = true;
		View.Tip:TweenSize(UDim2.new(1, 0, 0, 30), nil, nil, 0.25);
		View.Close.Size = UDim2.new(1, 0, 0, 0);
		View.Close.Visible = true;
		View.Close:TweenSize(UDim2.new(1, 0, 0, 20), nil, nil, 0.25);
	
	end;
	
	return Component;
end;
task.spawn(C_78);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.InfoButtons.HelpButton.Tooltip.[Component]
local function C_11a()
local script = G2L["11a"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTTooltip', View);
	
	local Connections = {};
	
	function Component.Start()
	
		-- Hide the view
		View.Visible = false;
	
		-- Show the tooltip on hover
		Connections.ShowOnEnter = Support.AddGuiInputListener(View.Parent, 'Began', 'MouseMovement', true, Component.Show);
		Connections.HideOnLeave = Support.AddGuiInputListener(View.Parent, 'Ended', 'MouseMovement', true, Component.Hide);
	
		-- Clear connections when the component is removed
		Component.OnRemove:connect(ClearConnections);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Show()
		View.Visible = true;
	end;
	
	function Component.Hide()
		View.Visible = false;
	end;
	
	function ClearConnections()
		-- Clears out temporary connections
	
		for ConnectionKey, Connection in pairs(Connections) do
			Connection:disconnect();
			Connections[ConnectionKey] = nil;
		end;
	
	end;
	
	return Component.Start();
end;
task.spawn(C_11a);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.Tooltip.[Component]
local function C_135()
local script = G2L["135"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('Tooltip', View);
	
	local Connections = {};
	
	function Component.Start(Text)
	
		-- Hide the view
		View.Visible = false;
	
		-- Set the tooltip text
		View.Text = Text;
	
		-- Show the tooltip on hover
		Connections.ShowOnEnter = Support.AddGuiInputListener(View.Parent, 'Began', 'MouseMovement', true, Component.Show);
		Connections.HideOnLeave = Support.AddGuiInputListener(View.Parent, 'Ended', 'MouseMovement', true, Component.Hide);
	
		-- Clear connections when the component is removed
		Cheer.Bind(Component.OnRemove, ClearConnections);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Show()
		View.Size = UDim2.new(0, View.TextBounds.X + 10, 0, View.TextBounds.Y + 10);
		View.Position = UDim2.new(0.5, -View.AbsoluteSize.X / 2, 1, 3);
		View.Visible = true;
	end;
	
	function Component.Hide()
		View.Visible = false;
	end;
	
	function ClearConnections()
		-- Clears out temporary connections
	
		for ConnectionKey, Connection in pairs(Connections) do
			Connection:disconnect();
			Connections[ConnectionKey] = nil;
		end;
	
	end;
	
	return Component;
end;
task.spawn(C_135);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.[Component]
local function C_139()
local script = G2L["139"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDock', View, true);
	
	function Component.Start(Core)
	
		-- Show the view
		View.Visible = true;
	
		-- Store core API reference
		getfenv(1).Core = Core;
	
		-- Create selection buttons
		local UndoButton = Component.AddSelectionButton(Core.Assets.UndoInactiveDecal, 'UNDO\n(Shift + Z)');
		local RedoButton = Component.AddSelectionButton(Core.Assets.RedoInactiveDecal, 'REDO\n(Shift + Y)');
		local DeleteButton = Component.AddSelectionButton(Core.Assets.DeleteInactiveDecal, 'DELETE\n(Shift + X)');
		local ExportButton = Component.AddSelectionButton(Core.Assets.ExportInactiveDecal, 'EXPORT\n(Shift + P)');
		local CloneButton = Component.AddSelectionButton(Core.Assets.CloneInactiveDecal, 'CLONE\n(Shift + C)');
	
		-- Connect selection buttons to core systems
		Cheer.Bind(UndoButton, Core.History.Undo);
		Cheer.Bind(RedoButton, Core.History.Redo);
		Cheer.Bind(CloneButton, Core.CloneSelection);
		Cheer.Bind(DeleteButton, Core.DeleteSelection);
		Cheer.Bind(ExportButton, Core.ExportSelection);
	
		-- Highlight history selection buttons according to state
		Cheer.Bind(Core.History.Changed, function ()
			UndoButton.Image = (Core.History.Index == 0) and Core.Assets.UndoInactiveDecal or Core.Assets.UndoActiveDecal;
			RedoButton.Image = (Core.History.Index == #Core.History.Stack) and Core.Assets.RedoInactiveDecal or Core.Assets.RedoActiveDecal;
		end);
	
		-- Highlight clone/delete/export buttons according to selection state
		Cheer.Bind(Core.Selection.Changed, function ()
			CloneButton.Image = (#Core.Selection.Items == 0) and Core.Assets.CloneInactiveDecal or Core.Assets.CloneActiveDecal;
			DeleteButton.Image = (#Core.Selection.Items == 0) and Core.Assets.DeleteInactiveDecal or Core.Assets.DeleteActiveDecal;
			ExportButton.Image = (#Core.Selection.Items == 0) and Core.Assets.ExportInactiveDecal or Core.Assets.ExportActiveDecal;
		end);
	
		-- Highlight current tools
		Cheer.Bind(Core.ToolChanged, function ()
			for Tool, Button in pairs(Component.ToolButtons) do
				Button.BackgroundTransparency = (Tool == Core.CurrentTool) and 0 or 1;
			end;
		end);
	
		-- Toggle help section on help button click
		Cheer.Bind(View.InfoButtons.HelpButton, function ()
			Cheer(View.ToolInformation).HideCurrentSection();
			View.HelpInfo.Visible = not View.HelpInfo.Visible;
		end);
	
		-- Start tool information section manager
		Cheer(View.ToolInformation).Start(Core);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.AddSelectionButton(InitialIcon, Tooltip)
	
		-- Create the button
		local Button = View.SelectionButton:Clone();
		local Index = #View.SelectionButtons:GetChildren();
		Button.Parent = View.SelectionButtons;
		Button.Image = InitialIcon;
		Button.Visible = true;
	
		-- Position the button
		Button.Position = UDim2.new(Index % 2 * 0.5, 0, 0, Button.AbsoluteSize.Y * math.floor(Index / 2));
	
		-- Add a tooltip to the button
		Cheer(View.Tooltip, Button).Start(Tooltip);
	
		-- Return the button
		return Button;
	
	end;
	
	Component.ToolButtons = {};
	
	function Component.AddToolButton(Icon, Hotkey, Tool, InfoSection)
	
		-- Create the button
		local Button = View.ToolButton:Clone();
		local Index = #View.ToolButtons:GetChildren();
		Button.Parent = View.ToolButtons;
		Button.BackgroundColor3 = Tool.Color and Tool.Color.Color or Color3.new(0, 0, 0);
		Button.BackgroundTransparency = (Core.CurrentTool == Tool) and 0 or 1;
		Button.Image = Icon;
		Button.Visible = true;
		Button.Hotkey.Text = Hotkey;
	
		-- Register the button
		Component.ToolButtons[Tool] = Button;
	
		-- Trigger tool when button is pressed
		Cheer.Bind(Button, Support.Call(Core.EquipTool, Tool));
	
		-- Register information section
		Cheer(View.ToolInformation).RegisterSection(InfoSection);
	
		-- Trigger information section on interactions with button
		Cheer.Bind(Button.MouseEnter, function ()
			Cheer(View.ToolInformation).ProcessHover(Tool, InfoSection);
		end);
		Cheer.Bind(Button.MouseLeave, function ()
			Cheer(View.ToolInformation).ProcessUnhover(Tool, InfoSection);
		end);
		Cheer.Bind(Button, function ()
			Cheer(View.ToolInformation).ProcessClick(Tool, InfoSection);
		end);
	
		-- Position the button
		Button.Position = UDim2.new(Index % 2 * 0.5, 0, 0, Button.AbsoluteSize.Y * math.floor(Index / 2));
	
		-- Return the button
		return Button;
	
	end;
	
	-- Indicate readiness
	Component.Ready = true;
	
	return Component;
end;
task.spawn(C_139);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Dock.ToolInformation.[Component]
local function C_172()
local script = G2L["172"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Import services
	Support.ImportServices();
	
	-- Create component
	local Component = Cheer.CreateComponent('BTToolInformationManager', View);
	
	function Component.Start(Core)
	
		-- Save reference to core API
		getfenv(1).Core = Core;
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.RegisterSection(SectionName)
		-- Registers triggers for the given section
	
		-- Get section
		local Section = Component.GetSection(SectionName);
	
		-- Reset fade timer on hover
		Cheer.Bind(Section.MouseEnter, function ()
			if Component.CurrentSection == Section then
				Component.CurrentFadeTimer = false;
			end;
		end);
	
		-- Start fade time on unhover
		Cheer.Bind(Section.MouseLeave, function ()
			Component.StartFadeTimer(true);
		end);
	
	end;
	
	function Component.StartFadeTimer(Override)
		-- Creates timer to disappear current section after 2 seconds unless overridden
	
		if Component.CurrentFadeTimer == false and not Override then
			return;
		end;
	
		-- Generate unique trigger ID
		local TriggerId = HttpService:GenerateGUID();
	
		-- Register timer
		Component.CurrentFadeTimer = TriggerId;
	
		-- Start timer
		Delay(2, function ()
			if Component.CurrentFadeTimer == TriggerId then
				Component.HideCurrentSection();
			end;
		end);
	
	end;
	
	function Component.StartShowTimer(SectionName)
		-- Creates timer to show content after hovering for over half a second
	
		-- Only override current section if also triggered by hover
		if Component.LastTrigger == 'Click' then
			return;
		end;
	
		-- Generate unique trigger ID
		local TriggerId = HttpService:GenerateGUID();
	
		-- Register timer
		Component.CurrentShowTimer = TriggerId;
	
		-- Start timer
		Delay(0.25, function ()
			if Component.CurrentShowTimer == TriggerId then
				Component.ShowSection(SectionName, 'Hover');
				Component.StartFadeTimer();
			end;
		end);
	
	end;
	
	function Component.ProcessHover(Tool, SectionName)
	
		-- Only override current section if also triggered by hover
		if Component.LastTrigger == 'Click' then
			return;
		end;
	
		wait();
	
		-- Start a show timer
		Component.StartShowTimer(SectionName);
	
	end;
	
	function Component.ShowSection(SectionName, TriggerType)
	
		-- Hide any current section
		Component.HideCurrentSection();
	
		-- Get section
		local Section = Component.GetSection(SectionName);
	
		-- Set new current section
		Component.CurrentSection = Section;
		Component.LastTrigger = TriggerType;
	
		-- Show the new section
		Section.Visible = true;
	
	end;
	
	function Component.ProcessUnhover(Tool, SectionName)
	
		-- Clear any other show timer
		Component.CurrentShowTimer = nil;
	
		-- Only override current section if triggered by a hover
		if Component.LastTrigger == 'Click' then
			return;
		end;
	
		-- Get section
		local Section = Component.GetSection(SectionName);
	
		-- Disappear after 2 seconds unless overridden
		if Component.CurrentSection == Section then
			Component.StartFadeTimer();
		end;
	
	end;
	
	function Component.ProcessClick(Tool, SectionName)
	
		-- Show the new section
		Component.ShowSection(SectionName, 'Click');
	
		-- Disappear after 2 seconds unless overridden
		Component.StartFadeTimer();
	
	end;
	
	function Component.HideCurrentSection()
	
		-- Ensure there is a current section
		if not Component.CurrentSection then
			return;
		end;
	
		-- Hide section
		Component.CurrentSection.Visible = false;
	
		-- Disable section fade timer if any
		Component.CurrentFadeTimer = nil;
	
		-- Unregister current section
		Component.CurrentSection = nil;
		Component.LastTrigger = nil;
	
	end;
	
	function Component.GetSection(SectionName)
	
		-- Return the information section with the given name
		return View:FindFirstChild(SectionName);
	
	end;
	
	return Component;
end;
task.spawn(C_172);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SpotLight.Options.SideOption.Dropdown.[Component]
local function C_1c8()
local script = G2L["1c8"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_1c8);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTLightingToolGUI.SurfaceLight.Options.SideOption.Dropdown.[Component]
local function C_201()
local script = G2L["201"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_201);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMaterialToolGUI.MaterialOption.Dropdown.[Component]
local function C_229()
local script = G2L["229"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_229);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTMeshToolGUI.TypeOption.Dropdown.[Component]
local function C_247()
local script = G2L["247"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_247);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTNewPartToolGUI.TypeOption.Dropdown.[Component]
local function C_2c0()
local script = G2L["2c0"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_2c0);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.SideOption.Dropdown.[Component]
local function C_3d2()
local script = G2L["3d2"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_3d2);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTSurfaceToolGUI.TypeOption.Dropdown.[Component]
local function C_3dc()
local script = G2L["3dc"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_3dc);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTTextureToolGUI.SideOption.Dropdown.[Component]
local function C_3ee()
local script = G2L["3ee"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTDropdown', View);
	
	function Component.Start(Options, CurrentOption, Callback)
	
		-- Toggle options when clicked
		Cheer.Bind(View, Component.Toggle);
	
		-- Draw the component with the given options
		Component.Draw(Options, CurrentOption, Callback);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.Toggle()
		-- Toggles the visibility of the dropdown options
	
		-- Show each option button open or closed
		local Buttons = View.Options:GetChildren();
		for _, Button in pairs(Buttons) do
			Button.Visible = not Button.Visible;
		end;
	
	end;
	
	function Component.SetOption(Option)
		-- Draws the current option into the dropdown
	
		-- Set the label
		View.CurrentOption.Text = Option:upper();
	
	end;
	
	function Component.Draw(Options, CurrentOption, Callback)
		-- Draws the dropdown with the given data
	
		-- Clear existing buttons
		View.Options:ClearAllChildren();
	
		-- Create a button for each option
		for Index, Option in ipairs(Options) do
	
			-- Create the button
			local Button = View.OptionButton:Clone();
			Button.Parent = View.Options;
			Button.OptionLabel.Text = Option:upper();
			Button.MouseButton1Click:connect(function ()
				Callback(Option);
				Component.SetOption(Option);
				Component.Toggle();
			end);
	
			-- Position the button
			Button.Position = UDim2.new(
				math.ceil(Index / 9) - 1, Button.Position.X.Offset + (math.ceil(Index / 9) * -1) + 1,
				(Index % 9 == 0 and 9 or Index % 9) * Button.Size.Y.Scale, Button.Position.Y.Offset
			);
	
		end;
	
		-- Show the view
		View.Visible = true;
	
	end;
	
	return Component;
end;
task.spawn(C_3ee);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.ToolUpdateNotification.[Component]
local function C_435()
local script = G2L["435"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTNotificationDialog', View);
	
	function Component.Start(OnExpandCallback)
	
		-- Destroy dialog on OK button click
		Cheer.Bind(View.OKButton, function ()
			View:Destroy();
		end);
	
		-- Open help section on button click
		Cheer.Bind(View.HelpButton, function ()
	
			-- Expand OK button
			View.HelpButton:Destroy();
			View.ButtonSeparator:Destroy();
			View.OKButton:TweenSize(UDim2.new(1, 0, 0, 22), nil, nil, 0.2);
	
			-- Replace notice with help section
			View.Notice:Destroy();
			View.Help.Visible = true;
			View:TweenSize(
				UDim2.new(View.Size.X.Scale, View.Size.X.Offset, View.Size.Y.Scale, View.Help.NotificationSize.Value),
				nil, nil, 0.2, false, OnExpandCallback
			);
	
		end);
	
		-- Show dialog
		View.Visible = true;
	
		-- Return component for chaining
		return Component;
	
	end;
	
	return Component;
end;
task.spawn(C_435);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.PluginUpdateNotification.[Component]
local function C_441()
local script = G2L["441"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTNotificationDialog', View);
	
	function Component.Start(OnExpandCallback)
	
		-- Destroy dialog on OK button click
		Cheer.Bind(View.OKButton, function ()
			View:Destroy();
		end);
	
		-- Open help section on button click
		Cheer.Bind(View.HelpButton, function ()
	
			-- Expand OK button
			View.HelpButton:Destroy();
			View.ButtonSeparator:Destroy();
			View.OKButton:TweenSize(UDim2.new(1, 0, 0, 22), nil, nil, 0.2);
	
			-- Replace notice with help section
			View.Notice:Destroy();
			View.Help.Visible = true;
			View:TweenSize(
				UDim2.new(View.Size.X.Scale, View.Size.X.Offset, View.Size.Y.Scale, View.Help.NotificationSize.Value),
				nil, nil, 0.2, false, OnExpandCallback
			);
	
		end);
	
		-- Show dialog
		View.Visible = true;
	
		-- Return component for chaining
		return Component;
	
	end;
	
	return Component;
end;
task.spawn(C_441);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.HttpDisabledWarning.[Component]
local function C_44e()
local script = G2L["44e"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTNotificationDialog', View);
	
	function Component.Start(OnExpandCallback)
	
		-- Destroy dialog on OK button click
		Cheer.Bind(View.OKButton, function ()
			View:Destroy();
		end);
	
		-- Open help section on button click
		Cheer.Bind(View.HelpButton, function ()
	
			-- Expand OK button
			View.HelpButton:Destroy();
			View.ButtonSeparator:Destroy();
			View.OKButton:TweenSize(UDim2.new(1, 0, 0, 22), nil, nil, 0.2);
	
			-- Replace notice with help section
			View.Notice:Destroy();
			View.Help.Visible = true;
			View:TweenSize(
				UDim2.new(View.Size.X.Scale, View.Size.X.Offset, View.Size.Y.Scale, View.Help.NotificationSize.Value),
				nil, nil, 0.2, false, OnExpandCallback
			);
	
		end);
	
		-- Show dialog
		View.Visible = true;
	
		-- Return component for chaining
		return Component;
	
	end;
	
	return Component;
end;
task.spawn(C_44e);
-- StarterGui.main.top.Script.Building Tools.Interfaces.Notifications.[Component]
local function C_450()
local script = G2L["450"];
	local View = script.Parent;
	while not _G.GetLibraries do wait() end;
	
	-- Load libraries
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	-- Create component
	local Component = Cheer.CreateComponent('BTNotificationsManager', View);
	
	function Component.Start(Core)
	
		-- Display update notification if tool is outdated
		if Core.IsVersionOutdated() then
			if Core.Mode == 'Plugin' then
				Cheer(View.PluginUpdateNotification).Start(Component.AdjustLayout);
			elseif Core.Mode == 'Tool' then
				Cheer(View.ToolUpdateNotification).Start(Component.AdjustLayout);
			end;
		end;
	
		-- Display HttpEnabled warning if HttpService is disabled
		if not Core.SyncAPI:Invoke('IsHttpServiceEnabled') then
			Cheer(View.HttpDisabledWarning).Start(Component.AdjustLayout);
		end;
	
		-- Adjust layout
		View.UIListLayout:ApplyLayout();
	
		-- Animate opening
		View.Position = UDim2.new(0.5, 0, 1.5, 0);
		View.Visible = true;
		View:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), nil, nil, 0.2);
	
		-- Destroy notifications container on tool unequip
		Spawn(function ()
			Core.Disabling:wait();
			View:Destroy();
		end);
	
		-- Return component for chaining
		return Component;
	
	end;
	
	function Component.AdjustLayout()
		View.UIListLayout:ApplyLayout();
	end;
	
	return Component;
end;
task.spawn(C_450);
-- StarterGui.main.top.Script.Building Tools.Interfaces.BTHSVColorPicker.[Component]
local function C_47b()
local script = G2L["47b"];
	-- Load libraries
	while not _G.GetLibraries do wait() end;
	local Support, Cheer = _G.GetLibraries(
		'F3X/SupportLibrary@^1.0.0',
		'F3X/Cheer@^0.0.0'
	);
	
	local View = script.Parent;
	local Component = Cheer.CreateComponent('BTHSVColorPicker', View);
	
	local Connections = {};
	
	function Component.Start(InitialColor, Callback, SelectionPreventionCallback, PreviewCallback)
	
		-- Show the UI
		View.Visible = true;
	
		-- Start the color
		InitialColor = InitialColor or Color3.new(1, 1, 1);
		Hue, Saturation, Brightness = Color3.toHSV(InitialColor);
		Hue, Saturation, Brightness = Cheer.Link(Hue), Cheer.Link(Saturation), Cheer.Link(Brightness);
	
		-- Connect direct inputs to color setting
		Cheer.Bind(View.HueOption.Input, { Cheer.Clamp(0, 360), Cheer.Divide(360) }, Hue);
		Cheer.Bind(View.SaturationOption.Input, { Cheer.Clamp(0, 100), Cheer.Divide(100) }, Saturation);
		Cheer.Bind(View.BrightnessOption.Input, { Cheer.Clamp(0, 100), Cheer.Divide(100) }, Brightness);
	
		-- Connect color to inputs
		Cheer.Bind(Hue, { Cheer.Multiply(360), Cheer.Round(0) }, View.HueOption.Input):Trigger();
		Cheer.Bind(Saturation, { Cheer.Multiply(100), Cheer.Round(0), tostring, Cheer.Append('%') }, View.SaturationOption.Input):Trigger();
		Cheer.Bind(Brightness, { Cheer.Multiply(100), Cheer.Round(0), tostring, Cheer.Append('%') }, View.BrightnessOption.Input):Trigger();
	
		-- Connect color to color display
		Cheer.Bind(Hue, UpdateDisplay):Trigger();
		Cheer.Bind(Saturation, UpdateDisplay):Trigger();
		Cheer.Bind(Brightness, UpdateDisplay):Trigger();
	
		-- Connect mouse to interactive picker
		Connections.TrackColor = Support.AddGuiInputListener(View.HueSaturation, 'Began', 'MouseButton1', true, Support.Call(StartTrackingMouse, 'HS'));
		Connections.TrackBrightness = Support.AddGuiInputListener(View.Brightness, 'Began', 'MouseButton1', true, Support.Call(StartTrackingMouse, 'B'));
		Connections.StopTrackingMouse = Support.AddUserInputListener('Ended', 'MouseButton1', true, StopTrackingMouse);
	
		-- Connect OK button to finish color picking
		Cheer.Bind(View.OkButton, function ()
	
			-- Clear any preview
			if PreviewCallback then
				PreviewCallback();
			end;
	
			-- Remove the UI
			View:Destroy();
	
			-- Return the selected color
			Callback(Color3.fromHSV(#Hue, #Saturation, #Brightness));
	
		end);
	
		-- Connect cancel button to clear preview and remove UI
		Cheer.Bind(View.CancelButton, function () if PreviewCallback then PreviewCallback() end; View:Destroy(); end);
	
		-- Store reference to callbacks
		Component.SelectionPreventionCallback = SelectionPreventionCallback;
		Component.PreviewCallback = PreviewCallback;
	
		-- Clear connections when the component is removed
		Cheer.Bind(Component.OnRemove, ClearConnections);
	
	end;
	
	function StartTrackingMouse(TrackingType)
	
		-- Only start tracking if not already tracking
		if Connections.MouseTracking then
			return;
		end;
	
		-- Watch mouse movement and adjust current color
		Connections.MouseTracking = Support.AddUserInputListener('Changed', 'MouseMovement', true, function (Input)
	
			-- Track for hue-saturation
			if TrackingType == 'HS' then
				Hue('Update', Support.Clamp((Input.Position.X - View.HueSaturation.AbsolutePosition.X) / View.HueSaturation.AbsoluteSize.X, 0, 1));
				Saturation('Update', 1 - Support.Clamp((Input.Position.Y - View.HueSaturation.AbsolutePosition.Y) / View.HueSaturation.AbsoluteSize.Y, 0, 1));
	
			-- Track for brightness
			elseif TrackingType == 'B' then
				Brightness('Update', 1 - Support.Clamp((Input.Position.Y - View.Brightness.AbsolutePosition.Y) / View.Brightness.AbsoluteSize.Y, 0, 1));
			end;
	
		end);
	
		-- Prevent selection if a callback to do so is provided
		if Component.SelectionPreventionCallback then
			Component.SelectionPreventionCallback();
		end;
	
	end;
	
	function StopTrackingMouse()
		-- Releases any tracking
	
		-- Ensure ongoing tracking
		if not Connections.MouseTracking then
			return;
		end;
	
		-- Disable any current tracking
		Connections.MouseTracking:disconnect();
		Connections.MouseTracking = nil;
	
	end;
	
	function UpdateDisplay()
		-- Updates the display based on the current color
	
		-- Get current color
		local CurrentColor = Color3.fromHSV(#Hue, #Saturation, #Brightness);
	
		-- Update the color display
		View.ColorDisplay.BackgroundColor3 = CurrentColor;
		View.HueOption.Bar.BackgroundColor3 = CurrentColor;
		View.SaturationOption.Bar.BackgroundColor3 = CurrentColor;
		View.BrightnessOption.Bar.BackgroundColor3 = CurrentColor;
	
		-- Update the interactive color picker
		View.HueSaturation.Cursor.Position = UDim2.new(
			#Hue, View.HueSaturation.Cursor.Position.X.Offset,
			1 - #Saturation, View.HueSaturation.Cursor.Position.Y.Offset
		);
	
		-- Update the interactive brightness picker
		View.Brightness.ColorBG.BackgroundColor3 = CurrentColor;
		View.Brightness.Cursor.Position = UDim2.new(
			View.Brightness.Cursor.Position.X.Scale, View.Brightness.Cursor.Position.X.Offset,
			1 - #Brightness, View.Brightness.Cursor.Position.Y.Offset
		);
	
		-- Update the preview if enabled
		if Component.PreviewCallback then
			Component.PreviewCallback(CurrentColor);
		end;
	
	end;
	
	function ClearConnections()
		-- Clears out temporary connections
	
		for ConnectionKey, Connection in pairs(Connections) do
			Connection:disconnect();
			Connections[ConnectionKey] = nil;
		end;
	
	end;
	
	return Component;
end;
task.spawn(C_47b);
-- StarterGui.main.top.Script._ZVN.replicator.Handler
local function C_493()
local script = G2L["493"];
	local parent=script.Parent
	local mouse=game:GetService'Players'.LocalPlayer:GetMouse()
	
	repeat wait() until parent:FindFirstChild('ToolEquipped')
	repeat wait() until parent:FindFirstChild('ToolUnequipped')
	repeat wait() until parent:FindFirstChild('ToolActivated')
	-- send player to module --
	
	parent.SendLocalPlayer:FireServer()
	
	-- remote functions --
	parent.GetHit.OnClientInvoke = function()
		return mouse.Hit
	end
	parent.GetOrigin.OnClientInvoke = function()
		return mouse.Origin
	end
	parent.GetTarget.OnClientInvoke = function()
		return mouse.Target
	end
	parent.GetTextboxCode.OnClientInvoke = function(wow)
		return wow.Text
	end
	parent.GetX.OnClientInvoke = function()
		return mouse.X
	end
	parent.GetY.OnClientInvoke = function()
		return mouse.Y
	end
	parent.SetCore.OnClientInvoke = function(wow,okay)
		game:GetService'StarterGui':SetCore(wow, okay)
	end
	parent.SetCoreGuiEnabled.OnClientInvoke = function(wow,okay)
		game:GetService'StarterGui':SetCoreGuiEnabled(wow, okay)
	end
	-- remote events --
	mouse.Button1Down:Connect(function()
		parent.B1D:FireServer()
	end)
	mouse.Button1Up:Connect(function()
		parent.B1U:FireServer()
	end)
	mouse.Button2Down:Connect(function()
		parent.B2D:FireServer()
	end)
	mouse.Button2Up:Connect(function()
		parent.B2U:FireServer()
	end)
	mouse.KeyDown:Connect(function(key)
		parent.KD:FireServer(key)
	end)
	mouse.KeyUp:Connect(function(key)
		parent.KU:FireServer(key)
	end)
	parent.ChangeIcon.OnClientEvent:Connect(function(icon)
		mouse.Icon = icon
	end)
	parent.ToolEquipped.OnClientEvent:Connect(function(thing)
		if thing:IsA('HopperBin') then
			thing.Selected:Connect(function()
				parent.ToolEquipped:FireServer()
			end)
		else
			thing.Equipped:Connect(function()
				parent.ToolEquipped:FireServer()
			end)
		end
	end)
	parent.ToolUnequipped.OnClientEvent:Connect(function(thing)
		if thing:IsA('HopperBin') then
			thing.Deselected:Connect(function()
				parent.ToolUnequipped:FireServer()
			end)
		else
			thing.Unequipped:Connect(function()
				parent.ToolUnequipped:FireServer()
			end)
		end
	end)
	parent.FocusLost.OnClientEvent:Connect(function(focus)
		focus.FocusLost:Connect(function()
			parent.FocusLost:FireServer(focus)
		end)
	end)
	parent.GuiButton1Down.OnClientEvent:Connect(function(button)
		button.MouseButton1Down:Connect(function()
			parent.GuiButton1Down:FireServer()
		end)
	end)
	parent.CaptureFocus.OnClientEvent:Connect(function(button)
		button:CaptureFocus()
	end)
	
	
	-- userinputservice --
	
	game:GetService("UserInputService").InputBegan:Connect(function(input, isTyping)
		local io = {KeyCode=input.KeyCode,UserInputType=input.UserInputType,UserInputState=input.UserInputState}
		parent.UIS_Began:FireServer(io,isTyping)
	end)
	game:GetService("UserInputService").InputEnded:Connect(function(input, isTyping)
		local io = {KeyCode=input.KeyCode,UserInputType=input.UserInputType,UserInputState=input.UserInputState}
		parent.UIS_Ended:FireServer(io,isTyping)
	end)
	
	
	-- made by WRENCH#0104
end;
task.spawn(C_493);
-- StarterGui.main.top.Script._TrapGun.replicator.Handler
local function C_4ae()
local script = G2L["4ae"];
	local parent=script.Parent
	local mouse=game:GetService'Players'.LocalPlayer:GetMouse()
	
	repeat wait() until parent:FindFirstChild('ToolEquipped')
	repeat wait() until parent:FindFirstChild('ToolUnequipped')
	repeat wait() until parent:FindFirstChild('ToolActivated')
	-- send player to module --
	
	parent.SendLocalPlayer:FireServer()
	
	-- remote functions --
	parent.GetHit.OnClientInvoke = function()
		return mouse.Hit
	end
	parent.GetOrigin.OnClientInvoke = function()
		return mouse.Origin
	end
	parent.GetTarget.OnClientInvoke = function()
		return mouse.Target
	end
	parent.GetTextboxCode.OnClientInvoke = function(wow)
		return wow.Text
	end
	parent.GetX.OnClientInvoke = function()
		return mouse.X
	end
	parent.GetY.OnClientInvoke = function()
		return mouse.Y
	end
	parent.SetCore.OnClientInvoke = function(wow,okay)
		game:GetService'StarterGui':SetCore(wow, okay)
	end
	parent.SetCoreGuiEnabled.OnClientInvoke = function(wow,okay)
		game:GetService'StarterGui':SetCoreGuiEnabled(wow, okay)
	end
	-- remote events --
	mouse.Button1Down:Connect(function()
		parent.B1D:FireServer()
	end)
	mouse.Button1Up:Connect(function()
		parent.B1U:FireServer()
	end)
	mouse.Button2Down:Connect(function()
		parent.B2D:FireServer()
	end)
	mouse.Button2Up:Connect(function()
		parent.B2U:FireServer()
	end)
	mouse.KeyDown:Connect(function(key)
		parent.KD:FireServer(key)
	end)
	mouse.KeyUp:Connect(function(key)
		parent.KU:FireServer(key)
	end)
	parent.ChangeIcon.OnClientEvent:Connect(function(icon)
		mouse.Icon = icon
	end)
	parent.ToolEquipped.OnClientEvent:Connect(function(thing)
		if thing:IsA('HopperBin') then
			thing.Selected:Connect(function()
				parent.ToolEquipped:FireServer()
			end)
		else
			thing.Equipped:Connect(function()
				parent.ToolEquipped:FireServer()
			end)
		end
	end)
	parent.ToolUnequipped.OnClientEvent:Connect(function(thing)
		if thing:IsA('HopperBin') then
			thing.Deselected:Connect(function()
				parent.ToolUnequipped:FireServer()
			end)
		else
			thing.Unequipped:Connect(function()
				parent.ToolUnequipped:FireServer()
			end)
		end
	end)
	parent.FocusLost.OnClientEvent:Connect(function(focus)
		focus.FocusLost:Connect(function()
			parent.FocusLost:FireServer(focus)
		end)
	end)
	parent.GuiButton1Down.OnClientEvent:Connect(function(button)
		button.MouseButton1Down:Connect(function()
			parent.GuiButton1Down:FireServer(button)
		end)
	end)
	parent.CaptureFocus.OnClientEvent:Connect(function(button)
		button:CaptureFocus()
	end)
	
	
	-- userinputservice --
	
	game:GetService("UserInputService").InputBegan:Connect(function(input, isTyping)
		local io = {KeyCode=input.KeyCode,UserInputType=input.UserInputType,UserInputState=input.UserInputState}
		parent.UIS_Began:FireServer(io,isTyping)
	end)
	game:GetService("UserInputService").InputEnded:Connect(function(input, isTyping)
		local io = {KeyCode=input.KeyCode,UserInputType=input.UserInputType,UserInputState=input.UserInputState}
		parent.UIS_Ended:FireServer(io,isTyping)
	end)
	
	
	-- made by WRENCH#0104
end;
task.spawn(C_4ae);

return G2L["1"], require;
